{"ast":null,"code":"import { getMinPointsDelta, getActualDesiredIntervalsCount, setRange, triggerLabelRender } from '../../common/utils/helper';\nimport { DoubleRange } from '../utils/double-range';\nimport { withIn, logBase } from '../../common/utils/helper';\nimport { isNullOrUndefined, extend, getValue } from '@syncfusion/ej2-base';\n/**\n * The `Double` module is used to render the numeric axis in charts.\n */\nvar Double = /** @class */function () {\n  /**\n   * Constructor for the dateTime module.\n   *\n   * @private\n   * @param {Chart} chart - Specifies the chart.\n   */\n  function Double(chart) {\n    this.isColumn = 0;\n    this.isStacking = false;\n    this.chart = chart;\n  }\n  /**\n   * Numeric Nice Interval for the axis.\n   *\n   * @private\n   * @param {Axis} axis - The axis.\n   * @param {number} delta - The delta value.\n   * @param {Size} size - The size.\n   * @returns {number} - The calculated nice interval.\n   */\n  Double.prototype.calculateNumericNiceInterval = function (axis, delta, size) {\n    var actualDesiredIntervalsCount = getActualDesiredIntervalsCount(size, axis);\n    var niceInterval = delta / actualDesiredIntervalsCount;\n    if (!isNullOrUndefined(axis.desiredIntervals)) {\n      if (this.isAutoIntervalOnBothAxis(axis)) {\n        return niceInterval;\n      }\n    }\n    var minInterval = Math.pow(10, Math.floor(logBase(niceInterval, 10)));\n    for (var _i = 0, _a = axis.intervalDivs; _i < _a.length; _i++) {\n      var interval = _a[_i];\n      var currentInterval = minInterval * interval;\n      if (actualDesiredIntervalsCount < delta / currentInterval) {\n        break;\n      }\n      niceInterval = currentInterval;\n    }\n    return niceInterval;\n  };\n  /**\n   * Determines whether auto interval is enabled on both axes.\n   *\n   * @private\n   * @param {Axis} axis - The axis.\n   * @returns {boolean} - The boolean value indicating if auto interval is enabled on both axes.\n   */\n  Double.prototype.isAutoIntervalOnBothAxis = function (axis) {\n    if ((axis.zoomFactor < 1 || axis.zoomPosition > 0) && axis.enableAutoIntervalOnZooming) {\n      return false;\n    } else {\n      return true;\n    }\n  };\n  Double.prototype.getActualRange = function (axis, size) {\n    this.initializeDoubleRange(axis);\n    if (!axis.startFromZero && this.isColumn > 0) {\n      axis.actualRange.interval = axis.interval || this.calculateNumericNiceInterval(axis, axis.doubleRange.delta, size);\n      axis.actualRange.max = axis.doubleRange.end + axis.actualRange.interval;\n      if (axis.doubleRange.start - axis.actualRange.interval < 0 && axis.doubleRange.start > 0) {\n        axis.actualRange.min = 0;\n      } else {\n        axis.actualRange.min = axis.doubleRange.start - (this.isStacking ? 0 : axis.actualRange.interval);\n      }\n    } else {\n      axis.actualRange.interval = axis.interval || this.calculateNumericNiceInterval(axis, axis.doubleRange.delta, size);\n      axis.actualRange.min = axis.doubleRange.start;\n      axis.actualRange.max = axis.doubleRange.end;\n    }\n  };\n  /**\n   * Range for the axis.\n   *\n   * @private\n   * @param {Axis} axis - The axis.\n   * @returns {void}\n   */\n  Double.prototype.initializeDoubleRange = function (axis) {\n    //Axis Min\n    if (axis.minimum !== null) {\n      this.min = axis.minimum;\n    } else if (this.min === null || this.min === Number.POSITIVE_INFINITY) {\n      this.min = 0;\n    }\n    // Axis Max\n    if (axis.maximum !== null) {\n      this.max = axis.maximum;\n    } else if (this.max === null || this.max === Number.NEGATIVE_INFINITY) {\n      this.max = 5;\n    }\n    if (this.min === this.max) {\n      this.max = axis.valueType.indexOf('Category') > -1 ? this.max : this.min + 1;\n    }\n    axis.doubleRange = new DoubleRange(this.min, this.max);\n    axis.actualRange = {};\n  };\n  /**\n   * The function to calculate the range and labels for the axis.\n   *\n   * @returns {void}\n   * @private\n   */\n  Double.prototype.calculateRangeAndInterval = function (size, axis) {\n    this.calculateRange(axis);\n    this.getActualRange(axis, size);\n    this.applyRangePadding(axis, size);\n    this.calculateVisibleLabels(axis, this.chart);\n  };\n  /**\n   * Calculate Range for the axis.\n   *\n   * @private\n   */\n  Double.prototype.calculateRange = function (axis) {\n    /** Generate axis range */\n    this.min = null;\n    this.max = null;\n    if (!setRange(axis)) {\n      for (var _i = 0, _a = axis.series; _i < _a.length; _i++) {\n        var series = _a[_i];\n        if (!series.visible) {\n          continue;\n        }\n        this.paddingInterval = 0;\n        if (!isNullOrUndefined(series.points)) {\n          axis.maxPointLength = series.points.length;\n        }\n        axis.maxPointLength = series.points.length;\n        if ((series.type.indexOf('Column') > -1 || series.type.indexOf('Histogram') > -1) && axis.orientation === 'Horizontal' || series.type.indexOf('Bar') > -1 && axis.orientation === 'Vertical') {\n          if ((series.xAxis.valueType === 'Double' || series.xAxis.valueType === 'DateTime') && series.xAxis.rangePadding === 'Auto') {\n            this.paddingInterval = getMinPointsDelta(series.xAxis, axis.series) * 0.5;\n          }\n        }\n        //For xRange\n        if (axis.orientation === 'Horizontal') {\n          if (this.chart.requireInvertedAxis) {\n            this.yAxisRange(axis, series);\n          } else {\n            this.findMinMax(series.xMin - this.paddingInterval, series.xMax + this.paddingInterval);\n          }\n        }\n        // For yRange\n        if (axis.orientation === 'Vertical') {\n          this.isColumn += series.type.indexOf('Column') !== -1 || series.type.indexOf('Bar') !== -1 || series.drawType === 'Column' ? 1 : 0;\n          this.isStacking = series.type.indexOf('Stacking') !== -1;\n          if (this.chart.requireInvertedAxis) {\n            this.findMinMax(series.xMin - this.paddingInterval, series.xMax + this.paddingInterval);\n          } else {\n            this.yAxisRange(axis, series);\n          }\n        }\n      }\n    }\n  };\n  Double.prototype.yAxisRange = function (axis, series) {\n    if (series.dragSettings.enable && this.chart.dragY) {\n      if (this.chart.dragY >= axis.visibleRange.max) {\n        series.yMax = this.chart.dragY + axis.visibleRange.interval;\n      }\n      if (this.chart.dragY <= axis.visibleRange.min) {\n        series.yMin = this.chart.dragY - axis.visibleRange.interval;\n      }\n    }\n    if (series.type === 'Waterfall') {\n      var cumulativeMax = 0;\n      var cumulativeValue = 0;\n      for (var i = 0; i < series.yData.length; i++) {\n        if (!(series.intermediateSumIndexes && series.intermediateSumIndexes.indexOf(i) !== -1) && !(series.sumIndexes && series.sumIndexes.indexOf(i) !== -1)) {\n          cumulativeValue += series.yData[i];\n        }\n        if (cumulativeValue > cumulativeMax) {\n          cumulativeMax = cumulativeValue;\n        }\n      }\n      this.findMinMax(series.yMin, cumulativeMax);\n    } else {\n      this.findMinMax(series.yMin, series.yMax);\n    }\n  };\n  Double.prototype.findMinMax = function (min, max) {\n    if (this.min === null || this.min > min) {\n      this.min = min;\n    }\n    if (this.max === null || this.max < max) {\n      this.max = max;\n    }\n    if (this.max === this.min && this.max < 0 && this.min < 0) {\n      // max == min\n      this.max = 0;\n    }\n  };\n  /**\n   * Apply padding for the range.\n   *\n   * @private\n   * @param {Axis} axis - The axis for which padding is applied.\n   * @param {Size} size - The size used for padding calculation.\n   * @returns {void}\n   */\n  Double.prototype.applyRangePadding = function (axis, size) {\n    var start = axis.actualRange.min;\n    var end = axis.actualRange.max;\n    if (!setRange(axis)) {\n      var interval = axis.actualRange.interval;\n      var padding = axis.getRangePadding(this.chart);\n      if (padding === 'Additional' || padding === 'Round') {\n        this.findAdditional(axis, start, end, interval, size);\n      } else if (padding === 'Normal') {\n        this.findNormal(axis, start, end, interval, size);\n      } else {\n        this.updateActualRange(axis, start, end, interval);\n      }\n    }\n    axis.actualRange.delta = axis.actualRange.max - axis.actualRange.min;\n    this.calculateVisibleRange(size, axis);\n  };\n  Double.prototype.updateActualRange = function (axis, minimum, maximum, interval) {\n    axis.actualRange = {\n      min: axis.minimum != null ? axis.minimum : minimum,\n      max: axis.maximum != null ? axis.maximum : maximum,\n      interval: axis.interval != null ? axis.interval : interval,\n      delta: axis.actualRange.delta\n    };\n  };\n  Double.prototype.findAdditional = function (axis, start, end, interval, size) {\n    var minimum;\n    var maximum;\n    minimum = Math.floor(start / interval) * interval;\n    maximum = Math.ceil(end / interval) * interval;\n    if (axis.rangePadding === 'Additional') {\n      minimum -= interval;\n      maximum += interval;\n    }\n    if (!isNullOrUndefined(axis.desiredIntervals)) {\n      var delta = maximum - minimum;\n      interval = this.calculateNumericNiceInterval(axis, delta, size);\n    }\n    this.updateActualRange(axis, minimum, maximum, interval);\n  };\n  Double.prototype.findNormal = function (axis, start, end, interval, size) {\n    var remaining;\n    var minimum;\n    var maximum;\n    var startValue = start;\n    if (start < 0) {\n      startValue = 0;\n      minimum = start + start * 0.05;\n      remaining = interval + minimum % interval;\n      if (0.365 * interval >= remaining) {\n        minimum -= interval;\n      }\n      if (minimum % interval < 0) {\n        minimum = minimum - interval - minimum % interval;\n      }\n    } else {\n      minimum = start < 5.0 / 6.0 * end ? 0 : start - (end - start) * 0.5;\n      if (minimum % interval > 0) {\n        minimum -= minimum % interval;\n      }\n    }\n    maximum = end > 0 ? end + (end - startValue) * 0.05 : end - (end - startValue) * 0.05;\n    remaining = interval - maximum % interval;\n    if (0.365 * interval >= remaining) {\n      maximum += interval;\n    }\n    if (maximum % interval > 0) {\n      maximum = maximum + interval - maximum % interval;\n    }\n    axis.doubleRange = new DoubleRange(minimum, maximum);\n    if (minimum === 0 || minimum < 0 && maximum < 0) {\n      interval = this.calculateNumericNiceInterval(axis, axis.doubleRange.delta, size);\n      maximum = Math.ceil(maximum / interval) * interval;\n    }\n    this.updateActualRange(axis, minimum, maximum, interval);\n  };\n  /**\n   * Calculate visible range for axis.\n   *\n   * @private\n   * @param {Size} size - The size used for calculation.\n   * @param {Axis} axis - The axis for which the visible range is calculated.\n   * @returns {void}\n   */\n  Double.prototype.calculateVisibleRange = function (size, axis) {\n    axis.visibleRange = {\n      max: axis.actualRange.max,\n      min: axis.actualRange.min,\n      delta: axis.actualRange.delta,\n      interval: axis.actualRange.interval\n    };\n    if (this.chart.chartAreaType === 'Cartesian') {\n      var isLazyLoad = isNullOrUndefined(axis.zoomingScrollBar) ? false : axis.zoomingScrollBar.isLazyLoad;\n      if ((axis.zoomFactor < 1 || axis.zoomPosition > 0) && !isLazyLoad) {\n        axis.calculateVisibleRangeOnZooming();\n        axis.visibleRange.interval = axis.enableAutoIntervalOnZooming ? this.calculateNumericNiceInterval(axis, axis.doubleRange.delta, size) : axis.visibleRange.interval;\n      }\n    }\n    var rangeDifference = (axis.visibleRange.max - axis.visibleRange.min) % axis.visibleRange.interval;\n    if (rangeDifference !== 0 && !isNaN(rangeDifference) && axis.valueType === 'Double' && axis.orientation === 'Vertical' && axis.rangePadding === 'Auto') {\n      var duplicateTempInterval = void 0;\n      var tempInterval = axis.visibleRange.min;\n      for (; tempInterval <= axis.visibleRange.max && duplicateTempInterval !== tempInterval; tempInterval += axis.visibleRange.interval) {\n        duplicateTempInterval = tempInterval;\n      }\n      if (duplicateTempInterval < axis.visibleRange.max) {\n        axis.visibleRange.max = duplicateTempInterval + axis.visibleRange.interval;\n      }\n    }\n    axis.triggerRangeRender(this.chart, axis.visibleRange.min, axis.visibleRange.max, axis.visibleRange.interval);\n  };\n  /**\n   * Calculate label for the axis.\n   *\n   * @private\n   */\n  Double.prototype.calculateVisibleLabels = function (axis, chart) {\n    /** Generate axis labels */\n    axis.visibleLabels = [];\n    var tempInterval = axis.visibleRange.min;\n    var labelStyle;\n    var controlName = chart.getModuleName();\n    var isPolarRadar = controlName === 'chart' && chart.chartAreaType === 'PolarRadar';\n    if (!isPolarRadar && (axis.zoomFactor < 1 || axis.zoomPosition > 0 || this.paddingInterval)) {\n      tempInterval = axis.visibleRange.min - axis.visibleRange.min % axis.visibleRange.interval;\n    }\n    var format = this.getFormat(axis);\n    var isCustom = format.match('{value}') !== null;\n    var intervalDigits = 0;\n    var formatDigits = 0;\n    if (axis.labelFormat && axis.labelFormat.indexOf('n') > -1) {\n      formatDigits = parseInt(axis.labelFormat.substring(1, axis.labelFormat.length), 10);\n    }\n    axis.format = chart.intl.getNumberFormat({\n      format: isCustom ? '' : format,\n      useGrouping: chart.useGroupingSeparator\n    });\n    axis.startLabel = axis.format(axis.visibleRange.min);\n    axis.endLabel = axis.format(axis.visibleRange.max);\n    if (axis.visibleRange.interval && (axis.visibleRange.interval + '').indexOf('.') >= 0) {\n      intervalDigits = (axis.visibleRange.interval + '').split('.')[1].length;\n    }\n    var duplicateTempInterval;\n    for (; tempInterval <= axis.visibleRange.max && duplicateTempInterval !== tempInterval; tempInterval += axis.visibleRange.interval) {\n      duplicateTempInterval = tempInterval;\n      labelStyle = extend({}, getValue('properties', axis.labelStyle), null, true);\n      if (withIn(tempInterval, axis.visibleRange)) {\n        triggerLabelRender(chart, tempInterval, this.formatValue(axis, isCustom, format, tempInterval), labelStyle, axis);\n      }\n    }\n    if (tempInterval && (tempInterval + '').indexOf('.') >= 0 && (tempInterval + '').split('.')[1].length > 10) {\n      tempInterval = (tempInterval + '').split('.')[1].length > (formatDigits || intervalDigits) ? +tempInterval.toFixed(formatDigits || intervalDigits) : tempInterval;\n      if (tempInterval <= axis.visibleRange.max) {\n        triggerLabelRender(chart, tempInterval, this.formatValue(axis, isCustom, format, tempInterval), labelStyle, axis);\n      }\n    }\n    if (axis.getMaxLabelWidth) {\n      axis.getMaxLabelWidth(this.chart);\n    }\n  };\n  /**\n   * Format of the axis label.\n   *\n   * @private\n   */\n  Double.prototype.getFormat = function (axis) {\n    if (axis.labelFormat) {\n      if (axis.labelFormat.indexOf('p') === 0 && axis.labelFormat.indexOf('{value}') === -1 && axis.isStack100) {\n        return '{value}%';\n      }\n      return axis.labelFormat;\n    }\n    return axis.isStack100 ? '{value}%' : '';\n  };\n  /**\n   * Formatted the axis label.\n   *\n   * @private\n   */\n  Double.prototype.formatValue = function (axis, isCustom, format, tempInterval) {\n    /*The toLocaleString method is used to adjust the decimal points for this ticket, specifically for ticket numbers I481747 and I541484.*/\n    var labelValue = !(tempInterval % 1) ? tempInterval : Number(tempInterval.toLocaleString('en-US').split(',').join(''));\n    return isCustom ? format.replace('{value}', axis.format(labelValue)) : format ? axis.format(tempInterval) : axis.format(labelValue);\n  };\n  /**\n   * Get module name.\n   *\n   * @returns {string} - Returns the module name.\n   */\n  Double.prototype.getModuleName = function () {\n    /**\n     * Returns the module name\n     */\n    return 'Double';\n  };\n  /**\n   * To destroy the double axis.\n   *\n   * @returns {void}\n   * @private\n   */\n  Double.prototype.destroy = function () {\n    /**\n     * Destroy method performed here.\n     */\n  };\n  return Double;\n}();\nexport { Double };","map":{"version":3,"names":["getMinPointsDelta","getActualDesiredIntervalsCount","setRange","triggerLabelRender","DoubleRange","withIn","logBase","isNullOrUndefined","extend","getValue","Double","chart","isColumn","isStacking","prototype","calculateNumericNiceInterval","axis","delta","size","actualDesiredIntervalsCount","niceInterval","desiredIntervals","isAutoIntervalOnBothAxis","minInterval","Math","pow","floor","_i","_a","intervalDivs","length","interval","currentInterval","zoomFactor","zoomPosition","enableAutoIntervalOnZooming","getActualRange","initializeDoubleRange","startFromZero","actualRange","doubleRange","max","end","start","min","minimum","Number","POSITIVE_INFINITY","maximum","NEGATIVE_INFINITY","valueType","indexOf","calculateRangeAndInterval","calculateRange","applyRangePadding","calculateVisibleLabels","series","visible","paddingInterval","points","maxPointLength","type","orientation","xAxis","rangePadding","requireInvertedAxis","yAxisRange","findMinMax","xMin","xMax","drawType","dragSettings","enable","dragY","visibleRange","yMax","yMin","cumulativeMax","cumulativeValue","i","yData","intermediateSumIndexes","sumIndexes","padding","getRangePadding","findAdditional","findNormal","updateActualRange","calculateVisibleRange","ceil","remaining","startValue","chartAreaType","isLazyLoad","zoomingScrollBar","calculateVisibleRangeOnZooming","rangeDifference","isNaN","duplicateTempInterval","tempInterval","triggerRangeRender","visibleLabels","labelStyle","controlName","getModuleName","isPolarRadar","format","getFormat","isCustom","match","intervalDigits","formatDigits","labelFormat","parseInt","substring","intl","getNumberFormat","useGrouping","useGroupingSeparator","startLabel","endLabel","split","formatValue","toFixed","getMaxLabelWidth","isStack100","labelValue","toLocaleString","join","replace","destroy"],"sources":["C:/Users/mkfun/Desktop/ct assignment/admin/node_modules/@syncfusion/ej2-charts/src/chart/axis/double-axis.js"],"sourcesContent":["import { getMinPointsDelta, getActualDesiredIntervalsCount, setRange, triggerLabelRender } from '../../common/utils/helper';\nimport { DoubleRange } from '../utils/double-range';\nimport { withIn, logBase } from '../../common/utils/helper';\nimport { isNullOrUndefined, extend, getValue } from '@syncfusion/ej2-base';\n/**\n * The `Double` module is used to render the numeric axis in charts.\n */\nvar Double = /** @class */ (function () {\n    /**\n     * Constructor for the dateTime module.\n     *\n     * @private\n     * @param {Chart} chart - Specifies the chart.\n     */\n    function Double(chart) {\n        this.isColumn = 0;\n        this.isStacking = false;\n        this.chart = chart;\n    }\n    /**\n     * Numeric Nice Interval for the axis.\n     *\n     * @private\n     * @param {Axis} axis - The axis.\n     * @param {number} delta - The delta value.\n     * @param {Size} size - The size.\n     * @returns {number} - The calculated nice interval.\n     */\n    Double.prototype.calculateNumericNiceInterval = function (axis, delta, size) {\n        var actualDesiredIntervalsCount = getActualDesiredIntervalsCount(size, axis);\n        var niceInterval = delta / actualDesiredIntervalsCount;\n        if (!isNullOrUndefined(axis.desiredIntervals)) {\n            if (this.isAutoIntervalOnBothAxis(axis)) {\n                return niceInterval;\n            }\n        }\n        var minInterval = Math.pow(10, Math.floor(logBase(niceInterval, 10)));\n        for (var _i = 0, _a = axis.intervalDivs; _i < _a.length; _i++) {\n            var interval = _a[_i];\n            var currentInterval = minInterval * interval;\n            if (actualDesiredIntervalsCount < (delta / currentInterval)) {\n                break;\n            }\n            niceInterval = currentInterval;\n        }\n        return niceInterval;\n    };\n    /**\n     * Determines whether auto interval is enabled on both axes.\n     *\n     * @private\n     * @param {Axis} axis - The axis.\n     * @returns {boolean} - The boolean value indicating if auto interval is enabled on both axes.\n     */\n    Double.prototype.isAutoIntervalOnBothAxis = function (axis) {\n        if (((axis.zoomFactor < 1 || axis.zoomPosition > 0) && axis.enableAutoIntervalOnZooming)) {\n            return false;\n        }\n        else {\n            return true;\n        }\n    };\n    Double.prototype.getActualRange = function (axis, size) {\n        this.initializeDoubleRange(axis);\n        if ((!axis.startFromZero) && (this.isColumn > 0)) {\n            axis.actualRange.interval = axis.interval || this.calculateNumericNiceInterval(axis, axis.doubleRange.delta, size);\n            axis.actualRange.max = axis.doubleRange.end + axis.actualRange.interval;\n            if ((axis.doubleRange.start - axis.actualRange.interval < 0 && axis.doubleRange.start > 0)) {\n                axis.actualRange.min = 0;\n            }\n            else {\n                axis.actualRange.min = axis.doubleRange.start - (this.isStacking ? 0 : axis.actualRange.interval);\n            }\n        }\n        else {\n            axis.actualRange.interval = axis.interval || this.calculateNumericNiceInterval(axis, axis.doubleRange.delta, size);\n            axis.actualRange.min = axis.doubleRange.start;\n            axis.actualRange.max = axis.doubleRange.end;\n        }\n    };\n    /**\n     * Range for the axis.\n     *\n     * @private\n     * @param {Axis} axis - The axis.\n     * @returns {void}\n     */\n    Double.prototype.initializeDoubleRange = function (axis) {\n        //Axis Min\n        if (axis.minimum !== null) {\n            this.min = axis.minimum;\n        }\n        else if (this.min === null || this.min === Number.POSITIVE_INFINITY) {\n            this.min = 0;\n        }\n        // Axis Max\n        if (axis.maximum !== null) {\n            this.max = axis.maximum;\n        }\n        else if (this.max === null || this.max === Number.NEGATIVE_INFINITY) {\n            this.max = 5;\n        }\n        if (this.min === this.max) {\n            this.max = axis.valueType.indexOf('Category') > -1 ? this.max : this.min + 1;\n        }\n        axis.doubleRange = new DoubleRange(this.min, this.max);\n        axis.actualRange = {};\n    };\n    /**\n     * The function to calculate the range and labels for the axis.\n     *\n     * @returns {void}\n     * @private\n     */\n    Double.prototype.calculateRangeAndInterval = function (size, axis) {\n        this.calculateRange(axis);\n        this.getActualRange(axis, size);\n        this.applyRangePadding(axis, size);\n        this.calculateVisibleLabels(axis, this.chart);\n    };\n    /**\n     * Calculate Range for the axis.\n     *\n     * @private\n     */\n    Double.prototype.calculateRange = function (axis) {\n        /** Generate axis range */\n        this.min = null;\n        this.max = null;\n        if (!setRange(axis)) {\n            for (var _i = 0, _a = axis.series; _i < _a.length; _i++) {\n                var series = _a[_i];\n                if (!series.visible) {\n                    continue;\n                }\n                this.paddingInterval = 0;\n                if (!isNullOrUndefined(series.points)) {\n                    axis.maxPointLength = series.points.length;\n                }\n                axis.maxPointLength = series.points.length;\n                if (((series.type.indexOf('Column') > -1 || series.type.indexOf('Histogram') > -1) && axis.orientation === 'Horizontal')\n                    || (series.type.indexOf('Bar') > -1 && axis.orientation === 'Vertical')) {\n                    if ((series.xAxis.valueType === 'Double' || series.xAxis.valueType === 'DateTime')\n                        && series.xAxis.rangePadding === 'Auto') {\n                        this.paddingInterval = getMinPointsDelta(series.xAxis, axis.series) * 0.5;\n                    }\n                }\n                //For xRange\n                if (axis.orientation === 'Horizontal') {\n                    if (this.chart.requireInvertedAxis) {\n                        this.yAxisRange(axis, series);\n                    }\n                    else {\n                        this.findMinMax(series.xMin - this.paddingInterval, series.xMax + this.paddingInterval);\n                    }\n                }\n                // For yRange\n                if (axis.orientation === 'Vertical') {\n                    this.isColumn += (series.type.indexOf('Column') !== -1 || series.type.indexOf('Bar') !== -1 || series.drawType === 'Column') ? 1 : 0;\n                    this.isStacking = series.type.indexOf('Stacking') !== -1;\n                    if (this.chart.requireInvertedAxis) {\n                        this.findMinMax(series.xMin - this.paddingInterval, series.xMax + this.paddingInterval);\n                    }\n                    else {\n                        this.yAxisRange(axis, series);\n                    }\n                }\n            }\n        }\n    };\n    Double.prototype.yAxisRange = function (axis, series) {\n        if (series.dragSettings.enable && this.chart.dragY) {\n            if (this.chart.dragY >= axis.visibleRange.max) {\n                series.yMax = this.chart.dragY + axis.visibleRange.interval;\n            }\n            if (this.chart.dragY <= axis.visibleRange.min) {\n                series.yMin = this.chart.dragY - axis.visibleRange.interval;\n            }\n        }\n        if (series.type === 'Waterfall') {\n            var cumulativeMax = 0;\n            var cumulativeValue = 0;\n            for (var i = 0; i < series.yData.length; i++) {\n                if (!(series.intermediateSumIndexes && series.intermediateSumIndexes.indexOf(i) !== -1) &&\n                    !(series.sumIndexes && series.sumIndexes.indexOf(i) !== -1)) {\n                    cumulativeValue += series.yData[i];\n                }\n                if (cumulativeValue > cumulativeMax) {\n                    cumulativeMax = cumulativeValue;\n                }\n            }\n            this.findMinMax(series.yMin, cumulativeMax);\n        }\n        else {\n            this.findMinMax(series.yMin, series.yMax);\n        }\n    };\n    Double.prototype.findMinMax = function (min, max) {\n        if (this.min === null || this.min > min) {\n            this.min = min;\n        }\n        if (this.max === null || this.max < max) {\n            this.max = max;\n        }\n        if ((this.max === this.min) && this.max < 0 && this.min < 0) { // max == min\n            this.max = 0;\n        }\n    };\n    /**\n     * Apply padding for the range.\n     *\n     * @private\n     * @param {Axis} axis - The axis for which padding is applied.\n     * @param {Size} size - The size used for padding calculation.\n     * @returns {void}\n     */\n    Double.prototype.applyRangePadding = function (axis, size) {\n        var start = axis.actualRange.min;\n        var end = axis.actualRange.max;\n        if (!setRange(axis)) {\n            var interval = axis.actualRange.interval;\n            var padding = axis.getRangePadding(this.chart);\n            if (padding === 'Additional' || padding === 'Round') {\n                this.findAdditional(axis, start, end, interval, size);\n            }\n            else if (padding === 'Normal') {\n                this.findNormal(axis, start, end, interval, size);\n            }\n            else {\n                this.updateActualRange(axis, start, end, interval);\n            }\n        }\n        axis.actualRange.delta = axis.actualRange.max - axis.actualRange.min;\n        this.calculateVisibleRange(size, axis);\n    };\n    Double.prototype.updateActualRange = function (axis, minimum, maximum, interval) {\n        axis.actualRange = {\n            min: axis.minimum != null ? axis.minimum : minimum,\n            max: axis.maximum != null ? axis.maximum : maximum,\n            interval: axis.interval != null ? axis.interval : interval,\n            delta: axis.actualRange.delta\n        };\n    };\n    Double.prototype.findAdditional = function (axis, start, end, interval, size) {\n        var minimum;\n        var maximum;\n        minimum = Math.floor(start / interval) * interval;\n        maximum = Math.ceil(end / interval) * interval;\n        if (axis.rangePadding === 'Additional') {\n            minimum -= interval;\n            maximum += interval;\n        }\n        if (!isNullOrUndefined(axis.desiredIntervals)) {\n            var delta = maximum - minimum;\n            interval = this.calculateNumericNiceInterval(axis, delta, size);\n        }\n        this.updateActualRange(axis, minimum, maximum, interval);\n    };\n    Double.prototype.findNormal = function (axis, start, end, interval, size) {\n        var remaining;\n        var minimum;\n        var maximum;\n        var startValue = start;\n        if (start < 0) {\n            startValue = 0;\n            minimum = start + (start * 0.05);\n            remaining = interval + (minimum % interval);\n            if ((0.365 * interval) >= remaining) {\n                minimum -= interval;\n            }\n            if (minimum % interval < 0) {\n                minimum = (minimum - interval) - (minimum % interval);\n            }\n        }\n        else {\n            minimum = start < ((5.0 / 6.0) * end) ? 0 : (start - (end - start) * 0.5);\n            if (minimum % interval > 0) {\n                minimum -= (minimum % interval);\n            }\n        }\n        maximum = (end > 0) ? (end + (end - startValue) * 0.05) : (end - (end - startValue) * 0.05);\n        remaining = interval - (maximum % interval);\n        if ((0.365 * interval) >= remaining) {\n            maximum += interval;\n        }\n        if (maximum % interval > 0) {\n            maximum = (maximum + interval) - (maximum % interval);\n        }\n        axis.doubleRange = new DoubleRange(minimum, maximum);\n        if (minimum === 0 || (minimum < 0 && maximum < 0)) {\n            interval = this.calculateNumericNiceInterval(axis, axis.doubleRange.delta, size);\n            maximum = Math.ceil(maximum / interval) * interval;\n        }\n        this.updateActualRange(axis, minimum, maximum, interval);\n    };\n    /**\n     * Calculate visible range for axis.\n     *\n     * @private\n     * @param {Size} size - The size used for calculation.\n     * @param {Axis} axis - The axis for which the visible range is calculated.\n     * @returns {void}\n     */\n    Double.prototype.calculateVisibleRange = function (size, axis) {\n        axis.visibleRange = {\n            max: axis.actualRange.max, min: axis.actualRange.min,\n            delta: axis.actualRange.delta, interval: axis.actualRange.interval\n        };\n        if (this.chart.chartAreaType === 'Cartesian') {\n            var isLazyLoad = isNullOrUndefined(axis.zoomingScrollBar) ? false : axis.zoomingScrollBar.isLazyLoad;\n            if ((axis.zoomFactor < 1 || axis.zoomPosition > 0) && !isLazyLoad) {\n                axis.calculateVisibleRangeOnZooming();\n                axis.visibleRange.interval = (axis.enableAutoIntervalOnZooming) ?\n                    this.calculateNumericNiceInterval(axis, axis.doubleRange.delta, size)\n                    : axis.visibleRange.interval;\n            }\n        }\n        var rangeDifference = (axis.visibleRange.max - axis.visibleRange.min) % axis.visibleRange.interval;\n        if (rangeDifference !== 0 && !isNaN(rangeDifference) && axis.valueType === 'Double' &&\n            axis.orientation === 'Vertical' && axis.rangePadding === 'Auto') {\n            var duplicateTempInterval = void 0;\n            var tempInterval = axis.visibleRange.min;\n            for (; (tempInterval <= axis.visibleRange.max) && (duplicateTempInterval !== tempInterval); tempInterval += axis.visibleRange.interval) {\n                duplicateTempInterval = tempInterval;\n            }\n            if (duplicateTempInterval < axis.visibleRange.max) {\n                axis.visibleRange.max = duplicateTempInterval + axis.visibleRange.interval;\n            }\n        }\n        axis.triggerRangeRender(this.chart, axis.visibleRange.min, axis.visibleRange.max, axis.visibleRange.interval);\n    };\n    /**\n     * Calculate label for the axis.\n     *\n     * @private\n     */\n    Double.prototype.calculateVisibleLabels = function (axis, chart) {\n        /** Generate axis labels */\n        axis.visibleLabels = [];\n        var tempInterval = axis.visibleRange.min;\n        var labelStyle;\n        var controlName = chart.getModuleName();\n        var isPolarRadar = controlName === 'chart' && chart.chartAreaType === 'PolarRadar';\n        if (!isPolarRadar && (axis.zoomFactor < 1 || axis.zoomPosition > 0 || this.paddingInterval)) {\n            tempInterval = axis.visibleRange.min - (axis.visibleRange.min % axis.visibleRange.interval);\n        }\n        var format = this.getFormat(axis);\n        var isCustom = format.match('{value}') !== null;\n        var intervalDigits = 0;\n        var formatDigits = 0;\n        if (axis.labelFormat && axis.labelFormat.indexOf('n') > -1) {\n            formatDigits = parseInt(axis.labelFormat.substring(1, axis.labelFormat.length), 10);\n        }\n        axis.format = chart.intl.getNumberFormat({\n            format: isCustom ? '' : format,\n            useGrouping: chart.useGroupingSeparator\n        });\n        axis.startLabel = axis.format(axis.visibleRange.min);\n        axis.endLabel = axis.format(axis.visibleRange.max);\n        if (axis.visibleRange.interval && (axis.visibleRange.interval + '').indexOf('.') >= 0) {\n            intervalDigits = (axis.visibleRange.interval + '').split('.')[1].length;\n        }\n        var duplicateTempInterval;\n        for (; (tempInterval <= axis.visibleRange.max) && (duplicateTempInterval !== tempInterval); tempInterval += axis.visibleRange.interval) {\n            duplicateTempInterval = tempInterval;\n            labelStyle = (extend({}, getValue('properties', axis.labelStyle), null, true));\n            if (withIn(tempInterval, axis.visibleRange)) {\n                triggerLabelRender(chart, tempInterval, this.formatValue(axis, isCustom, format, tempInterval), labelStyle, axis);\n            }\n        }\n        if (tempInterval && (tempInterval + '').indexOf('.') >= 0 && (tempInterval + '').split('.')[1].length > 10) {\n            tempInterval = (tempInterval + '').split('.')[1].length > (formatDigits || intervalDigits) ?\n                +tempInterval.toFixed(formatDigits || intervalDigits) : tempInterval;\n            if (tempInterval <= axis.visibleRange.max) {\n                triggerLabelRender(chart, tempInterval, this.formatValue(axis, isCustom, format, tempInterval), labelStyle, axis);\n            }\n        }\n        if (axis.getMaxLabelWidth) {\n            axis.getMaxLabelWidth(this.chart);\n        }\n    };\n    /**\n     * Format of the axis label.\n     *\n     * @private\n     */\n    Double.prototype.getFormat = function (axis) {\n        if (axis.labelFormat) {\n            if (axis.labelFormat.indexOf('p') === 0 && axis.labelFormat.indexOf('{value}') === -1 && axis.isStack100) {\n                return '{value}%';\n            }\n            return axis.labelFormat;\n        }\n        return axis.isStack100 ? '{value}%' : '';\n    };\n    /**\n     * Formatted the axis label.\n     *\n     * @private\n     */\n    Double.prototype.formatValue = function (axis, isCustom, format, tempInterval) {\n        /*The toLocaleString method is used to adjust the decimal points for this ticket, specifically for ticket numbers I481747 and I541484.*/\n        var labelValue = !(tempInterval % 1) ? tempInterval : Number(tempInterval.toLocaleString('en-US').split(',').join(''));\n        return isCustom ? format.replace('{value}', axis.format(labelValue))\n            : format ? axis.format(tempInterval) : axis.format(labelValue);\n    };\n    /**\n     * Get module name.\n     *\n     * @returns {string} - Returns the module name.\n     */\n    Double.prototype.getModuleName = function () {\n        /**\n         * Returns the module name\n         */\n        return 'Double';\n    };\n    /**\n     * To destroy the double axis.\n     *\n     * @returns {void}\n     * @private\n     */\n    Double.prototype.destroy = function () {\n        /**\n         * Destroy method performed here.\n         */\n    };\n    return Double;\n}());\nexport { Double };\n"],"mappings":"AAAA,SAASA,iBAAiB,EAAEC,8BAA8B,EAAEC,QAAQ,EAAEC,kBAAkB,QAAQ,2BAA2B;AAC3H,SAASC,WAAW,QAAQ,uBAAuB;AACnD,SAASC,MAAM,EAAEC,OAAO,QAAQ,2BAA2B;AAC3D,SAASC,iBAAiB,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,sBAAsB;AAC1E;AACA;AACA;AACA,IAAIC,MAAM,GAAG,aAAe,YAAY;EACpC;AACJ;AACA;AACA;AACA;AACA;EACI,SAASA,MAAMA,CAACC,KAAK,EAAE;IACnB,IAAI,CAACC,QAAQ,GAAG,CAAC;IACjB,IAAI,CAACC,UAAU,GAAG,KAAK;IACvB,IAAI,CAACF,KAAK,GAAGA,KAAK;EACtB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACID,MAAM,CAACI,SAAS,CAACC,4BAA4B,GAAG,UAAUC,IAAI,EAAEC,KAAK,EAAEC,IAAI,EAAE;IACzE,IAAIC,2BAA2B,GAAGlB,8BAA8B,CAACiB,IAAI,EAAEF,IAAI,CAAC;IAC5E,IAAII,YAAY,GAAGH,KAAK,GAAGE,2BAA2B;IACtD,IAAI,CAACZ,iBAAiB,CAACS,IAAI,CAACK,gBAAgB,CAAC,EAAE;MAC3C,IAAI,IAAI,CAACC,wBAAwB,CAACN,IAAI,CAAC,EAAE;QACrC,OAAOI,YAAY;MACvB;IACJ;IACA,IAAIG,WAAW,GAAGC,IAAI,CAACC,GAAG,CAAC,EAAE,EAAED,IAAI,CAACE,KAAK,CAACpB,OAAO,CAACc,YAAY,EAAE,EAAE,CAAC,CAAC,CAAC;IACrE,KAAK,IAAIO,EAAE,GAAG,CAAC,EAAEC,EAAE,GAAGZ,IAAI,CAACa,YAAY,EAAEF,EAAE,GAAGC,EAAE,CAACE,MAAM,EAAEH,EAAE,EAAE,EAAE;MAC3D,IAAII,QAAQ,GAAGH,EAAE,CAACD,EAAE,CAAC;MACrB,IAAIK,eAAe,GAAGT,WAAW,GAAGQ,QAAQ;MAC5C,IAAIZ,2BAA2B,GAAIF,KAAK,GAAGe,eAAgB,EAAE;QACzD;MACJ;MACAZ,YAAY,GAAGY,eAAe;IAClC;IACA,OAAOZ,YAAY;EACvB,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;EACIV,MAAM,CAACI,SAAS,CAACQ,wBAAwB,GAAG,UAAUN,IAAI,EAAE;IACxD,IAAK,CAACA,IAAI,CAACiB,UAAU,GAAG,CAAC,IAAIjB,IAAI,CAACkB,YAAY,GAAG,CAAC,KAAKlB,IAAI,CAACmB,2BAA2B,EAAG;MACtF,OAAO,KAAK;IAChB,CAAC,MACI;MACD,OAAO,IAAI;IACf;EACJ,CAAC;EACDzB,MAAM,CAACI,SAAS,CAACsB,cAAc,GAAG,UAAUpB,IAAI,EAAEE,IAAI,EAAE;IACpD,IAAI,CAACmB,qBAAqB,CAACrB,IAAI,CAAC;IAChC,IAAK,CAACA,IAAI,CAACsB,aAAa,IAAM,IAAI,CAAC1B,QAAQ,GAAG,CAAE,EAAE;MAC9CI,IAAI,CAACuB,WAAW,CAACR,QAAQ,GAAGf,IAAI,CAACe,QAAQ,IAAI,IAAI,CAAChB,4BAA4B,CAACC,IAAI,EAAEA,IAAI,CAACwB,WAAW,CAACvB,KAAK,EAAEC,IAAI,CAAC;MAClHF,IAAI,CAACuB,WAAW,CAACE,GAAG,GAAGzB,IAAI,CAACwB,WAAW,CAACE,GAAG,GAAG1B,IAAI,CAACuB,WAAW,CAACR,QAAQ;MACvE,IAAKf,IAAI,CAACwB,WAAW,CAACG,KAAK,GAAG3B,IAAI,CAACuB,WAAW,CAACR,QAAQ,GAAG,CAAC,IAAIf,IAAI,CAACwB,WAAW,CAACG,KAAK,GAAG,CAAC,EAAG;QACxF3B,IAAI,CAACuB,WAAW,CAACK,GAAG,GAAG,CAAC;MAC5B,CAAC,MACI;QACD5B,IAAI,CAACuB,WAAW,CAACK,GAAG,GAAG5B,IAAI,CAACwB,WAAW,CAACG,KAAK,IAAI,IAAI,CAAC9B,UAAU,GAAG,CAAC,GAAGG,IAAI,CAACuB,WAAW,CAACR,QAAQ,CAAC;MACrG;IACJ,CAAC,MACI;MACDf,IAAI,CAACuB,WAAW,CAACR,QAAQ,GAAGf,IAAI,CAACe,QAAQ,IAAI,IAAI,CAAChB,4BAA4B,CAACC,IAAI,EAAEA,IAAI,CAACwB,WAAW,CAACvB,KAAK,EAAEC,IAAI,CAAC;MAClHF,IAAI,CAACuB,WAAW,CAACK,GAAG,GAAG5B,IAAI,CAACwB,WAAW,CAACG,KAAK;MAC7C3B,IAAI,CAACuB,WAAW,CAACE,GAAG,GAAGzB,IAAI,CAACwB,WAAW,CAACE,GAAG;IAC/C;EACJ,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;EACIhC,MAAM,CAACI,SAAS,CAACuB,qBAAqB,GAAG,UAAUrB,IAAI,EAAE;IACrD;IACA,IAAIA,IAAI,CAAC6B,OAAO,KAAK,IAAI,EAAE;MACvB,IAAI,CAACD,GAAG,GAAG5B,IAAI,CAAC6B,OAAO;IAC3B,CAAC,MACI,IAAI,IAAI,CAACD,GAAG,KAAK,IAAI,IAAI,IAAI,CAACA,GAAG,KAAKE,MAAM,CAACC,iBAAiB,EAAE;MACjE,IAAI,CAACH,GAAG,GAAG,CAAC;IAChB;IACA;IACA,IAAI5B,IAAI,CAACgC,OAAO,KAAK,IAAI,EAAE;MACvB,IAAI,CAACP,GAAG,GAAGzB,IAAI,CAACgC,OAAO;IAC3B,CAAC,MACI,IAAI,IAAI,CAACP,GAAG,KAAK,IAAI,IAAI,IAAI,CAACA,GAAG,KAAKK,MAAM,CAACG,iBAAiB,EAAE;MACjE,IAAI,CAACR,GAAG,GAAG,CAAC;IAChB;IACA,IAAI,IAAI,CAACG,GAAG,KAAK,IAAI,CAACH,GAAG,EAAE;MACvB,IAAI,CAACA,GAAG,GAAGzB,IAAI,CAACkC,SAAS,CAACC,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,CAACV,GAAG,GAAG,IAAI,CAACG,GAAG,GAAG,CAAC;IAChF;IACA5B,IAAI,CAACwB,WAAW,GAAG,IAAIpC,WAAW,CAAC,IAAI,CAACwC,GAAG,EAAE,IAAI,CAACH,GAAG,CAAC;IACtDzB,IAAI,CAACuB,WAAW,GAAG,CAAC,CAAC;EACzB,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACI7B,MAAM,CAACI,SAAS,CAACsC,yBAAyB,GAAG,UAAUlC,IAAI,EAAEF,IAAI,EAAE;IAC/D,IAAI,CAACqC,cAAc,CAACrC,IAAI,CAAC;IACzB,IAAI,CAACoB,cAAc,CAACpB,IAAI,EAAEE,IAAI,CAAC;IAC/B,IAAI,CAACoC,iBAAiB,CAACtC,IAAI,EAAEE,IAAI,CAAC;IAClC,IAAI,CAACqC,sBAAsB,CAACvC,IAAI,EAAE,IAAI,CAACL,KAAK,CAAC;EACjD,CAAC;EACD;AACJ;AACA;AACA;AACA;EACID,MAAM,CAACI,SAAS,CAACuC,cAAc,GAAG,UAAUrC,IAAI,EAAE;IAC9C;IACA,IAAI,CAAC4B,GAAG,GAAG,IAAI;IACf,IAAI,CAACH,GAAG,GAAG,IAAI;IACf,IAAI,CAACvC,QAAQ,CAACc,IAAI,CAAC,EAAE;MACjB,KAAK,IAAIW,EAAE,GAAG,CAAC,EAAEC,EAAE,GAAGZ,IAAI,CAACwC,MAAM,EAAE7B,EAAE,GAAGC,EAAE,CAACE,MAAM,EAAEH,EAAE,EAAE,EAAE;QACrD,IAAI6B,MAAM,GAAG5B,EAAE,CAACD,EAAE,CAAC;QACnB,IAAI,CAAC6B,MAAM,CAACC,OAAO,EAAE;UACjB;QACJ;QACA,IAAI,CAACC,eAAe,GAAG,CAAC;QACxB,IAAI,CAACnD,iBAAiB,CAACiD,MAAM,CAACG,MAAM,CAAC,EAAE;UACnC3C,IAAI,CAAC4C,cAAc,GAAGJ,MAAM,CAACG,MAAM,CAAC7B,MAAM;QAC9C;QACAd,IAAI,CAAC4C,cAAc,GAAGJ,MAAM,CAACG,MAAM,CAAC7B,MAAM;QAC1C,IAAK,CAAC0B,MAAM,CAACK,IAAI,CAACV,OAAO,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,IAAIK,MAAM,CAACK,IAAI,CAACV,OAAO,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,KAAKnC,IAAI,CAAC8C,WAAW,KAAK,YAAY,IAC/GN,MAAM,CAACK,IAAI,CAACV,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,IAAInC,IAAI,CAAC8C,WAAW,KAAK,UAAW,EAAE;UACzE,IAAI,CAACN,MAAM,CAACO,KAAK,CAACb,SAAS,KAAK,QAAQ,IAAIM,MAAM,CAACO,KAAK,CAACb,SAAS,KAAK,UAAU,KAC1EM,MAAM,CAACO,KAAK,CAACC,YAAY,KAAK,MAAM,EAAE;YACzC,IAAI,CAACN,eAAe,GAAG1D,iBAAiB,CAACwD,MAAM,CAACO,KAAK,EAAE/C,IAAI,CAACwC,MAAM,CAAC,GAAG,GAAG;UAC7E;QACJ;QACA;QACA,IAAIxC,IAAI,CAAC8C,WAAW,KAAK,YAAY,EAAE;UACnC,IAAI,IAAI,CAACnD,KAAK,CAACsD,mBAAmB,EAAE;YAChC,IAAI,CAACC,UAAU,CAAClD,IAAI,EAAEwC,MAAM,CAAC;UACjC,CAAC,MACI;YACD,IAAI,CAACW,UAAU,CAACX,MAAM,CAACY,IAAI,GAAG,IAAI,CAACV,eAAe,EAAEF,MAAM,CAACa,IAAI,GAAG,IAAI,CAACX,eAAe,CAAC;UAC3F;QACJ;QACA;QACA,IAAI1C,IAAI,CAAC8C,WAAW,KAAK,UAAU,EAAE;UACjC,IAAI,CAAClD,QAAQ,IAAK4C,MAAM,CAACK,IAAI,CAACV,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,IAAIK,MAAM,CAACK,IAAI,CAACV,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,IAAIK,MAAM,CAACc,QAAQ,KAAK,QAAQ,GAAI,CAAC,GAAG,CAAC;UACpI,IAAI,CAACzD,UAAU,GAAG2C,MAAM,CAACK,IAAI,CAACV,OAAO,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;UACxD,IAAI,IAAI,CAACxC,KAAK,CAACsD,mBAAmB,EAAE;YAChC,IAAI,CAACE,UAAU,CAACX,MAAM,CAACY,IAAI,GAAG,IAAI,CAACV,eAAe,EAAEF,MAAM,CAACa,IAAI,GAAG,IAAI,CAACX,eAAe,CAAC;UAC3F,CAAC,MACI;YACD,IAAI,CAACQ,UAAU,CAAClD,IAAI,EAAEwC,MAAM,CAAC;UACjC;QACJ;MACJ;IACJ;EACJ,CAAC;EACD9C,MAAM,CAACI,SAAS,CAACoD,UAAU,GAAG,UAAUlD,IAAI,EAAEwC,MAAM,EAAE;IAClD,IAAIA,MAAM,CAACe,YAAY,CAACC,MAAM,IAAI,IAAI,CAAC7D,KAAK,CAAC8D,KAAK,EAAE;MAChD,IAAI,IAAI,CAAC9D,KAAK,CAAC8D,KAAK,IAAIzD,IAAI,CAAC0D,YAAY,CAACjC,GAAG,EAAE;QAC3Ce,MAAM,CAACmB,IAAI,GAAG,IAAI,CAAChE,KAAK,CAAC8D,KAAK,GAAGzD,IAAI,CAAC0D,YAAY,CAAC3C,QAAQ;MAC/D;MACA,IAAI,IAAI,CAACpB,KAAK,CAAC8D,KAAK,IAAIzD,IAAI,CAAC0D,YAAY,CAAC9B,GAAG,EAAE;QAC3CY,MAAM,CAACoB,IAAI,GAAG,IAAI,CAACjE,KAAK,CAAC8D,KAAK,GAAGzD,IAAI,CAAC0D,YAAY,CAAC3C,QAAQ;MAC/D;IACJ;IACA,IAAIyB,MAAM,CAACK,IAAI,KAAK,WAAW,EAAE;MAC7B,IAAIgB,aAAa,GAAG,CAAC;MACrB,IAAIC,eAAe,GAAG,CAAC;MACvB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGvB,MAAM,CAACwB,KAAK,CAAClD,MAAM,EAAEiD,CAAC,EAAE,EAAE;QAC1C,IAAI,EAAEvB,MAAM,CAACyB,sBAAsB,IAAIzB,MAAM,CAACyB,sBAAsB,CAAC9B,OAAO,CAAC4B,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,IACnF,EAAEvB,MAAM,CAAC0B,UAAU,IAAI1B,MAAM,CAAC0B,UAAU,CAAC/B,OAAO,CAAC4B,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE;UAC7DD,eAAe,IAAItB,MAAM,CAACwB,KAAK,CAACD,CAAC,CAAC;QACtC;QACA,IAAID,eAAe,GAAGD,aAAa,EAAE;UACjCA,aAAa,GAAGC,eAAe;QACnC;MACJ;MACA,IAAI,CAACX,UAAU,CAACX,MAAM,CAACoB,IAAI,EAAEC,aAAa,CAAC;IAC/C,CAAC,MACI;MACD,IAAI,CAACV,UAAU,CAACX,MAAM,CAACoB,IAAI,EAAEpB,MAAM,CAACmB,IAAI,CAAC;IAC7C;EACJ,CAAC;EACDjE,MAAM,CAACI,SAAS,CAACqD,UAAU,GAAG,UAAUvB,GAAG,EAAEH,GAAG,EAAE;IAC9C,IAAI,IAAI,CAACG,GAAG,KAAK,IAAI,IAAI,IAAI,CAACA,GAAG,GAAGA,GAAG,EAAE;MACrC,IAAI,CAACA,GAAG,GAAGA,GAAG;IAClB;IACA,IAAI,IAAI,CAACH,GAAG,KAAK,IAAI,IAAI,IAAI,CAACA,GAAG,GAAGA,GAAG,EAAE;MACrC,IAAI,CAACA,GAAG,GAAGA,GAAG;IAClB;IACA,IAAK,IAAI,CAACA,GAAG,KAAK,IAAI,CAACG,GAAG,IAAK,IAAI,CAACH,GAAG,GAAG,CAAC,IAAI,IAAI,CAACG,GAAG,GAAG,CAAC,EAAE;MAAE;MAC3D,IAAI,CAACH,GAAG,GAAG,CAAC;IAChB;EACJ,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI/B,MAAM,CAACI,SAAS,CAACwC,iBAAiB,GAAG,UAAUtC,IAAI,EAAEE,IAAI,EAAE;IACvD,IAAIyB,KAAK,GAAG3B,IAAI,CAACuB,WAAW,CAACK,GAAG;IAChC,IAAIF,GAAG,GAAG1B,IAAI,CAACuB,WAAW,CAACE,GAAG;IAC9B,IAAI,CAACvC,QAAQ,CAACc,IAAI,CAAC,EAAE;MACjB,IAAIe,QAAQ,GAAGf,IAAI,CAACuB,WAAW,CAACR,QAAQ;MACxC,IAAIoD,OAAO,GAAGnE,IAAI,CAACoE,eAAe,CAAC,IAAI,CAACzE,KAAK,CAAC;MAC9C,IAAIwE,OAAO,KAAK,YAAY,IAAIA,OAAO,KAAK,OAAO,EAAE;QACjD,IAAI,CAACE,cAAc,CAACrE,IAAI,EAAE2B,KAAK,EAAED,GAAG,EAAEX,QAAQ,EAAEb,IAAI,CAAC;MACzD,CAAC,MACI,IAAIiE,OAAO,KAAK,QAAQ,EAAE;QAC3B,IAAI,CAACG,UAAU,CAACtE,IAAI,EAAE2B,KAAK,EAAED,GAAG,EAAEX,QAAQ,EAAEb,IAAI,CAAC;MACrD,CAAC,MACI;QACD,IAAI,CAACqE,iBAAiB,CAACvE,IAAI,EAAE2B,KAAK,EAAED,GAAG,EAAEX,QAAQ,CAAC;MACtD;IACJ;IACAf,IAAI,CAACuB,WAAW,CAACtB,KAAK,GAAGD,IAAI,CAACuB,WAAW,CAACE,GAAG,GAAGzB,IAAI,CAACuB,WAAW,CAACK,GAAG;IACpE,IAAI,CAAC4C,qBAAqB,CAACtE,IAAI,EAAEF,IAAI,CAAC;EAC1C,CAAC;EACDN,MAAM,CAACI,SAAS,CAACyE,iBAAiB,GAAG,UAAUvE,IAAI,EAAE6B,OAAO,EAAEG,OAAO,EAAEjB,QAAQ,EAAE;IAC7Ef,IAAI,CAACuB,WAAW,GAAG;MACfK,GAAG,EAAE5B,IAAI,CAAC6B,OAAO,IAAI,IAAI,GAAG7B,IAAI,CAAC6B,OAAO,GAAGA,OAAO;MAClDJ,GAAG,EAAEzB,IAAI,CAACgC,OAAO,IAAI,IAAI,GAAGhC,IAAI,CAACgC,OAAO,GAAGA,OAAO;MAClDjB,QAAQ,EAAEf,IAAI,CAACe,QAAQ,IAAI,IAAI,GAAGf,IAAI,CAACe,QAAQ,GAAGA,QAAQ;MAC1Dd,KAAK,EAAED,IAAI,CAACuB,WAAW,CAACtB;IAC5B,CAAC;EACL,CAAC;EACDP,MAAM,CAACI,SAAS,CAACuE,cAAc,GAAG,UAAUrE,IAAI,EAAE2B,KAAK,EAAED,GAAG,EAAEX,QAAQ,EAAEb,IAAI,EAAE;IAC1E,IAAI2B,OAAO;IACX,IAAIG,OAAO;IACXH,OAAO,GAAGrB,IAAI,CAACE,KAAK,CAACiB,KAAK,GAAGZ,QAAQ,CAAC,GAAGA,QAAQ;IACjDiB,OAAO,GAAGxB,IAAI,CAACiE,IAAI,CAAC/C,GAAG,GAAGX,QAAQ,CAAC,GAAGA,QAAQ;IAC9C,IAAIf,IAAI,CAACgD,YAAY,KAAK,YAAY,EAAE;MACpCnB,OAAO,IAAId,QAAQ;MACnBiB,OAAO,IAAIjB,QAAQ;IACvB;IACA,IAAI,CAACxB,iBAAiB,CAACS,IAAI,CAACK,gBAAgB,CAAC,EAAE;MAC3C,IAAIJ,KAAK,GAAG+B,OAAO,GAAGH,OAAO;MAC7Bd,QAAQ,GAAG,IAAI,CAAChB,4BAA4B,CAACC,IAAI,EAAEC,KAAK,EAAEC,IAAI,CAAC;IACnE;IACA,IAAI,CAACqE,iBAAiB,CAACvE,IAAI,EAAE6B,OAAO,EAAEG,OAAO,EAAEjB,QAAQ,CAAC;EAC5D,CAAC;EACDrB,MAAM,CAACI,SAAS,CAACwE,UAAU,GAAG,UAAUtE,IAAI,EAAE2B,KAAK,EAAED,GAAG,EAAEX,QAAQ,EAAEb,IAAI,EAAE;IACtE,IAAIwE,SAAS;IACb,IAAI7C,OAAO;IACX,IAAIG,OAAO;IACX,IAAI2C,UAAU,GAAGhD,KAAK;IACtB,IAAIA,KAAK,GAAG,CAAC,EAAE;MACXgD,UAAU,GAAG,CAAC;MACd9C,OAAO,GAAGF,KAAK,GAAIA,KAAK,GAAG,IAAK;MAChC+C,SAAS,GAAG3D,QAAQ,GAAIc,OAAO,GAAGd,QAAS;MAC3C,IAAK,KAAK,GAAGA,QAAQ,IAAK2D,SAAS,EAAE;QACjC7C,OAAO,IAAId,QAAQ;MACvB;MACA,IAAIc,OAAO,GAAGd,QAAQ,GAAG,CAAC,EAAE;QACxBc,OAAO,GAAIA,OAAO,GAAGd,QAAQ,GAAKc,OAAO,GAAGd,QAAS;MACzD;IACJ,CAAC,MACI;MACDc,OAAO,GAAGF,KAAK,GAAK,GAAG,GAAG,GAAG,GAAID,GAAI,GAAG,CAAC,GAAIC,KAAK,GAAG,CAACD,GAAG,GAAGC,KAAK,IAAI,GAAI;MACzE,IAAIE,OAAO,GAAGd,QAAQ,GAAG,CAAC,EAAE;QACxBc,OAAO,IAAKA,OAAO,GAAGd,QAAS;MACnC;IACJ;IACAiB,OAAO,GAAIN,GAAG,GAAG,CAAC,GAAKA,GAAG,GAAG,CAACA,GAAG,GAAGiD,UAAU,IAAI,IAAI,GAAKjD,GAAG,GAAG,CAACA,GAAG,GAAGiD,UAAU,IAAI,IAAK;IAC3FD,SAAS,GAAG3D,QAAQ,GAAIiB,OAAO,GAAGjB,QAAS;IAC3C,IAAK,KAAK,GAAGA,QAAQ,IAAK2D,SAAS,EAAE;MACjC1C,OAAO,IAAIjB,QAAQ;IACvB;IACA,IAAIiB,OAAO,GAAGjB,QAAQ,GAAG,CAAC,EAAE;MACxBiB,OAAO,GAAIA,OAAO,GAAGjB,QAAQ,GAAKiB,OAAO,GAAGjB,QAAS;IACzD;IACAf,IAAI,CAACwB,WAAW,GAAG,IAAIpC,WAAW,CAACyC,OAAO,EAAEG,OAAO,CAAC;IACpD,IAAIH,OAAO,KAAK,CAAC,IAAKA,OAAO,GAAG,CAAC,IAAIG,OAAO,GAAG,CAAE,EAAE;MAC/CjB,QAAQ,GAAG,IAAI,CAAChB,4BAA4B,CAACC,IAAI,EAAEA,IAAI,CAACwB,WAAW,CAACvB,KAAK,EAAEC,IAAI,CAAC;MAChF8B,OAAO,GAAGxB,IAAI,CAACiE,IAAI,CAACzC,OAAO,GAAGjB,QAAQ,CAAC,GAAGA,QAAQ;IACtD;IACA,IAAI,CAACwD,iBAAiB,CAACvE,IAAI,EAAE6B,OAAO,EAAEG,OAAO,EAAEjB,QAAQ,CAAC;EAC5D,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIrB,MAAM,CAACI,SAAS,CAAC0E,qBAAqB,GAAG,UAAUtE,IAAI,EAAEF,IAAI,EAAE;IAC3DA,IAAI,CAAC0D,YAAY,GAAG;MAChBjC,GAAG,EAAEzB,IAAI,CAACuB,WAAW,CAACE,GAAG;MAAEG,GAAG,EAAE5B,IAAI,CAACuB,WAAW,CAACK,GAAG;MACpD3B,KAAK,EAAED,IAAI,CAACuB,WAAW,CAACtB,KAAK;MAAEc,QAAQ,EAAEf,IAAI,CAACuB,WAAW,CAACR;IAC9D,CAAC;IACD,IAAI,IAAI,CAACpB,KAAK,CAACiF,aAAa,KAAK,WAAW,EAAE;MAC1C,IAAIC,UAAU,GAAGtF,iBAAiB,CAACS,IAAI,CAAC8E,gBAAgB,CAAC,GAAG,KAAK,GAAG9E,IAAI,CAAC8E,gBAAgB,CAACD,UAAU;MACpG,IAAI,CAAC7E,IAAI,CAACiB,UAAU,GAAG,CAAC,IAAIjB,IAAI,CAACkB,YAAY,GAAG,CAAC,KAAK,CAAC2D,UAAU,EAAE;QAC/D7E,IAAI,CAAC+E,8BAA8B,CAAC,CAAC;QACrC/E,IAAI,CAAC0D,YAAY,CAAC3C,QAAQ,GAAIf,IAAI,CAACmB,2BAA2B,GAC1D,IAAI,CAACpB,4BAA4B,CAACC,IAAI,EAAEA,IAAI,CAACwB,WAAW,CAACvB,KAAK,EAAEC,IAAI,CAAC,GACnEF,IAAI,CAAC0D,YAAY,CAAC3C,QAAQ;MACpC;IACJ;IACA,IAAIiE,eAAe,GAAG,CAAChF,IAAI,CAAC0D,YAAY,CAACjC,GAAG,GAAGzB,IAAI,CAAC0D,YAAY,CAAC9B,GAAG,IAAI5B,IAAI,CAAC0D,YAAY,CAAC3C,QAAQ;IAClG,IAAIiE,eAAe,KAAK,CAAC,IAAI,CAACC,KAAK,CAACD,eAAe,CAAC,IAAIhF,IAAI,CAACkC,SAAS,KAAK,QAAQ,IAC/ElC,IAAI,CAAC8C,WAAW,KAAK,UAAU,IAAI9C,IAAI,CAACgD,YAAY,KAAK,MAAM,EAAE;MACjE,IAAIkC,qBAAqB,GAAG,KAAK,CAAC;MAClC,IAAIC,YAAY,GAAGnF,IAAI,CAAC0D,YAAY,CAAC9B,GAAG;MACxC,OAAQuD,YAAY,IAAInF,IAAI,CAAC0D,YAAY,CAACjC,GAAG,IAAMyD,qBAAqB,KAAKC,YAAa,EAAEA,YAAY,IAAInF,IAAI,CAAC0D,YAAY,CAAC3C,QAAQ,EAAE;QACpImE,qBAAqB,GAAGC,YAAY;MACxC;MACA,IAAID,qBAAqB,GAAGlF,IAAI,CAAC0D,YAAY,CAACjC,GAAG,EAAE;QAC/CzB,IAAI,CAAC0D,YAAY,CAACjC,GAAG,GAAGyD,qBAAqB,GAAGlF,IAAI,CAAC0D,YAAY,CAAC3C,QAAQ;MAC9E;IACJ;IACAf,IAAI,CAACoF,kBAAkB,CAAC,IAAI,CAACzF,KAAK,EAAEK,IAAI,CAAC0D,YAAY,CAAC9B,GAAG,EAAE5B,IAAI,CAAC0D,YAAY,CAACjC,GAAG,EAAEzB,IAAI,CAAC0D,YAAY,CAAC3C,QAAQ,CAAC;EACjH,CAAC;EACD;AACJ;AACA;AACA;AACA;EACIrB,MAAM,CAACI,SAAS,CAACyC,sBAAsB,GAAG,UAAUvC,IAAI,EAAEL,KAAK,EAAE;IAC7D;IACAK,IAAI,CAACqF,aAAa,GAAG,EAAE;IACvB,IAAIF,YAAY,GAAGnF,IAAI,CAAC0D,YAAY,CAAC9B,GAAG;IACxC,IAAI0D,UAAU;IACd,IAAIC,WAAW,GAAG5F,KAAK,CAAC6F,aAAa,CAAC,CAAC;IACvC,IAAIC,YAAY,GAAGF,WAAW,KAAK,OAAO,IAAI5F,KAAK,CAACiF,aAAa,KAAK,YAAY;IAClF,IAAI,CAACa,YAAY,KAAKzF,IAAI,CAACiB,UAAU,GAAG,CAAC,IAAIjB,IAAI,CAACkB,YAAY,GAAG,CAAC,IAAI,IAAI,CAACwB,eAAe,CAAC,EAAE;MACzFyC,YAAY,GAAGnF,IAAI,CAAC0D,YAAY,CAAC9B,GAAG,GAAI5B,IAAI,CAAC0D,YAAY,CAAC9B,GAAG,GAAG5B,IAAI,CAAC0D,YAAY,CAAC3C,QAAS;IAC/F;IACA,IAAI2E,MAAM,GAAG,IAAI,CAACC,SAAS,CAAC3F,IAAI,CAAC;IACjC,IAAI4F,QAAQ,GAAGF,MAAM,CAACG,KAAK,CAAC,SAAS,CAAC,KAAK,IAAI;IAC/C,IAAIC,cAAc,GAAG,CAAC;IACtB,IAAIC,YAAY,GAAG,CAAC;IACpB,IAAI/F,IAAI,CAACgG,WAAW,IAAIhG,IAAI,CAACgG,WAAW,CAAC7D,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,EAAE;MACxD4D,YAAY,GAAGE,QAAQ,CAACjG,IAAI,CAACgG,WAAW,CAACE,SAAS,CAAC,CAAC,EAAElG,IAAI,CAACgG,WAAW,CAAClF,MAAM,CAAC,EAAE,EAAE,CAAC;IACvF;IACAd,IAAI,CAAC0F,MAAM,GAAG/F,KAAK,CAACwG,IAAI,CAACC,eAAe,CAAC;MACrCV,MAAM,EAAEE,QAAQ,GAAG,EAAE,GAAGF,MAAM;MAC9BW,WAAW,EAAE1G,KAAK,CAAC2G;IACvB,CAAC,CAAC;IACFtG,IAAI,CAACuG,UAAU,GAAGvG,IAAI,CAAC0F,MAAM,CAAC1F,IAAI,CAAC0D,YAAY,CAAC9B,GAAG,CAAC;IACpD5B,IAAI,CAACwG,QAAQ,GAAGxG,IAAI,CAAC0F,MAAM,CAAC1F,IAAI,CAAC0D,YAAY,CAACjC,GAAG,CAAC;IAClD,IAAIzB,IAAI,CAAC0D,YAAY,CAAC3C,QAAQ,IAAI,CAACf,IAAI,CAAC0D,YAAY,CAAC3C,QAAQ,GAAG,EAAE,EAAEoB,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;MACnF2D,cAAc,GAAG,CAAC9F,IAAI,CAAC0D,YAAY,CAAC3C,QAAQ,GAAG,EAAE,EAAE0F,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC3F,MAAM;IAC3E;IACA,IAAIoE,qBAAqB;IACzB,OAAQC,YAAY,IAAInF,IAAI,CAAC0D,YAAY,CAACjC,GAAG,IAAMyD,qBAAqB,KAAKC,YAAa,EAAEA,YAAY,IAAInF,IAAI,CAAC0D,YAAY,CAAC3C,QAAQ,EAAE;MACpImE,qBAAqB,GAAGC,YAAY;MACpCG,UAAU,GAAI9F,MAAM,CAAC,CAAC,CAAC,EAAEC,QAAQ,CAAC,YAAY,EAAEO,IAAI,CAACsF,UAAU,CAAC,EAAE,IAAI,EAAE,IAAI,CAAE;MAC9E,IAAIjG,MAAM,CAAC8F,YAAY,EAAEnF,IAAI,CAAC0D,YAAY,CAAC,EAAE;QACzCvE,kBAAkB,CAACQ,KAAK,EAAEwF,YAAY,EAAE,IAAI,CAACuB,WAAW,CAAC1G,IAAI,EAAE4F,QAAQ,EAAEF,MAAM,EAAEP,YAAY,CAAC,EAAEG,UAAU,EAAEtF,IAAI,CAAC;MACrH;IACJ;IACA,IAAImF,YAAY,IAAI,CAACA,YAAY,GAAG,EAAE,EAAEhD,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAACgD,YAAY,GAAG,EAAE,EAAEsB,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC3F,MAAM,GAAG,EAAE,EAAE;MACxGqE,YAAY,GAAG,CAACA,YAAY,GAAG,EAAE,EAAEsB,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC3F,MAAM,IAAIiF,YAAY,IAAID,cAAc,CAAC,GACtF,CAACX,YAAY,CAACwB,OAAO,CAACZ,YAAY,IAAID,cAAc,CAAC,GAAGX,YAAY;MACxE,IAAIA,YAAY,IAAInF,IAAI,CAAC0D,YAAY,CAACjC,GAAG,EAAE;QACvCtC,kBAAkB,CAACQ,KAAK,EAAEwF,YAAY,EAAE,IAAI,CAACuB,WAAW,CAAC1G,IAAI,EAAE4F,QAAQ,EAAEF,MAAM,EAAEP,YAAY,CAAC,EAAEG,UAAU,EAAEtF,IAAI,CAAC;MACrH;IACJ;IACA,IAAIA,IAAI,CAAC4G,gBAAgB,EAAE;MACvB5G,IAAI,CAAC4G,gBAAgB,CAAC,IAAI,CAACjH,KAAK,CAAC;IACrC;EACJ,CAAC;EACD;AACJ;AACA;AACA;AACA;EACID,MAAM,CAACI,SAAS,CAAC6F,SAAS,GAAG,UAAU3F,IAAI,EAAE;IACzC,IAAIA,IAAI,CAACgG,WAAW,EAAE;MAClB,IAAIhG,IAAI,CAACgG,WAAW,CAAC7D,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,IAAInC,IAAI,CAACgG,WAAW,CAAC7D,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,IAAInC,IAAI,CAAC6G,UAAU,EAAE;QACtG,OAAO,UAAU;MACrB;MACA,OAAO7G,IAAI,CAACgG,WAAW;IAC3B;IACA,OAAOhG,IAAI,CAAC6G,UAAU,GAAG,UAAU,GAAG,EAAE;EAC5C,CAAC;EACD;AACJ;AACA;AACA;AACA;EACInH,MAAM,CAACI,SAAS,CAAC4G,WAAW,GAAG,UAAU1G,IAAI,EAAE4F,QAAQ,EAAEF,MAAM,EAAEP,YAAY,EAAE;IAC3E;IACA,IAAI2B,UAAU,GAAG,EAAE3B,YAAY,GAAG,CAAC,CAAC,GAAGA,YAAY,GAAGrD,MAAM,CAACqD,YAAY,CAAC4B,cAAc,CAAC,OAAO,CAAC,CAACN,KAAK,CAAC,GAAG,CAAC,CAACO,IAAI,CAAC,EAAE,CAAC,CAAC;IACtH,OAAOpB,QAAQ,GAAGF,MAAM,CAACuB,OAAO,CAAC,SAAS,EAAEjH,IAAI,CAAC0F,MAAM,CAACoB,UAAU,CAAC,CAAC,GAC9DpB,MAAM,GAAG1F,IAAI,CAAC0F,MAAM,CAACP,YAAY,CAAC,GAAGnF,IAAI,CAAC0F,MAAM,CAACoB,UAAU,CAAC;EACtE,CAAC;EACD;AACJ;AACA;AACA;AACA;EACIpH,MAAM,CAACI,SAAS,CAAC0F,aAAa,GAAG,YAAY;IACzC;AACR;AACA;IACQ,OAAO,QAAQ;EACnB,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACI9F,MAAM,CAACI,SAAS,CAACoH,OAAO,GAAG,YAAY;IACnC;AACR;AACA;EAFQ,CAGH;EACD,OAAOxH,MAAM;AACjB,CAAC,CAAC,CAAE;AACJ,SAASA,MAAM","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}