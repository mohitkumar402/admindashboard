{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport { valueToCoefficient, textElement, firstToLowerCase, withIn } from '../../common/utils/helper';\nimport { PathOption, Rect, measureText, TextOption } from '@syncfusion/ej2-svg-base';\nimport { DateTime } from '../../chart/axis/date-time-axis';\nimport { VisibleLabels } from '../../chart/axis/axis';\n/**\n * class for axis\n */\nvar RangeNavigatorAxis = /** @class */function (_super) {\n  __extends(RangeNavigatorAxis, _super);\n  function RangeNavigatorAxis(range) {\n    var _this = _super.call(this) || this;\n    _this.firstLevelLabels = [];\n    _this.secondLevelLabels = [];\n    _this.rangeNavigator = range;\n    return _this;\n  }\n  /**\n   * To render grid lines of axis.\n   *\n   * @returns {void}\n   */\n  RangeNavigatorAxis.prototype.renderGridLines = function () {\n    var pointX = 0;\n    var control = this.rangeNavigator;\n    var majorGridLines = control.majorGridLines;\n    var majorTickLines = control.majorTickLines;\n    var majorGrid = '';\n    var majorTick = '';\n    var rect = control.bounds;\n    var chartAxis = control.chartSeries.xAxis;\n    var disabledColor = control.disableRangeSelector ? 'transparent' : null;\n    this.gridLines = control.renderer.createGroup({\n      id: control.element.id + '_GridLines'\n    });\n    var tick = control.tickPosition === 'Outside' || control.series.length === 0 ? rect.y + rect.height + majorTickLines.height : rect.y + rect.height - majorTickLines.height;\n    //Gridlines\n    this.firstLevelLabels = [];\n    chartAxis.labelStyle = control.labelStyle;\n    chartAxis.skeleton = control.skeleton;\n    chartAxis.skeletonType = control.skeletonType;\n    chartAxis.isChart = false;\n    if (control.valueType.indexOf('DateTime') > -1) {\n      var interval = this.calculateDateTimeNiceInterval(chartAxis, rect, chartAxis.doubleRange.start, chartAxis.doubleRange.end, chartAxis.isChart);\n      if (control.valueType === 'DateTime') {\n        this.findAxisLabels(chartAxis, interval);\n      }\n      this.actualIntervalType = chartAxis.actualIntervalType;\n      if (control.valueType === 'DateTimeCategory' && (this.actualIntervalType === 'Quarter' || this.actualIntervalType === 'Weeks')) {\n        this.findSecondaryAxisLabels(chartAxis);\n      }\n    }\n    this.firstLevelLabels = chartAxis.visibleLabels;\n    this.lowerValues = [];\n    var labelLength = chartAxis.visibleLabels.length;\n    for (var i = 0; i < labelLength; i++) {\n      this.lowerValues.push(this.firstLevelLabels[i].value);\n      pointX = valueToCoefficient(this.firstLevelLabels[i].value, chartAxis) * rect.width + rect.x;\n      if (pointX >= rect.x && rect.x + rect.width >= pointX) {\n        majorGrid = majorGrid.concat('M ' + pointX + ' ' + (control.bounds.y + control.bounds.height) + ' L ' + pointX + ' ' + control.bounds.y + ' ');\n        majorTick = majorTick.concat('M ' + pointX + ' ' + (rect.y + rect.height) + ' L ' + pointX + ' ' + tick + ' ');\n      }\n    }\n    var options = new PathOption(control.element.id + '_MajorGridLine', 'transparent', majorGridLines.width, control.series.length ? disabledColor || majorGridLines.color || control.themeStyle.gridLineColor : 'transparent', 1, majorGridLines.dashArray, majorGrid);\n    this.gridLines.appendChild(control.renderer.drawPath(options));\n    options = new PathOption(control.element.id + '_MajorTickLine', 'transparent', majorTickLines.width, disabledColor || majorTickLines.color || control.themeStyle.gridLineColor, 1, majorGridLines.dashArray, majorTick);\n    this.gridLines.appendChild(control.renderer.drawPath(options));\n  };\n  /**\n   * To render of axis labels.\n   *\n   * @returns {void}\n   */\n  RangeNavigatorAxis.prototype.renderAxisLabels = function () {\n    var axis = this.rangeNavigator.chartSeries.xAxis;\n    var control = this.rangeNavigator;\n    var pointY;\n    var labelElement = control.renderer.createGroup({\n      id: control.element.id + '_AxisLabels'\n    });\n    var firstLevelElement = control.renderer.createGroup({\n      id: control.element.id + '_FirstLevelAxisLabels'\n    });\n    var secondLevelElement = control.renderer.createGroup({\n      id: control.element.id + '_SecondLevelAxisLabels'\n    });\n    var secondaryAxis = axis;\n    pointY = this.findLabelY(control, false);\n    this.placeAxisLabels(axis, pointY, '_AxisLabel_', control, firstLevelElement);\n    secondaryAxis.intervalType = secondaryAxis.actualIntervalType = control.groupBy || this.getSecondaryLabelType(axis.actualIntervalType);\n    secondaryAxis.labelFormat = '';\n    if (control.enableGrouping && control.valueType.indexOf('DateTime') > -1 && this.actualIntervalType !== 'Years') {\n      secondaryAxis.visibleRange.interval = 1;\n      secondaryAxis.visibleLabels = [];\n      var interval = this.calculateDateTimeNiceInterval(secondaryAxis, control.bounds, secondaryAxis.doubleRange.start, secondaryAxis.doubleRange.end, secondaryAxis.isChart);\n      if (control.valueType === 'DateTime') {\n        this.findAxisLabels(secondaryAxis, interval);\n      } else {\n        this.findSecondaryAxisLabels(secondaryAxis);\n      }\n      this.secondLevelLabels = secondaryAxis.visibleLabels;\n      pointY = this.findLabelY(control, true);\n      var border = this.placeAxisLabels(secondaryAxis, pointY, '_SecondaryLabel_', control, secondLevelElement);\n      var path = new PathOption(control.element.id + '_SecondaryMajorLines', 'transparent', control.majorTickLines.width, control.majorTickLines.color || control.themeStyle.gridLineColor, 1, control.majorGridLines.dashArray, border);\n      this.gridLines.appendChild(control.renderer.drawPath(path));\n    }\n    control.chartSeries.xAxis.visibleLabels = control.chartSeries.xAxis.visibleLabels.concat(secondaryAxis.visibleLabels);\n    labelElement.style.cursor = axis.valueType.indexOf('DateTime') > -1 ? 'cursor: pointer' : 'cursor: default';\n    labelElement.appendChild(firstLevelElement);\n    labelElement.appendChild(secondLevelElement);\n    //gridlines and axis label append to element\n    control.svgObject.appendChild(this.gridLines);\n    control.svgObject.appendChild(labelElement);\n  };\n  /**\n   * To find the secondary level label type.\n   *\n   * @param {RangeIntervalType} type - The type of range interval.\n   * @returns {RangeIntervalType} - The secondary level label type.\n   */\n  RangeNavigatorAxis.prototype.getSecondaryLabelType = function (type) {\n    var types = ['Years', 'Quarter', 'Months', 'Weeks', 'Days', 'Hours', 'Minutes', 'Seconds'];\n    return type === 'Years' ? 'Years' : types[types.indexOf(type) - 1];\n  };\n  /**\n   * To find labels for date time category axis.\n   *\n   * @param {Axis} axis - Range axis.\n   * @returns {void}\n   */\n  RangeNavigatorAxis.prototype.findSecondaryAxisLabels = function (axis) {\n    axis.visibleLabels = [];\n    axis.visibleRange.interval = Math.max(axis.visibleRange.interval, 1);\n    var previousIndex;\n    this.rangeNavigator.format = this.rangeNavigator.intl.getDateFormat({\n      format: axis.labelFormat || '',\n      type: firstToLowerCase(axis.skeleton),\n      skeleton: this.getSkeleton(axis, null, null)\n    });\n    for (var i = Math.ceil(axis.visibleRange.min); i <= axis.visibleRange.max; i += axis.visibleRange.interval) {\n      if ((!this.rangeNavigator.dateTimeCategoryModule.sameInterval(axis.labels.map(Number)[i], axis.labels.map(Number)[i - axis.visibleRange.interval], axis.actualIntervalType, i) || axis.isIndexed) && withIn(i, axis.visibleRange) && this.rangeNavigator.dateTimeCategoryModule.isMaximum(i, previousIndex, axis)) {\n        var currentLabel = new Date(axis.labels.map(Number)[i]);\n        if (axis.actualIntervalType === 'Quarter') {\n          var quarterMonths = [0, 3, 6, 9];\n          var quarterIndex = Math.floor(currentLabel.getMonth() / 3);\n          currentLabel.setMonth(quarterMonths[quarterIndex]);\n        }\n        axis.visibleLabels.push(new VisibleLabels(this.dateFormats(this.rangeNavigator.format(currentLabel), axis, axis.visibleLabels.length), i, this.rangeNavigator.labelStyle, this.rangeNavigator.format(currentLabel)));\n        previousIndex = i;\n      }\n    }\n  };\n  /**\n   * To find labels for date time axis.\n   *\n   * @param {Axis} axis - Range axis.\n   * @param {number} interval - Interval for the date time axis.\n   * @returns {void}\n   */\n  RangeNavigatorAxis.prototype.findAxisLabels = function (axis, interval) {\n    axis.visibleLabels = [];\n    var start = new Date(axis.visibleRange.min);\n    var nextInterval;\n    var text;\n    interval = this.rangeNavigator.interval ? this.rangeNavigator.interval : interval;\n    switch (axis.actualIntervalType) {\n      case 'Years':\n        start = new Date(start.getFullYear(), 0, 1);\n        break;\n      case 'Quarter':\n        if (start.getMonth() <= 2) {\n          start = new Date(start.getFullYear(), 0, 1);\n        } else if (start.getMonth() <= 5) {\n          start = new Date(start.getFullYear(), 3, 1);\n        } else if (start.getMonth() <= 8) {\n          start = new Date(start.getFullYear(), 6, 1);\n        } else {\n          start = new Date(start.getFullYear(), 9, 1);\n        }\n        break;\n      case 'Months':\n        start = new Date(start.getFullYear(), start.getMonth());\n        break;\n      case 'Weeks':\n        start = new Date(start.getFullYear(), start.getMonth(), start.getDate() - start.getDay());\n        break;\n      case 'Days':\n        start = new Date(start.getFullYear(), start.getMonth(), start.getDate());\n        break;\n      case 'Hours':\n        start = new Date(start.getFullYear(), start.getMonth(), start.getDate(), start.getHours());\n        break;\n      case 'Minutes':\n        start = new Date(start.getFullYear(), start.getMonth(), start.getDate(), start.getHours(), start.getMinutes());\n        break;\n      case 'Seconds':\n        start = new Date(start.getFullYear(), start.getMonth(), start.getDate(), start.getHours(), start.getMinutes(), start.getSeconds());\n        break;\n    }\n    nextInterval = start.getTime();\n    this.rangeNavigator.format = this.rangeNavigator.intl.getDateFormat({\n      format: axis.labelFormat || '',\n      type: firstToLowerCase(axis.skeletonType),\n      skeleton: this.getSkeleton(axis, null, null)\n    });\n    while (nextInterval <= axis.visibleRange.max) {\n      text = this.dateFormats(this.rangeNavigator.format(new Date(nextInterval)), axis, axis.visibleLabels.length);\n      axis.visibleLabels.push(new VisibleLabels(text, nextInterval, this.rangeNavigator.labelStyle, text));\n      nextInterval = this.increaseDateTimeInterval(axis, nextInterval, interval).getTime();\n    }\n  };\n  /**\n   * To find date time formats for Quarter and week interval type.\n   *\n   * @param {string} text - The text.\n   * @param {Axis} axis - The axis.\n   * @param {number} index - The index.\n   * @returns {string} - The modified text.\n   */\n  RangeNavigatorAxis.prototype.dateFormats = function (text, axis, index) {\n    var changedText = text;\n    var isFirstLevel = this.rangeNavigator.enableGrouping && this.firstLevelLabels.length === 0;\n    switch (axis.actualIntervalType) {\n      case 'Quarter':\n        if (text.indexOf('Jan') > -1) {\n          changedText = !isFirstLevel ? text.replace('Jan', 'Quarter1') : 'Quarter1';\n        } else if (text.indexOf('Apr') > -1) {\n          changedText = !isFirstLevel ? text.replace('Apr', 'Quarter2') : 'Quarter2';\n        } else if (text.indexOf('Jul') > -1) {\n          changedText = !isFirstLevel ? text.replace('Jul', 'Quarter3') : 'Quarter3';\n        } else if (text.indexOf('Oct') > -1) {\n          changedText = !isFirstLevel ? text.replace('Oct', 'Quarter4') : 'Quarter4';\n        }\n        break;\n      case 'Weeks':\n        changedText = 'Week' + ++index;\n        break;\n      default:\n        changedText = text;\n        break;\n    }\n    return changedText;\n  };\n  /**\n   * To find the y co-ordinate for axis labels.\n   *\n   * @param {RangeNavigator} control - The RangeNavigator control.\n   * @param {boolean} isSecondary - If sets to true, indicates that the axis is a secondary axis.\n   * @returns {number} - The y-coordinate for the labels.\n   */\n  RangeNavigatorAxis.prototype.findLabelY = function (control, isSecondary) {\n    var pointY;\n    var reference = control.bounds.y + control.bounds.height;\n    var tickHeight = control.majorTickLines.height;\n    var textHeight = measureText('Quarter1 2011', control.labelStyle, control.themeStyle.axisLabelFont).height;\n    var padding = control.labelPosition === 'Inside' ? 3 : 8;\n    if (control.labelPosition === 'Outside' && control.tickPosition === 'Outside' || control.series.length === 0) {\n      pointY = reference + tickHeight + padding + textHeight * 0.75;\n    } else if (control.labelPosition === 'Inside' && control.tickPosition === 'Inside') {\n      pointY = reference - tickHeight - padding;\n    } else if (control.labelPosition === 'Inside' && control.tickPosition === 'Outside') {\n      pointY = reference - padding;\n    } else {\n      pointY = reference + padding + textHeight * 0.75;\n    }\n    if (isSecondary) {\n      padding = 15;\n      if (control.labelPosition === 'Outside' || control.series.length === 0) {\n        pointY += padding + textHeight * 0.75;\n      } else {\n        pointY = control.tickPosition === 'Outside' || control.series.length === 0 ? reference + tickHeight + padding + textHeight * 0.75 : reference + padding + textHeight * 0.75;\n      }\n    }\n    return pointY;\n  };\n  /**\n   * It places the axis labels and returns border for secondary axis labels.\n   *\n   * @param {Axis} axis - Axis for the lables placed.\n   * @param {number} pointY - The y co-ordinate for axis labels.\n   * @param {string} id - The id for the axis elements.\n   * @param {RangeNavigator} control - The range navigator control.\n   * @param {Element} labelElement - The parent element in which the axis labels are appended.\n   * @returns {string} - The border for the secondary axis labels.\n   */\n  RangeNavigatorAxis.prototype.placeAxisLabels = function (axis, pointY, id, control, labelElement) {\n    var maxLabels = axis.visibleLabels.length;\n    var label;\n    var prevLabel;\n    var pointX;\n    var padding = 2;\n    var rect = control.bounds;\n    var border = '';\n    var pointXGrid;\n    var disabledColor = control.disableRangeSelector ? 'transparent' : null;\n    var prevX = control.enableRtl ? rect.x + rect.width : rect.x;\n    var intervalType = axis.actualIntervalType;\n    var intervalInTime = control.labelPlacement === 'Auto' && control.valueType === 'DateTime' || control.labelPlacement === 'BetweenTicks' ? maxLabels > 1 ? axis.visibleLabels[1].value - axis.visibleLabels[0].value : (axis.visibleRange.max - axis.visibleLabels[0].value) / 2 : 0;\n    if (control.valueType.indexOf('DateTime') > -1 && (intervalType === 'Quarter' || intervalType === 'Weeks')) {\n      this.findSuitableFormat(axis, control);\n    }\n    for (var i = 0, len = maxLabels; i < len; i++) {\n      label = axis.visibleLabels[i];\n      label.size = measureText(label.text, axis.labelStyle, control.themeStyle.axisLabelFont);\n      if ((control.secondaryLabelAlignment === 'Middle' || id.indexOf('_AxisLabel_') > -1) && (control.labelPlacement === 'Auto' || control.labelPlacement === 'BetweenTicks')) {\n        pointX = valueToCoefficient(label.value + intervalInTime / 2, axis) * rect.width + rect.x;\n      } else if (id.indexOf('Secondary') > -1) {\n        pointX = this.findAlignment(axis, i);\n      }\n      if (control.labelPlacement === 'OnTicks' && control.labelPosition === 'Inside') {\n        pointX = valueToCoefficient(label.value, axis) * rect.width + rect.x + label.size.width / 2 + padding;\n      } else if (control.labelPlacement === 'OnTicks' && control.labelPosition === 'Outside') {\n        pointX = valueToCoefficient(label.value, axis) * rect.width + rect.x;\n      }\n      pointXGrid = valueToCoefficient(label.value, axis) * rect.width + rect.x;\n      //edgelabelPlacements\n      if ((i === 0 || i === axis.visibleLabels.length - 1 && control.enableRtl) && pointX < rect.x) {\n        pointX = rect.x + label.size.width / 2;\n      }\n      if ((i === axis.visibleLabels.length - 1 || i === 0 && control.enableRtl) && pointX + label.size.width > rect.x + rect.width) {\n        pointX = rect.x + rect.width - label.size.width / 2;\n      }\n      //secondary axis grid lines\n      if (id.indexOf('_SecondaryLabel_') > -1) {\n        if (pointX >= rect.x && rect.x + rect.width >= pointX) {\n          border = border.concat('M ' + pointXGrid + ' ' + pointY + ' L ' + pointXGrid + ' ' + (pointY - label.size.height));\n        }\n      }\n      //smart axis label position,\n      if (control.labelIntersectAction === 'Hide' && i !== 0 && this.isIntersect(axis, pointX, label.size.width, prevX, prevLabel.size.width)) {\n        continue;\n      }\n      //label alignment for single visible label\n      if (control.secondaryLabelAlignment === 'Middle' && axis.visibleLabels.length === 1) {\n        pointX = valueToCoefficient(label.value, axis) + (rect.x + rect.width / 2);\n      }\n      //labelrender event\n      var labelStyle = control.labelStyle;\n      var style = {\n        size: labelStyle.size,\n        color: disabledColor || labelStyle.color || control.themeStyle.axisLabelFont.color,\n        fontFamily: labelStyle.fontFamily,\n        fontStyle: labelStyle.fontStyle || control.labelStyle.fontStyle,\n        fontWeight: labelStyle.fontWeight || control.labelStyle.fontWeight,\n        opacity: labelStyle.opacity || control.labelStyle.opacity,\n        textAlignment: labelStyle.textAlignment || control.labelStyle.textAlignment,\n        textOverflow: labelStyle.textOverflow || control.labelStyle.textOverflow\n      };\n      var argsData = {\n        cancel: false,\n        name: 'labelRender',\n        text: label.text,\n        value: label.value,\n        labelStyle: style,\n        region: new Rect(pointX, pointY, label.size.width, label.size.height)\n      };\n      control.trigger('labelRender', argsData);\n      if (!argsData.cancel) {\n        control.labels.push(argsData);\n      } else {\n        continue;\n      }\n      textElement(this.rangeNavigator.renderer, new TextOption(this.rangeNavigator.element.id + id + i, pointX, pointY, 'middle', argsData.text), argsData.labelStyle, argsData.labelStyle.color || control.themeStyle.labelFontColor, labelElement, null, null, null, null, null, null, null, null, null, null, control.themeStyle.axisLabelFont).style.cursor = axis.valueType.indexOf('DateTime') > -1 ? 'cursor: pointer' : 'cursor: default';\n      prevX = pointX;\n      prevLabel = label;\n    }\n    return border;\n  };\n  /**\n   * To check label is intersected with successive label or not.\n   *\n   * @param {Axis} axis - The axis for which the labels are placed.\n   * @param {number} currentX - The x-coordinate for the current label.\n   * @param {number} currentWidth - The width of the current label.\n   * @param {number} prevX - The x-coordinate for the previous label.\n   * @param {number} prevWidth - The width of the previous label.\n   * @returns {boolean} - True if the labels intersect; otherwise, false.\n   */\n  RangeNavigatorAxis.prototype.isIntersect = function (axis, currentX, currentWidth, prevX, prevWidth) {\n    return axis.isInversed ? currentX + currentWidth / 2 > prevX - prevWidth / 2 : currentX - currentWidth / 2 < prevX + prevWidth / 2;\n  };\n  /**\n   * To find suitable label format for Quarter and week Interval types.\n   *\n   * @param {Axis} axis - RangeNavigator axis.\n   * @param {RangeNavigator} control - RangeNavigator instance.\n   * @returns {void}\n   */\n  RangeNavigatorAxis.prototype.findSuitableFormat = function (axis, control) {\n    var labels = axis.visibleLabels;\n    var labelLength = labels.length;\n    var bounds = control.bounds;\n    var prevX;\n    var currentX;\n    var interval = control.valueType === 'DateTime' ? labelLength > 1 ? labels[1].value - labels[0].value : axis.visibleRange.interval : 0;\n    for (var i = 0; i < labelLength; i++) {\n      currentX = valueToCoefficient(labels[i].value + interval / 2, axis) * bounds.width + bounds.x;\n      labels[i].size = measureText(labels[i].text, axis.labelStyle, control.themeStyle.axisLabelFont);\n      //edgelabelPlacements\n      if (i === 0 && currentX < bounds.x) {\n        currentX = bounds.x + labels[i].size.width / 2;\n      }\n      if (axis.actualIntervalType === 'Quarter') {\n        if (i !== 0) {\n          if (labels[i].text.indexOf('Quarter') > -1 && this.isIntersect(axis, currentX, labels[i].size.width, prevX, labels[i - 1].size.width)) {\n            labels.every(function (label) {\n              label.text = label.text.toString().replace('Quarter', 'QTR');\n              return true;\n            });\n            axis.visibleLabels = labels;\n            this.findSuitableFormat(axis, control);\n          } else {\n            if (this.isIntersect(axis, currentX, labels[i].size.width, prevX, labels[i - 1].size.width)) {\n              labels.every(function (label) {\n                label.text = label.text.toString().replace('QTR', 'Q');\n                return true;\n              });\n              axis.visibleLabels = labels;\n            }\n          }\n        }\n      } else if (axis.actualIntervalType === 'Weeks') {\n        if (i !== 0 && labels[i].text.indexOf('Week') > -1 && this.isIntersect(axis, currentX, labels[i].size.width, prevX, labels[i - 1].size.width)) {\n          labels.every(function (label) {\n            label.text = label.text.toString().replace('Week', 'W');\n            return true;\n          });\n          axis.visibleLabels = labels;\n        }\n      }\n      prevX = currentX;\n    }\n  };\n  /**\n   * Alignment position for secondary level labels in date time axis.\n   *\n   * @param {Axis} axis - The axis.\n   * @param {number} index - The index of the label.\n   * @returns {number} - The alignment position for the secondary axis labels.\n   */\n  RangeNavigatorAxis.prototype.findAlignment = function (axis, index) {\n    var label = axis.visibleLabels[index];\n    var nextLabel = axis.visibleLabels[index + 1];\n    var bounds = this.rangeNavigator.bounds;\n    return this.rangeNavigator.secondaryLabelAlignment === 'Near' ? valueToCoefficient(label.value, axis) * bounds.width + bounds.x + label.size.width / 2 : valueToCoefficient(nextLabel ? nextLabel.value : axis.visibleRange.max, axis) * bounds.width + bounds.x - label.size.width;\n  };\n  return RangeNavigatorAxis;\n}(DateTime);\nexport { RangeNavigatorAxis };","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","valueToCoefficient","textElement","firstToLowerCase","withIn","PathOption","Rect","measureText","TextOption","DateTime","VisibleLabels","RangeNavigatorAxis","_super","range","_this","call","firstLevelLabels","secondLevelLabels","rangeNavigator","renderGridLines","pointX","control","majorGridLines","majorTickLines","majorGrid","majorTick","rect","bounds","chartAxis","chartSeries","xAxis","disabledColor","disableRangeSelector","gridLines","renderer","createGroup","id","element","tick","tickPosition","series","length","y","height","labelStyle","skeleton","skeletonType","isChart","valueType","indexOf","interval","calculateDateTimeNiceInterval","doubleRange","start","end","findAxisLabels","actualIntervalType","findSecondaryAxisLabels","visibleLabels","lowerValues","labelLength","i","push","value","width","x","concat","options","color","themeStyle","gridLineColor","dashArray","appendChild","drawPath","renderAxisLabels","axis","pointY","labelElement","firstLevelElement","secondLevelElement","secondaryAxis","findLabelY","placeAxisLabels","intervalType","groupBy","getSecondaryLabelType","labelFormat","enableGrouping","visibleRange","border","path","style","cursor","svgObject","type","types","Math","max","previousIndex","format","intl","getDateFormat","getSkeleton","ceil","min","dateTimeCategoryModule","sameInterval","labels","map","Number","isIndexed","isMaximum","currentLabel","Date","quarterMonths","quarterIndex","floor","getMonth","setMonth","dateFormats","nextInterval","text","getFullYear","getDate","getDay","getHours","getMinutes","getSeconds","getTime","increaseDateTimeInterval","index","changedText","isFirstLevel","replace","isSecondary","reference","tickHeight","textHeight","axisLabelFont","padding","labelPosition","maxLabels","label","prevLabel","pointXGrid","prevX","enableRtl","intervalInTime","labelPlacement","findSuitableFormat","len","size","secondaryLabelAlignment","findAlignment","labelIntersectAction","isIntersect","fontFamily","fontStyle","fontWeight","opacity","textAlignment","textOverflow","argsData","cancel","name","region","trigger","labelFontColor","currentX","currentWidth","prevWidth","isInversed","every","toString","nextLabel"],"sources":["C:/Users/mkfun/Desktop/ct assignment/admin/node_modules/@syncfusion/ej2-charts/src/range-navigator/renderer/range-axis.js"],"sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { valueToCoefficient, textElement, firstToLowerCase, withIn } from '../../common/utils/helper';\nimport { PathOption, Rect, measureText, TextOption } from '@syncfusion/ej2-svg-base';\nimport { DateTime } from '../../chart/axis/date-time-axis';\nimport { VisibleLabels } from '../../chart/axis/axis';\n/**\n * class for axis\n */\nvar RangeNavigatorAxis = /** @class */ (function (_super) {\n    __extends(RangeNavigatorAxis, _super);\n    function RangeNavigatorAxis(range) {\n        var _this = _super.call(this) || this;\n        _this.firstLevelLabels = [];\n        _this.secondLevelLabels = [];\n        _this.rangeNavigator = range;\n        return _this;\n    }\n    /**\n     * To render grid lines of axis.\n     *\n     * @returns {void}\n     */\n    RangeNavigatorAxis.prototype.renderGridLines = function () {\n        var pointX = 0;\n        var control = this.rangeNavigator;\n        var majorGridLines = control.majorGridLines;\n        var majorTickLines = control.majorTickLines;\n        var majorGrid = '';\n        var majorTick = '';\n        var rect = control.bounds;\n        var chartAxis = control.chartSeries.xAxis;\n        var disabledColor = (control.disableRangeSelector) ? 'transparent' : null;\n        this.gridLines = control.renderer.createGroup({ id: control.element.id + '_GridLines' });\n        var tick = (control.tickPosition === 'Outside' || control.series.length === 0) ?\n            rect.y + rect.height + majorTickLines.height : rect.y + rect.height - majorTickLines.height;\n        //Gridlines\n        this.firstLevelLabels = [];\n        chartAxis.labelStyle = control.labelStyle;\n        chartAxis.skeleton = control.skeleton;\n        chartAxis.skeletonType = control.skeletonType;\n        chartAxis.isChart = false;\n        if (control.valueType.indexOf('DateTime') > -1) {\n            var interval = this.calculateDateTimeNiceInterval(chartAxis, rect, chartAxis.doubleRange.start, chartAxis.doubleRange.end, chartAxis.isChart);\n            if (control.valueType === 'DateTime') {\n                this.findAxisLabels(chartAxis, interval);\n            }\n            this.actualIntervalType = chartAxis.actualIntervalType;\n            if (control.valueType === 'DateTimeCategory' && (this.actualIntervalType === 'Quarter' || this.actualIntervalType === 'Weeks')) {\n                this.findSecondaryAxisLabels(chartAxis);\n            }\n        }\n        this.firstLevelLabels = chartAxis.visibleLabels;\n        this.lowerValues = [];\n        var labelLength = chartAxis.visibleLabels.length;\n        for (var i = 0; i < labelLength; i++) {\n            this.lowerValues.push(this.firstLevelLabels[i].value);\n            pointX = (valueToCoefficient(this.firstLevelLabels[i].value, chartAxis) * rect.width) + rect.x;\n            if (pointX >= rect.x && (rect.x + rect.width) >= pointX) {\n                majorGrid = majorGrid.concat('M ' + pointX + ' ' + (control.bounds.y + control.bounds.height) +\n                    ' L ' + pointX + ' ' + control.bounds.y + ' ');\n                majorTick = majorTick.concat('M ' + (pointX) + ' ' + (rect.y + rect.height) +\n                    ' L ' + (pointX) + ' ' + tick + ' ');\n            }\n        }\n        var options = new PathOption(control.element.id + '_MajorGridLine', 'transparent', majorGridLines.width, control.series.length ? disabledColor || majorGridLines.color || control.themeStyle.gridLineColor : 'transparent', 1, majorGridLines.dashArray, majorGrid);\n        this.gridLines.appendChild(control.renderer.drawPath(options));\n        options = new PathOption(control.element.id + '_MajorTickLine', 'transparent', majorTickLines.width, disabledColor || majorTickLines.color || control.themeStyle.gridLineColor, 1, majorGridLines.dashArray, majorTick);\n        this.gridLines.appendChild(control.renderer.drawPath(options));\n    };\n    /**\n     * To render of axis labels.\n     *\n     * @returns {void}\n     */\n    RangeNavigatorAxis.prototype.renderAxisLabels = function () {\n        var axis = this.rangeNavigator.chartSeries.xAxis;\n        var control = this.rangeNavigator;\n        var pointY;\n        var labelElement = control.renderer.createGroup({ id: control.element.id + '_AxisLabels' });\n        var firstLevelElement = control.renderer.createGroup({ id: control.element.id + '_FirstLevelAxisLabels' });\n        var secondLevelElement = control.renderer.createGroup({ id: control.element.id + '_SecondLevelAxisLabels' });\n        var secondaryAxis = axis;\n        pointY = this.findLabelY(control, false);\n        this.placeAxisLabels(axis, pointY, '_AxisLabel_', control, firstLevelElement);\n        secondaryAxis.intervalType = secondaryAxis.actualIntervalType = (control.groupBy ||\n            this.getSecondaryLabelType(axis.actualIntervalType));\n        secondaryAxis.labelFormat = '';\n        if (control.enableGrouping && control.valueType.indexOf('DateTime') > -1 && this.actualIntervalType !== 'Years') {\n            secondaryAxis.visibleRange.interval = 1;\n            secondaryAxis.visibleLabels = [];\n            var interval = this.calculateDateTimeNiceInterval(secondaryAxis, control.bounds, secondaryAxis.doubleRange.start, secondaryAxis.doubleRange.end, secondaryAxis.isChart);\n            if (control.valueType === 'DateTime') {\n                this.findAxisLabels(secondaryAxis, interval);\n            }\n            else {\n                this.findSecondaryAxisLabels(secondaryAxis);\n            }\n            this.secondLevelLabels = secondaryAxis.visibleLabels;\n            pointY = this.findLabelY(control, true);\n            var border = this.placeAxisLabels(secondaryAxis, pointY, '_SecondaryLabel_', control, secondLevelElement);\n            var path = new PathOption(control.element.id + '_SecondaryMajorLines', 'transparent', control.majorTickLines.width, control.majorTickLines.color || control.themeStyle.gridLineColor, 1, control.majorGridLines.dashArray, border);\n            this.gridLines.appendChild(control.renderer.drawPath(path));\n        }\n        control.chartSeries.xAxis.visibleLabels = control.chartSeries.xAxis.visibleLabels.concat(secondaryAxis.visibleLabels);\n        labelElement.style.cursor = axis.valueType.indexOf('DateTime') > -1 ? 'cursor: pointer' : 'cursor: default';\n        labelElement.appendChild(firstLevelElement);\n        labelElement.appendChild(secondLevelElement);\n        //gridlines and axis label append to element\n        control.svgObject.appendChild(this.gridLines);\n        control.svgObject.appendChild(labelElement);\n    };\n    /**\n     * To find the secondary level label type.\n     *\n     * @param {RangeIntervalType} type - The type of range interval.\n     * @returns {RangeIntervalType} - The secondary level label type.\n     */\n    RangeNavigatorAxis.prototype.getSecondaryLabelType = function (type) {\n        var types = ['Years', 'Quarter', 'Months', 'Weeks', 'Days', 'Hours', 'Minutes', 'Seconds'];\n        return (type === 'Years' ? 'Years' : types[types.indexOf(type) - 1]);\n    };\n    /**\n     * To find labels for date time category axis.\n     *\n     * @param {Axis} axis - Range axis.\n     * @returns {void}\n     */\n    RangeNavigatorAxis.prototype.findSecondaryAxisLabels = function (axis) {\n        axis.visibleLabels = [];\n        axis.visibleRange.interval = Math.max(axis.visibleRange.interval, 1);\n        var previousIndex;\n        this.rangeNavigator.format = this.rangeNavigator.intl.getDateFormat({\n            format: axis.labelFormat || '',\n            type: firstToLowerCase(axis.skeleton), skeleton: this.getSkeleton(axis, null, null)\n        });\n        for (var i = Math.ceil(axis.visibleRange.min); i <= axis.visibleRange.max; i += axis.visibleRange.interval) {\n            if ((!this.rangeNavigator.dateTimeCategoryModule.sameInterval(axis.labels.map(Number)[i], axis.labels.map(Number)[i - axis.visibleRange.interval], axis.actualIntervalType, i) || axis.isIndexed)\n                && withIn(i, axis.visibleRange)\n                && this.rangeNavigator.dateTimeCategoryModule.isMaximum(i, previousIndex, axis)) {\n                var currentLabel = new Date(axis.labels.map(Number)[i]);\n                if (axis.actualIntervalType === 'Quarter') {\n                    var quarterMonths = [0, 3, 6, 9];\n                    var quarterIndex = Math.floor(currentLabel.getMonth() / 3);\n                    currentLabel.setMonth(quarterMonths[quarterIndex]);\n                }\n                axis.visibleLabels.push(new VisibleLabels(this.dateFormats(this.rangeNavigator.format(currentLabel), axis, axis.visibleLabels.length), i, this.rangeNavigator.labelStyle, this.rangeNavigator.format(currentLabel)));\n                previousIndex = i;\n            }\n        }\n    };\n    /**\n     * To find labels for date time axis.\n     *\n     * @param {Axis} axis - Range axis.\n     * @param {number} interval - Interval for the date time axis.\n     * @returns {void}\n     */\n    RangeNavigatorAxis.prototype.findAxisLabels = function (axis, interval) {\n        axis.visibleLabels = [];\n        var start = new Date(axis.visibleRange.min);\n        var nextInterval;\n        var text;\n        interval = this.rangeNavigator.interval ? this.rangeNavigator.interval : interval;\n        switch (axis.actualIntervalType) {\n            case 'Years':\n                start = new Date(start.getFullYear(), 0, 1);\n                break;\n            case 'Quarter':\n                if (start.getMonth() <= 2) {\n                    start = new Date(start.getFullYear(), 0, 1);\n                }\n                else if (start.getMonth() <= 5) {\n                    start = new Date(start.getFullYear(), 3, 1);\n                }\n                else if (start.getMonth() <= 8) {\n                    start = new Date(start.getFullYear(), 6, 1);\n                }\n                else {\n                    start = new Date(start.getFullYear(), 9, 1);\n                }\n                break;\n            case 'Months':\n                start = new Date(start.getFullYear(), start.getMonth());\n                break;\n            case 'Weeks':\n                start = new Date(start.getFullYear(), start.getMonth(), start.getDate() - start.getDay());\n                break;\n            case 'Days':\n                start = new Date(start.getFullYear(), start.getMonth(), start.getDate());\n                break;\n            case 'Hours':\n                start = new Date(start.getFullYear(), start.getMonth(), start.getDate(), start.getHours());\n                break;\n            case 'Minutes':\n                start = new Date(start.getFullYear(), start.getMonth(), start.getDate(), start.getHours(), start.getMinutes());\n                break;\n            case 'Seconds':\n                start = new Date(start.getFullYear(), start.getMonth(), start.getDate(), start.getHours(), start.getMinutes(), start.getSeconds());\n                break;\n        }\n        nextInterval = start.getTime();\n        this.rangeNavigator.format = this.rangeNavigator.intl.getDateFormat({\n            format: axis.labelFormat || '',\n            type: firstToLowerCase(axis.skeletonType), skeleton: this.getSkeleton(axis, null, null)\n        });\n        while (nextInterval <= axis.visibleRange.max) {\n            text = this.dateFormats(this.rangeNavigator.format(new Date(nextInterval)), axis, axis.visibleLabels.length);\n            axis.visibleLabels.push(new VisibleLabels(text, nextInterval, this.rangeNavigator.labelStyle, text));\n            nextInterval = this.increaseDateTimeInterval(axis, nextInterval, interval).getTime();\n        }\n    };\n    /**\n     * To find date time formats for Quarter and week interval type.\n     *\n     * @param {string} text - The text.\n     * @param {Axis} axis - The axis.\n     * @param {number} index - The index.\n     * @returns {string} - The modified text.\n     */\n    RangeNavigatorAxis.prototype.dateFormats = function (text, axis, index) {\n        var changedText = text;\n        var isFirstLevel = this.rangeNavigator.enableGrouping && this.firstLevelLabels.length === 0;\n        switch (axis.actualIntervalType) {\n            case 'Quarter':\n                if (text.indexOf('Jan') > -1) {\n                    changedText = !isFirstLevel ? text.replace('Jan', 'Quarter1') : 'Quarter1';\n                }\n                else if (text.indexOf('Apr') > -1) {\n                    changedText = !isFirstLevel ? text.replace('Apr', 'Quarter2') : 'Quarter2';\n                }\n                else if (text.indexOf('Jul') > -1) {\n                    changedText = !isFirstLevel ? text.replace('Jul', 'Quarter3') : 'Quarter3';\n                }\n                else if (text.indexOf('Oct') > -1) {\n                    changedText = !isFirstLevel ? text.replace('Oct', 'Quarter4') : 'Quarter4';\n                }\n                break;\n            case 'Weeks':\n                changedText = 'Week' + ++index;\n                break;\n            default:\n                changedText = text;\n                break;\n        }\n        return changedText;\n    };\n    /**\n     * To find the y co-ordinate for axis labels.\n     *\n     * @param {RangeNavigator} control - The RangeNavigator control.\n     * @param {boolean} isSecondary - If sets to true, indicates that the axis is a secondary axis.\n     * @returns {number} - The y-coordinate for the labels.\n     */\n    RangeNavigatorAxis.prototype.findLabelY = function (control, isSecondary) {\n        var pointY;\n        var reference = control.bounds.y + control.bounds.height;\n        var tickHeight = control.majorTickLines.height;\n        var textHeight = measureText('Quarter1 2011', control.labelStyle, control.themeStyle.axisLabelFont).height;\n        var padding = control.labelPosition === 'Inside' ? 3 : 8;\n        if ((control.labelPosition === 'Outside' && control.tickPosition === 'Outside') || control.series.length === 0) {\n            pointY = reference + tickHeight + padding + textHeight * 0.75;\n        }\n        else if (control.labelPosition === 'Inside' && control.tickPosition === 'Inside') {\n            pointY = reference - tickHeight - padding;\n        }\n        else if (control.labelPosition === 'Inside' && control.tickPosition === 'Outside') {\n            pointY = reference - padding;\n        }\n        else {\n            pointY = reference + padding + (textHeight * 0.75);\n        }\n        if (isSecondary) {\n            padding = 15;\n            if (control.labelPosition === 'Outside' || control.series.length === 0) {\n                pointY += padding + textHeight * 0.75;\n            }\n            else {\n                pointY = (control.tickPosition === 'Outside' || control.series.length === 0) ?\n                    reference + tickHeight + padding + textHeight * 0.75 : reference + padding + textHeight * 0.75;\n            }\n        }\n        return pointY;\n    };\n    /**\n     * It places the axis labels and returns border for secondary axis labels.\n     *\n     * @param {Axis} axis - Axis for the lables placed.\n     * @param {number} pointY - The y co-ordinate for axis labels.\n     * @param {string} id - The id for the axis elements.\n     * @param {RangeNavigator} control - The range navigator control.\n     * @param {Element} labelElement - The parent element in which the axis labels are appended.\n     * @returns {string} - The border for the secondary axis labels.\n     */\n    RangeNavigatorAxis.prototype.placeAxisLabels = function (axis, pointY, id, control, labelElement) {\n        var maxLabels = axis.visibleLabels.length;\n        var label;\n        var prevLabel;\n        var pointX;\n        var padding = 2;\n        var rect = control.bounds;\n        var border = '';\n        var pointXGrid;\n        var disabledColor = (control.disableRangeSelector) ? 'transparent' : null;\n        var prevX = control.enableRtl ? (rect.x + rect.width) : rect.x;\n        var intervalType = axis.actualIntervalType;\n        var intervalInTime = ((control.labelPlacement === 'Auto' && control.valueType === 'DateTime') || control.labelPlacement === 'BetweenTicks') ?\n            maxLabels > 1 ? (axis.visibleLabels[1].value - axis.visibleLabels[0].value) :\n                (axis.visibleRange.max - axis.visibleLabels[0].value) / 2 : 0;\n        if (control.valueType.indexOf('DateTime') > -1 && (intervalType === 'Quarter' || intervalType === 'Weeks')) {\n            this.findSuitableFormat(axis, control);\n        }\n        for (var i = 0, len = maxLabels; i < len; i++) {\n            label = axis.visibleLabels[i];\n            label.size = measureText(label.text, axis.labelStyle, control.themeStyle.axisLabelFont);\n            if ((control.secondaryLabelAlignment === 'Middle' || id.indexOf('_AxisLabel_') > -1) && (control.labelPlacement === 'Auto' || control.labelPlacement === 'BetweenTicks')) {\n                pointX = (valueToCoefficient((label.value + intervalInTime / 2), axis) * rect.width) + rect.x;\n            }\n            else if ((id.indexOf('Secondary') > -1)) {\n                pointX = this.findAlignment(axis, i);\n            }\n            if (control.labelPlacement === 'OnTicks' && control.labelPosition === 'Inside') {\n                pointX = (valueToCoefficient(label.value, axis) * rect.width) + rect.x + label.size.width / 2 + padding;\n            }\n            else if (control.labelPlacement === 'OnTicks' && control.labelPosition === 'Outside') {\n                pointX = (valueToCoefficient(label.value, axis) * rect.width) + rect.x;\n            }\n            pointXGrid = (valueToCoefficient((label.value), axis) * rect.width) + rect.x;\n            //edgelabelPlacements\n            if ((i === 0 || (i === axis.visibleLabels.length - 1 && control.enableRtl)) && pointX < rect.x) {\n                pointX = rect.x + label.size.width / 2;\n            }\n            if ((i === axis.visibleLabels.length - 1 || (i === 0 && control.enableRtl)) &&\n                ((pointX + label.size.width) > (rect.x + rect.width))) {\n                pointX = rect.x + rect.width - label.size.width / 2;\n            }\n            //secondary axis grid lines\n            if (id.indexOf('_SecondaryLabel_') > -1) {\n                if (pointX >= rect.x && (rect.x + rect.width) >= pointX) {\n                    border = border.concat('M ' + pointXGrid + ' ' + pointY +\n                        ' L ' + pointXGrid + ' ' + (pointY - label.size.height));\n                }\n            }\n            //smart axis label position,\n            if (control.labelIntersectAction === 'Hide' &&\n                i !== 0 && this.isIntersect(axis, pointX, label.size.width, prevX, prevLabel.size.width)) {\n                continue;\n            }\n            //label alignment for single visible label\n            if (control.secondaryLabelAlignment === 'Middle' && axis.visibleLabels.length === 1) {\n                pointX = valueToCoefficient(label.value, axis) + (rect.x + (rect.width / 2));\n            }\n            //labelrender event\n            var labelStyle = control.labelStyle;\n            var style = {\n                size: labelStyle.size, color: disabledColor || labelStyle.color || control.themeStyle.axisLabelFont.color,\n                fontFamily: labelStyle.fontFamily,\n                fontStyle: labelStyle.fontStyle || control.labelStyle.fontStyle,\n                fontWeight: labelStyle.fontWeight || control.labelStyle.fontWeight,\n                opacity: labelStyle.opacity || control.labelStyle.opacity,\n                textAlignment: labelStyle.textAlignment || control.labelStyle.textAlignment,\n                textOverflow: labelStyle.textOverflow || control.labelStyle.textOverflow\n            };\n            var argsData = {\n                cancel: false, name: 'labelRender',\n                text: label.text, value: label.value, labelStyle: style,\n                region: new Rect(pointX, pointY, label.size.width, label.size.height)\n            };\n            control.trigger('labelRender', argsData);\n            if (!argsData.cancel) {\n                control.labels.push(argsData);\n            }\n            else {\n                continue;\n            }\n            textElement(this.rangeNavigator.renderer, new TextOption(this.rangeNavigator.element.id + id + i, pointX, pointY, 'middle', argsData.text), argsData.labelStyle, argsData.labelStyle.color || control.themeStyle.labelFontColor, labelElement, null, null, null, null, null, null, null, null, null, null, control.themeStyle.axisLabelFont).style.cursor = axis.valueType.indexOf('DateTime') > -1 ? 'cursor: pointer' : 'cursor: default';\n            prevX = pointX;\n            prevLabel = label;\n        }\n        return border;\n    };\n    /**\n     * To check label is intersected with successive label or not.\n     *\n     * @param {Axis} axis - The axis for which the labels are placed.\n     * @param {number} currentX - The x-coordinate for the current label.\n     * @param {number} currentWidth - The width of the current label.\n     * @param {number} prevX - The x-coordinate for the previous label.\n     * @param {number} prevWidth - The width of the previous label.\n     * @returns {boolean} - True if the labels intersect; otherwise, false.\n     */\n    RangeNavigatorAxis.prototype.isIntersect = function (axis, currentX, currentWidth, prevX, prevWidth) {\n        return (axis.isInversed) ? (currentX + currentWidth / 2 > prevX - prevWidth / 2) :\n            (currentX - currentWidth / 2 < prevX + prevWidth / 2);\n    };\n    /**\n     * To find suitable label format for Quarter and week Interval types.\n     *\n     * @param {Axis} axis - RangeNavigator axis.\n     * @param {RangeNavigator} control - RangeNavigator instance.\n     * @returns {void}\n     */\n    RangeNavigatorAxis.prototype.findSuitableFormat = function (axis, control) {\n        var labels = axis.visibleLabels;\n        var labelLength = labels.length;\n        var bounds = control.bounds;\n        var prevX;\n        var currentX;\n        var interval = control.valueType === 'DateTime' ?\n            labelLength > 1 ? (labels[1].value - labels[0].value) : axis.visibleRange.interval\n            : 0;\n        for (var i = 0; i < labelLength; i++) {\n            currentX = (valueToCoefficient((labels[i].value + interval / 2), axis) * bounds.width) + bounds.x;\n            labels[i].size = measureText(labels[i].text, axis.labelStyle, control.themeStyle.axisLabelFont);\n            //edgelabelPlacements\n            if (i === 0 && currentX < bounds.x) {\n                currentX = bounds.x + labels[i].size.width / 2;\n            }\n            if (axis.actualIntervalType === 'Quarter') {\n                if (i !== 0) {\n                    if ((labels[i].text.indexOf('Quarter') > -1) &&\n                        (this.isIntersect(axis, currentX, labels[i].size.width, prevX, labels[i - 1].size.width))) {\n                        labels.every(function (label) {\n                            label.text = label.text.toString().replace('Quarter', 'QTR');\n                            return true;\n                        });\n                        axis.visibleLabels = labels;\n                        this.findSuitableFormat(axis, control);\n                    }\n                    else {\n                        if (this.isIntersect(axis, currentX, labels[i].size.width, prevX, labels[i - 1].size.width)) {\n                            labels.every(function (label) {\n                                label.text = label.text.toString().replace('QTR', 'Q');\n                                return true;\n                            });\n                            axis.visibleLabels = labels;\n                        }\n                    }\n                }\n            }\n            else if (axis.actualIntervalType === 'Weeks') {\n                if ((i !== 0) && ((labels[i].text.indexOf('Week') > -1) &&\n                    (this.isIntersect(axis, currentX, labels[i].size.width, prevX, labels[i - 1].size.width)))) {\n                    labels.every(function (label) {\n                        label.text = label.text.toString().replace('Week', 'W');\n                        return true;\n                    });\n                    axis.visibleLabels = labels;\n                }\n            }\n            prevX = currentX;\n        }\n    };\n    /**\n     * Alignment position for secondary level labels in date time axis.\n     *\n     * @param {Axis} axis - The axis.\n     * @param {number} index - The index of the label.\n     * @returns {number} - The alignment position for the secondary axis labels.\n     */\n    RangeNavigatorAxis.prototype.findAlignment = function (axis, index) {\n        var label = axis.visibleLabels[index];\n        var nextLabel = axis.visibleLabels[index + 1];\n        var bounds = this.rangeNavigator.bounds;\n        return (this.rangeNavigator.secondaryLabelAlignment === 'Near' ?\n            (valueToCoefficient((label.value), axis) * bounds.width) + bounds.x + label.size.width / 2 :\n            (valueToCoefficient((nextLabel ? nextLabel.value : axis.visibleRange.max), axis) * bounds.width) + bounds.x - label.size.width);\n    };\n    return RangeNavigatorAxis;\n}(DateTime));\nexport { RangeNavigatorAxis };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}