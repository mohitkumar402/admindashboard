{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * Accumulation charts base file\n */\nimport { Animation, animationMode, isNullOrUndefined } from '@syncfusion/ej2-base';\nimport { stringToNumber, ChartLocation, degreeToLocation, getAnimationFunction, getElement, markerAnimate } from '../../common/utils/helper';\nimport { Rect } from '@syncfusion/ej2-svg-base';\nimport { animationComplete } from '../../common/model/constants';\nimport { AccumulationBase } from './accumulation-base';\n/**\n * The `PieBase` class is used to perform base calculations for the `Pie` series.\n *\n * @private\n */\nvar PieBase = /** @class */function (_super) {\n  __extends(PieBase, _super);\n  function PieBase() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * To initialize the property values.\n   *\n   * @private\n   * @param {AccumulationChart} chart - The accumulation chart control.\n   * @param {AccumulationSeries} series - The series for which the properties are initialized.\n   * @returns {void}\n   */\n  PieBase.prototype.initProperties = function (chart, series) {\n    this.accumulation = chart;\n    this.size = Math.min(chart.initialClipRect.width, chart.initialClipRect.height);\n    this.initAngles(series);\n    var pieCoefficient = 0.8;\n    var r = parseInt(series.radius, 10);\n    if ((series.radius.indexOf('%') !== -1 || typeof r === 'number') && !isNaN(r)) {\n      this.isRadiusMapped = false;\n      this.pieBaseRadius = stringToNumber(series.radius, series.border.width > 20 ? 0.5 * pieCoefficient * this.size : this.size / 2);\n      this.innerRadius = stringToNumber(series.innerRadius, this.pieBaseRadius);\n      this.pieBaseLabelRadius = series.dataLabel.position === 'Inside' ? (this.pieBaseRadius - this.innerRadius) / 2 + this.innerRadius : this.pieBaseRadius + stringToNumber(series.dataLabel.connectorStyle.length || '4%', this.size / 2);\n    } else {\n      var radiusCollection = [];\n      this.isRadiusMapped = true;\n      for (var i = 0; i < Object.keys(series.points).length; i++) {\n        if (series.points[i].sliceRadius.indexOf('%') !== -1) {\n          radiusCollection[i] = stringToNumber(series.points[i].sliceRadius, this.size / 2);\n        } else {\n          radiusCollection[i] = parseInt(series.points[i].sliceRadius, 10);\n        }\n      }\n      var minRadius = Math.min.apply(null, radiusCollection);\n      var maxRadius = Math.max.apply(null, radiusCollection);\n      this.pieBaseRadius = this.seriesRadius = maxRadius;\n      this.innerRadius = stringToNumber(series.innerRadius, this.seriesRadius);\n      this.innerRadius = this.innerRadius > minRadius ? this.innerRadius / 2 : this.innerRadius;\n    }\n    // this.radius = stringToNumber(series.radius, size / 2);\n    // this.innerRadius = stringToNumber(series.innerRadius, this.radius);\n    // this.labelRadius = series.dataLabel.position === 'Inside' ? (((this.radius - this.innerRadius) / 2) + this.innerRadius) :\n    //     (this.radius + stringToNumber(series.dataLabel.connectorStyle.length || '4%', size / 2));\n    this.radius = this.pieBaseRadius;\n    this.labelRadius = this.pieBaseLabelRadius;\n    chart.explodeDistance = series.explode ? stringToNumber(series.explodeOffset, this.pieBaseRadius) : 0;\n    this.findCenter(chart, series);\n    this.center = this.pieBaseCenter;\n    if (!chart.redraw) {\n      this.defaultLabelBound(series, series.dataLabel.visible, series.dataLabel.position);\n    }\n    this.totalAngle -= 0.001;\n  };\n  /*\n   * To get label radius of the pie.\n   * @private\n   */\n  PieBase.prototype.getLabelRadius = function (series, point) {\n    return series.dataLabel.position === 'Inside' ? (stringToNumber(point.sliceRadius, this.pieBaseRadius) - this.innerRadius) / 2 + this.innerRadius : stringToNumber(point.sliceRadius, this.size / 2) + stringToNumber(series.dataLabel.connectorStyle.length || '4%', this.size / 2);\n  };\n  /**\n   * To find the center of the accumulation.\n   *\n   * @private\n   * @param {AccumulationChart} accumulation - The accumulation chart control.\n   * @param {AccumulationSeries} series - The series for which the center is calculated.\n   * @returns {void}\n   */\n  PieBase.prototype.findCenter = function (accumulation, series) {\n    this.accumulation = accumulation;\n    this.pieBaseCenter = {\n      x: stringToNumber(accumulation.center.x, accumulation.initialClipRect.width) + accumulation.initialClipRect.x,\n      y: stringToNumber(accumulation.center.y, accumulation.initialClipRect.height) + accumulation.initialClipRect.y\n    };\n    var accumulationRect = this.getSeriesBound(series);\n    var accumulationRectCenter = new ChartLocation(accumulationRect.x + accumulationRect.width / 2, accumulationRect.y + accumulationRect.height / 2);\n    this.pieBaseCenter.x += this.pieBaseCenter.x - accumulationRectCenter.x;\n    this.pieBaseCenter.y += this.pieBaseCenter.y - accumulationRectCenter.y;\n    this.accumulation.origin = this.pieBaseCenter;\n  };\n  /**\n   * To find angles from series.\n   *\n   * @param {AccumulationSeries} series - The series for which to calculate angles.\n   * @returns {void}\n   */\n  PieBase.prototype.initAngles = function (series) {\n    var endAngle = isNullOrUndefined(series.endAngle) ? series.startAngle : series.endAngle;\n    this.totalAngle = (endAngle - series.startAngle) % 360;\n    this.startAngle = series.startAngle - 90;\n    this.totalAngle = this.totalAngle <= 0 ? 360 + this.totalAngle : this.totalAngle;\n    this.startAngle = (this.startAngle < 0 ? this.startAngle + 360 : this.startAngle) % 360;\n  };\n  /**\n   * To calculate data-label bound.\n   *\n   * @private\n   * @param {AccumulationSeries} series - The series for which to calculate data-label bounds.\n   * @param {boolean} visible - Indicates whether the data-labels are visible.\n   * @param {AccumulationLabelPosition} position - The position of the data-labels.\n   * @returns {void}\n   */\n  PieBase.prototype.defaultLabelBound = function (series, visible, position) {\n    var accumulationBound = this.getSeriesBound(series);\n    series.accumulationBound = accumulationBound;\n    series.labelBound = new Rect(accumulationBound.x, accumulationBound.y, accumulationBound.width + accumulationBound.x, accumulationBound.height + accumulationBound.y);\n    if (visible && position === 'Outside') {\n      series.labelBound = new Rect(Infinity, Infinity, -Infinity, -Infinity);\n    }\n  };\n  /**\n   * To calculate series bound.\n   *\n   * @private\n   * @param {AccumulationSeries} series - The series for which to calculate the bound.\n   * @returns {Rect} - Returns a rect.\n   */\n  PieBase.prototype.getSeriesBound = function (series) {\n    var rect = new Rect(Infinity, Infinity, -Infinity, -Infinity);\n    this.initAngles(series);\n    var start = this.startAngle;\n    var total = this.totalAngle;\n    var end = (this.startAngle + total) % 360;\n    end = end === 0 ? 360 : end;\n    series.findMaxBounds(rect, this.getRectFromAngle(start));\n    series.findMaxBounds(rect, this.getRectFromAngle(end));\n    series.findMaxBounds(rect, new Rect(this.pieBaseCenter.x, this.pieBaseCenter.y, 0, 0));\n    var nextQuandrant = (Math.floor(start / 90) * 90 + 90) % 360;\n    var lastQuadrant = Math.floor(end / 90) * 90 % 360;\n    lastQuadrant = lastQuadrant === 0 ? 360 : lastQuadrant;\n    if (total >= 90 || lastQuadrant === nextQuandrant) {\n      series.findMaxBounds(rect, this.getRectFromAngle(nextQuandrant));\n      series.findMaxBounds(rect, this.getRectFromAngle(lastQuadrant));\n    }\n    if (start === 0 || start + total >= 360) {\n      series.findMaxBounds(rect, this.getRectFromAngle(0));\n    }\n    var length = nextQuandrant === lastQuadrant ? 0 : Math.floor(total / 90);\n    for (var i = 1; i < length; i++) {\n      nextQuandrant = nextQuandrant + 90;\n      if (nextQuandrant < lastQuadrant || end < start || total === 360) {\n        series.findMaxBounds(rect, this.getRectFromAngle(nextQuandrant));\n      }\n    }\n    rect.width -= rect.x;\n    rect.height -= rect.y;\n    return rect;\n  };\n  /**\n   * To get rect location size from angle.\n   *\n   * @param {number} angle - The angle in degrees.\n   * @returns {Rect} - The rect representing the location size from angle.\n   */\n  PieBase.prototype.getRectFromAngle = function (angle) {\n    var location = degreeToLocation(angle, this.pieBaseRadius, this.pieBaseCenter);\n    return new Rect(location.x, location.y, 0, 0);\n  };\n  /**\n   * To get path arc direction.\n   *\n   * @param {ChartLocation} center - The center coordinates of the arc.\n   * @param {number} start - The starting angle of the arc in degrees.\n   * @param {number} end - The ending angle of the arc in degrees.\n   * @param {number} radius - The radius of the arc.\n   * @param {number} innerRadius - The inner radius of the arc.\n   * @param {number} borderRadius - The border radius of the arc.\n   * @param {boolean} isBorder - It specifies whether it is for rendering a border.\n   * @param {AccPoints[]} seriesPoints - The points of the series.\n   * @returns {string} - The path string representing the arc direction.\n   */\n  PieBase.prototype.getPathArc = function (center, start, end, radius, innerRadius, borderRadius, isBorder, seriesPoints) {\n    var degree = end - start;\n    degree = degree < 0 ? degree + 360 : degree;\n    var flag = degree < 180 ? 0 : 1;\n    if (!innerRadius && innerRadius === 0) {\n      return this.getPiePath(center, degreeToLocation(start, radius, center), degreeToLocation(end, radius, center), radius, flag, borderRadius, seriesPoints);\n    } else {\n      return this.getDoughnutPath(center, degreeToLocation(start, radius, center), degreeToLocation(end, radius, center), radius, degreeToLocation(start, innerRadius, center), degreeToLocation(end, innerRadius, center), innerRadius, flag, borderRadius, isBorder, seriesPoints);\n    }\n  };\n  /**\n   * To get pie direction.\n   *\n   * @param {ChartLocation} center - The center of the pie.\n   * @param {ChartLocation} start - The starting location of the pie.\n   * @param {ChartLocation} end - The ending location of the pie.\n   * @param {number} radius - The radius of the pie.\n   * @param {number} clockWise - The direction of the pie.\n   * @param {number} cornerRadius - The border radius of the arc.\n   * @param {AccPoints[]} seriesPoints - The points of the series.\n   * @returns {string} - The path direction for the pie.\n   */\n  PieBase.prototype.getPiePath = function (center, start, end, radius, clockWise, cornerRadius, seriesPoints) {\n    var sliceCount = this.sliceCheck(seriesPoints);\n    cornerRadius = sliceCount === 1 ? 0 : cornerRadius;\n    var startAngle = Math.atan2(start.y - center.y, start.x - center.x);\n    var endAngle = Math.atan2(end.y - center.y, end.x - center.x);\n    cornerRadius = this.adjustCornerRadius(startAngle, endAngle, radius, cornerRadius);\n    var x1 = start.x - cornerRadius * Math.cos(startAngle);\n    var y1 = start.y - cornerRadius * Math.sin(startAngle);\n    var x2 = end.x - cornerRadius * Math.cos(Math.PI / 2 + endAngle);\n    var y2 = end.y - cornerRadius * Math.sin(Math.PI / 2 + endAngle);\n    var cx2 = end.x - cornerRadius * Math.cos(endAngle);\n    var cy2 = end.y - cornerRadius * Math.sin(endAngle);\n    var cx1 = start.x + cornerRadius * Math.cos(Math.PI / 2 + startAngle);\n    var cy1 = start.y + cornerRadius * Math.sin(Math.PI / 2 + startAngle);\n    return \"M \" + center.x + \" \" + center.y + \" L \" + x1 + \" \" + y1 + \" A \" + cornerRadius + \" \" + cornerRadius + \" 0 0 1 \" + cx1 + \" \" + cy1 + \" A \" + radius + \" \" + radius + \" 0 \" + clockWise + \" 1 \" + x2 + \" \" + y2 + \" A \" + cornerRadius + \" \" + cornerRadius + \" 0 0 1 \" + cx2 + \" \" + cy2 + \" Z\";\n  };\n  /**\n   * To get doughnut direction.\n   *\n   * @param {ChartLocation} center - The center of the doughnut.\n   * @param {ChartLocation} start - The starting location of the outer doughnut.\n   * @param {ChartLocation} end - The ending location of the outer doughnut.\n   * @param {number} radius - The radius of the outer doughnut.\n   * @param {ChartLocation} innerStart - The starting location of the inner doughnut.\n   * @param {ChartLocation} innerEnd - The ending location of the inner doughnut.\n   * @param {number} innerRadius - The radius of the inner doughnut.\n   * @param {number} clockWise - The direction of the doughnut.\n   * @param {number} cornerRadius - The border radius of the arc.\n   * @param {boolean} isBorder - It specifies whether it is for rendering a border.\n   * @param {AccPoints[]} seriesPoints - The points of the series.\n   * @returns {string} - The path direction for the doughnut.\n   */\n  PieBase.prototype.getDoughnutPath = function (center, start, end, radius, innerStart, innerEnd, innerRadius, clockWise, cornerRadius, isBorder, seriesPoints) {\n    var sliceCount = this.sliceCheck(seriesPoints);\n    cornerRadius = sliceCount === 1 ? 0 : cornerRadius;\n    var startAngle = Math.atan2(start.y - innerStart.y, start.x - innerStart.x);\n    var endAngle = Math.atan2(end.y - innerEnd.y, end.x - innerEnd.x);\n    cornerRadius = this.adjustCornerRadius(startAngle, endAngle, innerRadius, cornerRadius);\n    cornerRadius = isBorder && this.innerRadius === 0 ? cornerRadius * -1 : cornerRadius;\n    var x1 = start.x - cornerRadius * Math.cos(startAngle);\n    var y1 = start.y - cornerRadius * Math.sin(startAngle);\n    var x2 = end.x - cornerRadius * Math.cos(Math.PI / 2 + endAngle);\n    var y2 = end.y - cornerRadius * Math.sin(Math.PI / 2 + endAngle);\n    var x3 = innerEnd.x + cornerRadius * Math.cos(endAngle);\n    var y3 = innerEnd.y + cornerRadius * Math.sin(endAngle);\n    var x4 = innerStart.x + cornerRadius * Math.cos(Math.PI / 2 + startAngle);\n    var y4 = innerStart.y + cornerRadius * Math.sin(Math.PI / 2 + startAngle);\n    var cx1 = start.x + cornerRadius * Math.cos(Math.PI / 2 + startAngle);\n    var cy1 = start.y + cornerRadius * Math.sin(Math.PI / 2 + startAngle);\n    var cx2 = end.x - cornerRadius * Math.cos(endAngle);\n    var cy2 = end.y - cornerRadius * Math.sin(endAngle);\n    var cx3 = innerEnd.x - cornerRadius * Math.cos(Math.PI / 2 + endAngle);\n    var cy3 = innerEnd.y - cornerRadius * Math.sin(Math.PI / 2 + endAngle);\n    var cx4 = innerStart.x + cornerRadius * Math.cos(startAngle);\n    var cy4 = innerStart.y + cornerRadius * Math.sin(startAngle);\n    if (isBorder) {\n      return \"M \" + cx1 + \" \" + cy1 + \" A \" + radius + \" \" + radius + \" 0 \" + clockWise + \" 1 \" + x2 + \" \" + y2 + \" L \" + cx3 + \" \" + cy3 + \" A \" + innerRadius + \" \" + innerRadius + \" 0 \" + clockWise + \" 0 \" + x4 + \" \" + y4 + \" Z\";\n    } else {\n      return \"M \" + x1 + \" \" + y1 + \" A \" + cornerRadius + \" \" + cornerRadius + \" 0 0 1 \" + cx1 + \" \" + cy1 + \" A \" + radius + \" \" + radius + \" 0 \" + clockWise + \" 1 \" + x2 + \" \" + y2 + \" A \" + cornerRadius + \" \" + cornerRadius + \" 0 0 1 \" + cx2 + \" \" + cy2 + \" L \" + x3 + \" \" + y3 + \" A \" + cornerRadius + \" \" + cornerRadius + \" 0 0 1 \" + cx3 + \" \" + cy3 + \" A \" + innerRadius + \" \" + innerRadius + \" 0 \" + clockWise + \" 0 \" + x4 + \" \" + y4 + \" A \" + cornerRadius + \" \" + cornerRadius + \" 0 0 1 \" + cx4 + \" \" + cy4 + \" Z\";\n    }\n  };\n  /**\n   * Adjusts the corner radius of a pie chart slice based on the angle of the slice.\n   * Ensures that the corner radius does not exceed a value that would cause the arcs\n   * of the slice to overlap or create an invalid shape.\n   *\n   * @param {number} startAngle - The start angle of the pie.\n   * @param {number} endAngle - The end angle of the pie.\n   * @param {number} radius - The radius of the pie.\n   * @param {number} cornerRadius - The border radius of the arc.\n   * @returns {number} - The adjusted corner radius of the pie.\n   */\n  PieBase.prototype.adjustCornerRadius = function (startAngle, endAngle, radius, cornerRadius) {\n    var anglePerSlice = Math.abs(endAngle - startAngle);\n    if (anglePerSlice > Math.PI) {\n      anglePerSlice = 2 * Math.PI - anglePerSlice; // Handle large angles that cross the -PI to PI boundary\n    }\n    // Adjust corner radius based on the angle per slice\n    var angleFactor = anglePerSlice / (2 * Math.PI);\n    var adjustedCornerRadius = radius * angleFactor;\n    return Math.min(cornerRadius, adjustedCornerRadius);\n  };\n  /**\n   * To Check slice count.\n   *\n   * @param {AccPoints[]} seriesPoints - The points of the series.\n   * @returns {number} - The number of visible pie slice.\n   */\n  PieBase.prototype.sliceCheck = function (seriesPoints) {\n    var isOneSlice = 0;\n    for (var index = 0; index < seriesPoints.length; index++) {\n      var point = seriesPoints[index];\n      if (point.visible) {\n        isOneSlice++;\n      }\n    }\n    return isOneSlice;\n  };\n  /**\n   * Method to start animation for pie series.\n   *\n   * @param {Element} slice - The slice element to animate.\n   * @param {AccumulationSeries} series - The accumulation chart control.\n   * @param {Element} groupElement - The group element containing the pie series.\n   * @param {number} borderRadius - The border radius of the arc.\n   * @param {AccPoints[]} seriesPoints - The points of the series.\n   * @returns {void}\n   */\n  PieBase.prototype.doAnimation = function (slice, series, groupElement, borderRadius, seriesPoints) {\n    var _this = this;\n    var startAngle = series.startAngle - 90;\n    var duration = this.accumulation.duration ? this.accumulation.duration : series.animation.duration;\n    var value;\n    this.pieBaseCenter.x += 1;\n    var radius = Math.max(this.accumulation.availableSize.height, this.accumulation.availableSize.width) * 0.75;\n    radius += radius * 0.414; // formula r + r / 2 * (1.414 -1)\n    var effect = getAnimationFunction('Linear'); // need to check animation type\n    new Animation({}).animate(slice, {\n      duration: duration === 0 && animationMode === 'Enable' ? 1000 : duration,\n      delay: series.animation.delay,\n      progress: function (args) {\n        value = effect(args.timeStamp, startAngle, _this.totalAngle, args.duration);\n        slice.setAttribute('d', _this.getPathArc(_this.pieBaseCenter, startAngle, value, radius, 0, borderRadius, false, seriesPoints));\n      },\n      end: function () {\n        _this.pieBaseCenter.x -= 1;\n        slice.setAttribute('d', _this.getPathArc(_this.pieBaseCenter, 0, 359.99999, radius, 0, borderRadius, false, seriesPoints));\n        _this.accumulation.trigger(animationComplete, _this.accumulation.isBlazor ? {} : {\n          series: series,\n          accumulation: _this.accumulation,\n          chart: _this.accumulation\n        });\n        var datalabelGroup = getElement(_this.accumulation.element.id + '_datalabel_Series_' + series.index);\n        if (datalabelGroup) {\n          markerAnimate(datalabelGroup, series.animation.delay, series.animation.duration, series, null, null, false);\n        }\n        groupElement.style.cssText = '';\n        var annotationElement = getElement(_this.accumulation.element.id + '_Annotation_Collections');\n        if (annotationElement) {\n          annotationElement.style.visibility = 'visible';\n        }\n      }\n    });\n  };\n  return PieBase;\n}(AccumulationBase);\nexport { PieBase };","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","Animation","animationMode","isNullOrUndefined","stringToNumber","ChartLocation","degreeToLocation","getAnimationFunction","getElement","markerAnimate","Rect","animationComplete","AccumulationBase","PieBase","_super","apply","arguments","initProperties","chart","series","accumulation","size","Math","min","initialClipRect","width","height","initAngles","pieCoefficient","r","parseInt","radius","indexOf","isNaN","isRadiusMapped","pieBaseRadius","border","innerRadius","pieBaseLabelRadius","dataLabel","position","connectorStyle","length","radiusCollection","i","keys","points","sliceRadius","minRadius","maxRadius","max","seriesRadius","labelRadius","explodeDistance","explode","explodeOffset","findCenter","center","pieBaseCenter","redraw","defaultLabelBound","visible","totalAngle","getLabelRadius","point","x","y","accumulationRect","getSeriesBound","accumulationRectCenter","origin","endAngle","startAngle","accumulationBound","labelBound","Infinity","rect","start","total","end","findMaxBounds","getRectFromAngle","nextQuandrant","floor","lastQuadrant","angle","location","getPathArc","borderRadius","isBorder","seriesPoints","degree","flag","getPiePath","getDoughnutPath","clockWise","cornerRadius","sliceCount","sliceCheck","atan2","adjustCornerRadius","x1","cos","y1","sin","x2","PI","y2","cx2","cy2","cx1","cy1","innerStart","innerEnd","x3","y3","x4","y4","cx3","cy3","cx4","cy4","anglePerSlice","abs","angleFactor","adjustedCornerRadius","isOneSlice","index","doAnimation","slice","groupElement","_this","duration","animation","value","availableSize","effect","animate","delay","progress","args","timeStamp","setAttribute","trigger","isBlazor","datalabelGroup","element","id","style","cssText","annotationElement","visibility"],"sources":["C:/Users/mkfun/Desktop/ct assignment/admin/node_modules/@syncfusion/ej2-charts/src/accumulation-chart/renderer/pie-base.js"],"sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * Accumulation charts base file\n */\nimport { Animation, animationMode, isNullOrUndefined } from '@syncfusion/ej2-base';\nimport { stringToNumber, ChartLocation, degreeToLocation, getAnimationFunction, getElement, markerAnimate } from '../../common/utils/helper';\nimport { Rect } from '@syncfusion/ej2-svg-base';\nimport { animationComplete } from '../../common/model/constants';\nimport { AccumulationBase } from './accumulation-base';\n/**\n * The `PieBase` class is used to perform base calculations for the `Pie` series.\n *\n * @private\n */\nvar PieBase = /** @class */ (function (_super) {\n    __extends(PieBase, _super);\n    function PieBase() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * To initialize the property values.\n     *\n     * @private\n     * @param {AccumulationChart} chart - The accumulation chart control.\n     * @param {AccumulationSeries} series - The series for which the properties are initialized.\n     * @returns {void}\n     */\n    PieBase.prototype.initProperties = function (chart, series) {\n        this.accumulation = chart;\n        this.size = Math.min(chart.initialClipRect.width, chart.initialClipRect.height);\n        this.initAngles(series);\n        var pieCoefficient = 0.8;\n        var r = parseInt(series.radius, 10);\n        if ((series.radius.indexOf('%') !== -1 || typeof r === 'number') && !isNaN(r)) {\n            this.isRadiusMapped = false;\n            this.pieBaseRadius = stringToNumber(series.radius, series.border.width > 20\n                ? (0.5 * pieCoefficient * this.size) : this.size / 2);\n            this.innerRadius = stringToNumber(series.innerRadius, this.pieBaseRadius);\n            this.pieBaseLabelRadius = series.dataLabel.position === 'Inside' ? (((this.pieBaseRadius - this.innerRadius) / 2) + this.innerRadius) :\n                (this.pieBaseRadius + stringToNumber(series.dataLabel.connectorStyle.length || '4%', this.size / 2));\n        }\n        else {\n            var radiusCollection = [];\n            this.isRadiusMapped = true;\n            for (var i = 0; i < Object.keys(series.points).length; i++) {\n                if (series.points[i].sliceRadius.indexOf('%') !== -1) {\n                    radiusCollection[i] = stringToNumber(series.points[i].sliceRadius, this.size / 2);\n                }\n                else {\n                    radiusCollection[i] = parseInt(series.points[i].sliceRadius, 10);\n                }\n            }\n            var minRadius = Math.min.apply(null, radiusCollection);\n            var maxRadius = Math.max.apply(null, radiusCollection);\n            this.pieBaseRadius = this.seriesRadius = maxRadius;\n            this.innerRadius = stringToNumber(series.innerRadius, this.seriesRadius);\n            this.innerRadius = this.innerRadius > minRadius ? (this.innerRadius / 2) : this.innerRadius;\n        }\n        // this.radius = stringToNumber(series.radius, size / 2);\n        // this.innerRadius = stringToNumber(series.innerRadius, this.radius);\n        // this.labelRadius = series.dataLabel.position === 'Inside' ? (((this.radius - this.innerRadius) / 2) + this.innerRadius) :\n        //     (this.radius + stringToNumber(series.dataLabel.connectorStyle.length || '4%', size / 2));\n        this.radius = this.pieBaseRadius;\n        this.labelRadius = this.pieBaseLabelRadius;\n        chart.explodeDistance = series.explode ? stringToNumber(series.explodeOffset, this.pieBaseRadius) : 0;\n        this.findCenter(chart, series);\n        this.center = this.pieBaseCenter;\n        if (!chart.redraw) {\n            this.defaultLabelBound(series, series.dataLabel.visible, series.dataLabel.position);\n        }\n        this.totalAngle -= 0.001;\n    };\n    /*\n     * To get label radius of the pie.\n     * @private\n     */\n    PieBase.prototype.getLabelRadius = function (series, point) {\n        return series.dataLabel.position === 'Inside' ?\n            ((((stringToNumber(point.sliceRadius, this.pieBaseRadius) - this.innerRadius)) / 2) + this.innerRadius) :\n            (stringToNumber(point.sliceRadius, this.size / 2) + stringToNumber(series.dataLabel.connectorStyle.length || '4%', this.size / 2));\n    };\n    /**\n     * To find the center of the accumulation.\n     *\n     * @private\n     * @param {AccumulationChart} accumulation - The accumulation chart control.\n     * @param {AccumulationSeries} series - The series for which the center is calculated.\n     * @returns {void}\n     */\n    PieBase.prototype.findCenter = function (accumulation, series) {\n        this.accumulation = accumulation;\n        this.pieBaseCenter = {\n            x: stringToNumber(accumulation.center.x, accumulation.initialClipRect.width) + (accumulation.initialClipRect.x),\n            y: stringToNumber(accumulation.center.y, accumulation.initialClipRect.height) + (accumulation.initialClipRect.y)\n        };\n        var accumulationRect = this.getSeriesBound(series);\n        var accumulationRectCenter = new ChartLocation(accumulationRect.x + accumulationRect.width / 2, accumulationRect.y + accumulationRect.height / 2);\n        this.pieBaseCenter.x += (this.pieBaseCenter.x - accumulationRectCenter.x);\n        this.pieBaseCenter.y += (this.pieBaseCenter.y - accumulationRectCenter.y);\n        this.accumulation.origin = this.pieBaseCenter;\n    };\n    /**\n     * To find angles from series.\n     *\n     * @param {AccumulationSeries} series - The series for which to calculate angles.\n     * @returns {void}\n     */\n    PieBase.prototype.initAngles = function (series) {\n        var endAngle = isNullOrUndefined(series.endAngle) ? series.startAngle : series.endAngle;\n        this.totalAngle = (endAngle - series.startAngle) % 360;\n        this.startAngle = series.startAngle - 90;\n        this.totalAngle = this.totalAngle <= 0 ? (360 + this.totalAngle) : this.totalAngle;\n        this.startAngle = (this.startAngle < 0 ? (this.startAngle + 360) : this.startAngle) % 360;\n    };\n    /**\n     * To calculate data-label bound.\n     *\n     * @private\n     * @param {AccumulationSeries} series - The series for which to calculate data-label bounds.\n     * @param {boolean} visible - Indicates whether the data-labels are visible.\n     * @param {AccumulationLabelPosition} position - The position of the data-labels.\n     * @returns {void}\n     */\n    PieBase.prototype.defaultLabelBound = function (series, visible, position) {\n        var accumulationBound = this.getSeriesBound(series);\n        series.accumulationBound = accumulationBound;\n        series.labelBound = new Rect(accumulationBound.x, accumulationBound.y, accumulationBound.width + accumulationBound.x, accumulationBound.height + accumulationBound.y);\n        if (visible && position === 'Outside') {\n            series.labelBound = new Rect(Infinity, Infinity, -Infinity, -Infinity);\n        }\n    };\n    /**\n     * To calculate series bound.\n     *\n     * @private\n     * @param {AccumulationSeries} series - The series for which to calculate the bound.\n     * @returns {Rect} - Returns a rect.\n     */\n    PieBase.prototype.getSeriesBound = function (series) {\n        var rect = new Rect(Infinity, Infinity, -Infinity, -Infinity);\n        this.initAngles(series);\n        var start = this.startAngle;\n        var total = this.totalAngle;\n        var end = (this.startAngle + total) % 360;\n        end = (end === 0) ? 360 : end;\n        series.findMaxBounds(rect, this.getRectFromAngle(start));\n        series.findMaxBounds(rect, this.getRectFromAngle(end));\n        series.findMaxBounds(rect, new Rect(this.pieBaseCenter.x, this.pieBaseCenter.y, 0, 0));\n        var nextQuandrant = (Math.floor(start / 90) * 90 + 90) % 360;\n        var lastQuadrant = (Math.floor(end / 90) * 90) % 360;\n        lastQuadrant = (lastQuadrant === 0) ? 360 : lastQuadrant;\n        if (total >= 90 || lastQuadrant === nextQuandrant) {\n            series.findMaxBounds(rect, this.getRectFromAngle(nextQuandrant));\n            series.findMaxBounds(rect, this.getRectFromAngle(lastQuadrant));\n        }\n        if (start === 0 || (start + total >= 360)) {\n            series.findMaxBounds(rect, this.getRectFromAngle(0));\n        }\n        var length = nextQuandrant === lastQuadrant ? 0 : Math.floor(total / 90);\n        for (var i = 1; i < length; i++) {\n            nextQuandrant = nextQuandrant + 90;\n            if ((nextQuandrant < lastQuadrant || end < start) || total === 360) {\n                series.findMaxBounds(rect, this.getRectFromAngle(nextQuandrant));\n            }\n        }\n        rect.width -= rect.x;\n        rect.height -= rect.y;\n        return rect;\n    };\n    /**\n     * To get rect location size from angle.\n     *\n     * @param {number} angle - The angle in degrees.\n     * @returns {Rect} - The rect representing the location size from angle.\n     */\n    PieBase.prototype.getRectFromAngle = function (angle) {\n        var location = degreeToLocation(angle, this.pieBaseRadius, this.pieBaseCenter);\n        return new Rect(location.x, location.y, 0, 0);\n    };\n    /**\n     * To get path arc direction.\n     *\n     * @param {ChartLocation} center - The center coordinates of the arc.\n     * @param {number} start - The starting angle of the arc in degrees.\n     * @param {number} end - The ending angle of the arc in degrees.\n     * @param {number} radius - The radius of the arc.\n     * @param {number} innerRadius - The inner radius of the arc.\n     * @param {number} borderRadius - The border radius of the arc.\n     * @param {boolean} isBorder - It specifies whether it is for rendering a border.\n     * @param {AccPoints[]} seriesPoints - The points of the series.\n     * @returns {string} - The path string representing the arc direction.\n     */\n    PieBase.prototype.getPathArc = function (center, start, end, radius, innerRadius, borderRadius, isBorder, seriesPoints) {\n        var degree = end - start;\n        degree = degree < 0 ? (degree + 360) : degree;\n        var flag = (degree < 180) ? 0 : 1;\n        if (!innerRadius && innerRadius === 0) {\n            return this.getPiePath(center, degreeToLocation(start, radius, center), degreeToLocation(end, radius, center), radius, flag, borderRadius, seriesPoints);\n        }\n        else {\n            return this.getDoughnutPath(center, degreeToLocation(start, radius, center), degreeToLocation(end, radius, center), radius, degreeToLocation(start, innerRadius, center), degreeToLocation(end, innerRadius, center), innerRadius, flag, borderRadius, isBorder, seriesPoints);\n        }\n    };\n    /**\n     * To get pie direction.\n     *\n     * @param {ChartLocation} center - The center of the pie.\n     * @param {ChartLocation} start - The starting location of the pie.\n     * @param {ChartLocation} end - The ending location of the pie.\n     * @param {number} radius - The radius of the pie.\n     * @param {number} clockWise - The direction of the pie.\n     * @param {number} cornerRadius - The border radius of the arc.\n     * @param {AccPoints[]} seriesPoints - The points of the series.\n     * @returns {string} - The path direction for the pie.\n     */\n    PieBase.prototype.getPiePath = function (center, start, end, radius, clockWise, cornerRadius, seriesPoints) {\n        var sliceCount = this.sliceCheck(seriesPoints);\n        cornerRadius = sliceCount === 1 ? 0 : cornerRadius;\n        var startAngle = Math.atan2(start.y - center.y, start.x - center.x);\n        var endAngle = Math.atan2(end.y - center.y, end.x - center.x);\n        cornerRadius = this.adjustCornerRadius(startAngle, endAngle, radius, cornerRadius);\n        var x1 = start.x - cornerRadius * Math.cos(startAngle);\n        var y1 = start.y - cornerRadius * Math.sin(startAngle);\n        var x2 = end.x - cornerRadius * Math.cos(Math.PI / 2 + endAngle);\n        var y2 = end.y - cornerRadius * Math.sin(Math.PI / 2 + endAngle);\n        var cx2 = end.x - cornerRadius * Math.cos(endAngle);\n        var cy2 = end.y - cornerRadius * Math.sin(endAngle);\n        var cx1 = start.x + cornerRadius * Math.cos(Math.PI / 2 + startAngle);\n        var cy1 = start.y + cornerRadius * Math.sin(Math.PI / 2 + startAngle);\n        return \"M \" + center.x + \" \" + center.y + \" L \" + x1 + \" \" + y1 + \" A \" + cornerRadius + \" \" + cornerRadius + \" 0 0 1 \" + cx1 + \" \" + cy1 + \" A \" + radius + \" \" + radius + \" 0 \" + clockWise + \" 1 \" + x2 + \" \" + y2 + \" A \" + cornerRadius + \" \" + cornerRadius + \" 0 0 1 \" + cx2 + \" \" + cy2 + \" Z\";\n    };\n    /**\n     * To get doughnut direction.\n     *\n     * @param {ChartLocation} center - The center of the doughnut.\n     * @param {ChartLocation} start - The starting location of the outer doughnut.\n     * @param {ChartLocation} end - The ending location of the outer doughnut.\n     * @param {number} radius - The radius of the outer doughnut.\n     * @param {ChartLocation} innerStart - The starting location of the inner doughnut.\n     * @param {ChartLocation} innerEnd - The ending location of the inner doughnut.\n     * @param {number} innerRadius - The radius of the inner doughnut.\n     * @param {number} clockWise - The direction of the doughnut.\n     * @param {number} cornerRadius - The border radius of the arc.\n     * @param {boolean} isBorder - It specifies whether it is for rendering a border.\n     * @param {AccPoints[]} seriesPoints - The points of the series.\n     * @returns {string} - The path direction for the doughnut.\n     */\n    PieBase.prototype.getDoughnutPath = function (center, start, end, radius, innerStart, innerEnd, innerRadius, clockWise, cornerRadius, isBorder, seriesPoints) {\n        var sliceCount = this.sliceCheck(seriesPoints);\n        cornerRadius = sliceCount === 1 ? 0 : cornerRadius;\n        var startAngle = Math.atan2(start.y - innerStart.y, start.x - innerStart.x);\n        var endAngle = Math.atan2(end.y - innerEnd.y, end.x - innerEnd.x);\n        cornerRadius = this.adjustCornerRadius(startAngle, endAngle, innerRadius, cornerRadius);\n        cornerRadius = (isBorder && (this.innerRadius === 0)) ? cornerRadius * -1 : cornerRadius;\n        var x1 = start.x - cornerRadius * Math.cos(startAngle);\n        var y1 = start.y - cornerRadius * Math.sin(startAngle);\n        var x2 = end.x - cornerRadius * Math.cos(Math.PI / 2 + endAngle);\n        var y2 = end.y - cornerRadius * Math.sin(Math.PI / 2 + endAngle);\n        var x3 = innerEnd.x + cornerRadius * Math.cos(endAngle);\n        var y3 = innerEnd.y + cornerRadius * Math.sin(endAngle);\n        var x4 = innerStart.x + cornerRadius * Math.cos(Math.PI / 2 + startAngle);\n        var y4 = innerStart.y + cornerRadius * Math.sin(Math.PI / 2 + startAngle);\n        var cx1 = start.x + cornerRadius * Math.cos(Math.PI / 2 + startAngle);\n        var cy1 = start.y + cornerRadius * Math.sin(Math.PI / 2 + startAngle);\n        var cx2 = end.x - cornerRadius * Math.cos(endAngle);\n        var cy2 = end.y - cornerRadius * Math.sin(endAngle);\n        var cx3 = innerEnd.x - cornerRadius * Math.cos(Math.PI / 2 + endAngle);\n        var cy3 = innerEnd.y - cornerRadius * Math.sin(Math.PI / 2 + endAngle);\n        var cx4 = innerStart.x + cornerRadius * Math.cos(startAngle);\n        var cy4 = innerStart.y + cornerRadius * Math.sin(startAngle);\n        if (isBorder) {\n            return \"M \" + cx1 + \" \" + cy1 + \" A \" + radius + \" \" + radius + \" 0 \" + clockWise + \" 1 \" + x2 + \" \" + y2 + \" L \" + cx3 + \" \" + cy3 + \" A \" + innerRadius + \" \" + innerRadius + \" 0 \" + clockWise + \" 0 \" + x4 + \" \" + y4 + \" Z\";\n        }\n        else {\n            return \"M \" + x1 + \" \" + y1 + \" A \" + cornerRadius + \" \" + cornerRadius + \" 0 0 1 \" + cx1 + \" \" + cy1 + \" A \" + radius + \" \" + radius + \" 0 \" + clockWise + \" 1 \" + x2 + \" \" + y2 + \" A \" + cornerRadius + \" \" + cornerRadius + \" 0 0 1 \" + cx2 + \" \" + cy2 + \" L \" + x3 + \" \" + y3 + \" A \" + cornerRadius + \" \" + cornerRadius + \" 0 0 1 \" + cx3 + \" \" + cy3 + \" A \" + innerRadius + \" \" + innerRadius + \" 0 \" + clockWise + \" 0 \" + x4 + \" \" + y4 + \" A \" + cornerRadius + \" \" + cornerRadius + \" 0 0 1 \" + cx4 + \" \" + cy4 + \" Z\";\n        }\n    };\n    /**\n     * Adjusts the corner radius of a pie chart slice based on the angle of the slice.\n     * Ensures that the corner radius does not exceed a value that would cause the arcs\n     * of the slice to overlap or create an invalid shape.\n     *\n     * @param {number} startAngle - The start angle of the pie.\n     * @param {number} endAngle - The end angle of the pie.\n     * @param {number} radius - The radius of the pie.\n     * @param {number} cornerRadius - The border radius of the arc.\n     * @returns {number} - The adjusted corner radius of the pie.\n     */\n    PieBase.prototype.adjustCornerRadius = function (startAngle, endAngle, radius, cornerRadius) {\n        var anglePerSlice = Math.abs(endAngle - startAngle);\n        if (anglePerSlice > Math.PI) {\n            anglePerSlice = 2 * Math.PI - anglePerSlice; // Handle large angles that cross the -PI to PI boundary\n        }\n        // Adjust corner radius based on the angle per slice\n        var angleFactor = anglePerSlice / (2 * Math.PI);\n        var adjustedCornerRadius = radius * angleFactor;\n        return Math.min(cornerRadius, adjustedCornerRadius);\n    };\n    /**\n     * To Check slice count.\n     *\n     * @param {AccPoints[]} seriesPoints - The points of the series.\n     * @returns {number} - The number of visible pie slice.\n     */\n    PieBase.prototype.sliceCheck = function (seriesPoints) {\n        var isOneSlice = 0;\n        for (var index = 0; index < seriesPoints.length; index++) {\n            var point = seriesPoints[index];\n            if (point.visible) {\n                isOneSlice++;\n            }\n        }\n        return isOneSlice;\n    };\n    /**\n     * Method to start animation for pie series.\n     *\n     * @param {Element} slice - The slice element to animate.\n     * @param {AccumulationSeries} series - The accumulation chart control.\n     * @param {Element} groupElement - The group element containing the pie series.\n     * @param {number} borderRadius - The border radius of the arc.\n     * @param {AccPoints[]} seriesPoints - The points of the series.\n     * @returns {void}\n     */\n    PieBase.prototype.doAnimation = function (slice, series, groupElement, borderRadius, seriesPoints) {\n        var _this = this;\n        var startAngle = series.startAngle - 90;\n        var duration = this.accumulation.duration ? this.accumulation.duration : series.animation.duration;\n        var value;\n        this.pieBaseCenter.x += 1;\n        var radius = Math.max(this.accumulation.availableSize.height, this.accumulation.availableSize.width) * 0.75;\n        radius += radius * (0.414); // formula r + r / 2 * (1.414 -1)\n        var effect = getAnimationFunction('Linear'); // need to check animation type\n        new Animation({}).animate(slice, {\n            duration: (duration === 0 && animationMode === 'Enable') ? 1000 : duration,\n            delay: series.animation.delay,\n            progress: function (args) {\n                value = effect(args.timeStamp, startAngle, _this.totalAngle, args.duration);\n                slice.setAttribute('d', _this.getPathArc(_this.pieBaseCenter, startAngle, value, radius, 0, borderRadius, false, seriesPoints));\n            },\n            end: function () {\n                _this.pieBaseCenter.x -= 1;\n                slice.setAttribute('d', _this.getPathArc(_this.pieBaseCenter, 0, 359.99999, radius, 0, borderRadius, false, seriesPoints));\n                _this.accumulation.trigger(animationComplete, _this.accumulation.isBlazor ? {} :\n                    { series: series, accumulation: _this.accumulation, chart: _this.accumulation });\n                var datalabelGroup = getElement(_this.accumulation.element.id + '_datalabel_Series_' + series.index);\n                if (datalabelGroup) {\n                    markerAnimate(datalabelGroup, series.animation.delay, series.animation.duration, series, null, null, false);\n                }\n                groupElement.style.cssText = '';\n                var annotationElement = getElement(_this.accumulation.element.id + '_Annotation_Collections');\n                if (annotationElement) {\n                    annotationElement.style.visibility = 'visible';\n                }\n            }\n        });\n    };\n    return PieBase;\n}(AccumulationBase));\nexport { PieBase };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}