{"ast":null,"code":"import { Animation, animationMode, isNullOrUndefined, remove } from '@syncfusion/ej2-base';\nimport { DoubleRange } from '../utils/double-range';\nimport { appendChildElement, redrawElement, pathAnimation, valueToCoefficient, getVisiblePoints, colorNameToHex, checkColorFormat, applyZLight } from '../../common/utils/helper';\nimport { getAnimationFunction, getPoint, getMinPointsDelta } from '../../common/utils/helper';\nimport { PathOption, Rect } from '@syncfusion/ej2-svg-base';\nimport { pointRender } from '../../common/model/constants';\n/**\n * Base class for column series.\n * This class provides common properties and methods for column series in the chart.\n *\n * @private\n */\nvar ColumnBase = /** @class */function () {\n  function ColumnBase() {}\n  ColumnBase.prototype.getSideBySideInfo = function (series) {\n    series.isRectSeries = true;\n    if (series.chart.enableSideBySidePlacement && !series.position || !isNullOrUndefined(series.columnWidthInPixel)) {\n      this.getSideBySidePositions(series);\n    }\n    if (series.columnWidthInPixel) {\n      return new DoubleRange(0, 0);\n    }\n    var position = series.type === 'Histogram' || !series.chart.enableSideBySidePlacement ? 0 : series.position;\n    var rectCount = series.type === 'Histogram' || !series.chart.enableSideBySidePlacement ? 1 : series.rectCount;\n    var visibleSeries = series.chart.visibleSeries;\n    var seriesSpacing = series.chart.enableSideBySidePlacement ? series.columnSpacing : 0; // Column Spacing\n    var pointSpacing = series.columnWidth === null || isNaN(+series.columnWidth) ? series.type === 'Histogram' ? 1 : 0.7 : Math.min(series.columnWidth, 1); // Column width\n    var minimumPointDelta = getMinPointsDelta(series.xAxis, visibleSeries);\n    var width = minimumPointDelta * pointSpacing;\n    var radius;\n    var location = position / rectCount - 0.5;\n    var doubleRange = new DoubleRange(location, location + 1 / rectCount);\n    if (!(isNaN(doubleRange.start) || isNaN(doubleRange.end))) {\n      if (series.groupName && series.type.indexOf('Stacking') === -1) {\n        var mainColumnWidth_1 = 0.7;\n        series.chart.series.filter(function (series) {\n          if (series.columnWidth > mainColumnWidth_1) {\n            mainColumnWidth_1 = series.columnWidth;\n          }\n        });\n        var mainWidth = minimumPointDelta * mainColumnWidth_1;\n        var mainDoubleRange = new DoubleRange(doubleRange.start * mainWidth, doubleRange.end * mainWidth);\n        var difference = (mainDoubleRange.delta - (doubleRange.end * width - doubleRange.start * width)) / 2;\n        doubleRange = new DoubleRange(mainDoubleRange.start + difference, mainDoubleRange.end - difference);\n      } else {\n        doubleRange = new DoubleRange(doubleRange.start * width, doubleRange.end * width);\n      }\n      radius = seriesSpacing * doubleRange.delta;\n      doubleRange = new DoubleRange(doubleRange.start + radius / 2, doubleRange.end - radius / 2);\n    }\n    return doubleRange;\n  };\n  /**\n   * Gets the rectangle bounds based on two points.\n   *\n   * @param {number} x1 - The x-coordinate of the first point.\n   * @param {number} y1 - The y-coordinate of the first point.\n   * @param {number} x2 - The x-coordinate of the second point.\n   * @param {number} y2 - The y-coordinate of the second point.\n   * @param {Series} series - The series associated with the rectangle.\n   * @returns {Rect} - The rectangle bounds.\n   */\n  ColumnBase.prototype.getRectangle = function (x1, y1, x2, y2, series) {\n    var point1 = getPoint(x1, y1, series.xAxis, series.yAxis, series.chart.requireInvertedAxis);\n    var point2 = getPoint(x2, y2, series.xAxis, series.yAxis, series.chart.requireInvertedAxis);\n    return new Rect(Math.min(point1.x, point2.x), Math.min(point1.y, point2.y), Math.abs(point2.x - point1.x), Math.abs(point2.y - point1.y));\n  };\n  /**\n   * Draws a cylinder using the provided options and element.\n   *\n   * @param {PathOption} options - The path options for drawing the cylinder.\n   * @param {HTMLElement} element - The HTML element to which the cylinder is drawn.\n   * @param {CylinderSeriesOption} cylinderSeriesOption - The options specific to the cylinder series.\n   * @param {Rect} rect - The rectangle bounds within which the cylinder is drawn.\n   * @param {Series} series - The series associated with the cylinder.\n   * @returns {void}\n   */\n  ColumnBase.prototype.drawCylinder = function (options, element, cylinderSeriesOption, rect, series) {\n    var width = rect.width;\n    var height = rect.height;\n    if (series.chart.enableCanvas) {\n      var ctx = series.chart.canvasRender.ctx;\n      var canvasCtx = ctx;\n      ctx.save();\n      var gradientColor = colorNameToHex(options.fill);\n      var x = rect.x + series.clipRect.x;\n      var y = rect.y + series.clipRect.y;\n      var arc = 2 * Math.PI + 0.1;\n      var rx = void 0;\n      var ry = void 0;\n      var cx1 = void 0;\n      var cx2 = void 0;\n      var cy1 = void 0;\n      var cy2 = void 0;\n      var x1 = void 0;\n      var x2 = void 0;\n      var y1 = void 0;\n      var y2 = void 0;\n      var cx = void 0;\n      var cy = void 0;\n      var xl = void 0;\n      var yl = void 0;\n      var xPos = void 0;\n      var yPos = void 0;\n      var step = void 0;\n      var rxt = void 0;\n      var ryt = void 0;\n      var gx1 = 0;\n      var gx2 = 0;\n      var gy1 = 0;\n      var gy2 = 0;\n      var ini = 0;\n      ctx.fillStyle = applyZLight(gradientColor, 0.9);\n      ctx.lineWidth = 0;\n      ctx.strokeStyle = applyZLight(gradientColor, 0.9);\n      ctx.globalAlpha = options.opacity;\n      if (cylinderSeriesOption.isColumn) {\n        gx1 = x;\n        gx2 = width + x;\n        rx = width / 2;\n        ry = rx / 4;\n        cx2 = cx1 = x + rx;\n        y2 = cy1 = y - ry;\n        x2 = x;\n        x1 = x + width;\n        cy2 = y1 = y + height - ry;\n        step = Math.PI;\n        rxt = -rx;\n        ryt = ry;\n        if (cylinderSeriesOption.stacking) {\n          if (!cylinderSeriesOption.isLastSeries) {\n            y2 = cy1 = y + ry;\n          }\n        }\n      } else {\n        gy2 = height + y;\n        gy1 = y;\n        ry = height / 2;\n        rx = ry / 4;\n        x2 = cx1 = x + rx;\n        x1 = cx2 = x + width + rx;\n        y1 = y + height;\n        y2 = y;\n        cy2 = cy1 = y + ry;\n        ini = Math.PI / 2;\n        step = Math.PI * 1.5;\n        if (cylinderSeriesOption.stacking) {\n          if (!cylinderSeriesOption.isLastSeries) {\n            x1 = cx2 = x + width - rx;\n          }\n        }\n        ry = -ry;\n        rx = -rx;\n        rxt = rx;\n        ryt = -ry;\n      }\n      var color = applyZLight(gradientColor, 0.7);\n      var gradient = ctx.createLinearGradient(gx1, gy1, gx2, gy2);\n      gradient.addColorStop(0, gradientColor);\n      gradient.addColorStop(0.3, color);\n      gradient.addColorStop(0.7, color);\n      gradient.addColorStop(1, gradientColor);\n      for (var j = 1; j <= 4; j++) {\n        var i = 0;\n        if (j < 4) {\n          ctx.beginPath();\n        }\n        if (j % 2 === 0) {\n          cx = cx2;\n          cy = cy2;\n          xl = x2;\n          yl = y2;\n        } else {\n          cx = cx1;\n          cy = cy1;\n          xl = x1;\n          yl = y1;\n        }\n        if (j === 4) {\n          rx = rxt;\n          ry = ryt;\n          ctx.fillStyle = gradient;\n        }\n        if (j > 2) {\n          i = ini;\n          arc = step;\n        }\n        for (; i <= arc; i += 0.1) {\n          xPos = cx - rx * Math.cos(i);\n          yPos = cy + ry * Math.sin(i);\n          if (i === 0) {\n            ctx.moveTo(xPos, yPos);\n          } else {\n            ctx.lineTo(xPos, yPos);\n          }\n        }\n        if (j > 2) {\n          ctx.lineTo(xl, yl);\n        }\n        if (j !== 3) {\n          ctx.stroke();\n          ctx.fill();\n        }\n      }\n      if (options.id.indexOf('Series') >= 0) {\n        ctx.clip();\n        ctx.restore();\n        ctx = canvasCtx;\n      }\n    } else {\n      var chart = series.chart;\n      var x = rect.x;\n      var y = rect.y;\n      var id = options.id;\n      var gradientColor = options.fill;\n      var fillColor = gradientColor;\n      var format = checkColorFormat(gradientColor);\n      if (!format) {\n        gradientColor = colorNameToHex(gradientColor);\n      }\n      var AEx = 0;\n      var AEy = 0;\n      var LX = 0;\n      var LY = 0;\n      var GX = 0;\n      var GY = 0;\n      var X = void 0;\n      var Y = void 0;\n      var X1 = void 0;\n      var Y1 = void 0;\n      var X2 = void 0;\n      var Y2 = void 0;\n      var rx = void 0;\n      var ry = void 0;\n      var i = 2;\n      if (cylinderSeriesOption.isColumn) {\n        rx = width / 2;\n        ry = rx / 4;\n        X = X1 = x;\n        Y = ry < y ? y - ry : cylinderSeriesOption.stacking ? y + ry : y - ry;\n        Y1 = Y;\n        AEx = 2 * rx;\n        LY = ry < y ? height : height < 2 * ry ? height : cylinderSeriesOption.stacking ? height - 2 * ry : height;\n        X2 = X;\n        Y2 = ry < y ? Y + height : height < Y ? height + Y : cylinderSeriesOption.stacking ? height + (y - ry) : height + Y;\n        GX = 100;\n        if (cylinderSeriesOption.stacking) {\n          if (!cylinderSeriesOption.isLastSeries) {\n            Y = Y1 = y + ry;\n            LY = height < rx / 2 ? height : height - rx / 2;\n          }\n        }\n      } else {\n        ry = height / 2;\n        rx = ry / 4;\n        Y = Y1 = y;\n        X = X1 = Math.abs(x - rx);\n        AEy = 2 * ry;\n        LX = width;\n        X2 = X + width;\n        Y2 = Y;\n        GY = 100;\n        if (cylinderSeriesOption.stacking) {\n          if (!cylinderSeriesOption.isLastSeries) {\n            X2 = X + width - rx * 2;\n            LX = width - rx * 2;\n          }\n        }\n      }\n      remove(this.element);\n      while (i--) {\n        options.d = 'M' + X.toString() + ',' + Y.toString() + 'a' + rx.toString() + ',' + ry.toString() + ' 0 1,0 ' + AEx.toString() + ',' + AEy.toString() + 'a' + rx.toString() + ',' + ry.toString() + ' 0 1,0 ' + (-1 * AEx).toString() + ',' + (-1 * AEy).toString();\n        options.id = id + '_' + 'Region_' + i;\n        options.fill = applyZLight(gradientColor, 0.9);\n        if (i % 2 === 0 && series.type !== 'StackingBar100' && series.type !== 'StackingBar' && series.type !== 'Bar') {\n          options.fill = options.fill + '10';\n        }\n        this.element = chart.renderer.drawPath(this.options, new Int32Array([series.clipRect.x, series.clipRect.y]));\n        appendChildElement(series.chart.enableCanvas, series.seriesElement, this.element, chart.redraw);\n        X = X2;\n        Y = Y2;\n      }\n      options.d = 'M' + X1.toString() + ',' + Y1.toString() + 'a' + rx.toString() + ',' + ry.toString() + ' 0 1,0 ' + AEx.toString() + ',' + AEy.toString() + 'l' + LX.toString() + ' ' + LY.toString() + 'a' + rx.toString() + ',' + ry.toString() + ' 0 1,1 ' + (-1 * AEx).toString() + ',' + (-1 * AEy).toString() + ' z';\n      options.id = id + '_' + 'Region_2';\n      options.fill = applyZLight(gradientColor, 0.7);\n      var optiong = void 0;\n      if (fillColor.indexOf('url') === -1) {\n        if (!document.getElementById(id)) {\n          optiong = {\n            'id': id,\n            x1: '0%',\n            y1: '0%',\n            x2: GX.toString() + '%',\n            y2: GY.toString() + '%'\n          };\n          var gradientElement = [{\n            colorStop: '0%',\n            color: gradientColor\n          }, {\n            colorStop: '30%',\n            color: applyZLight(gradientColor, 0.7)\n          }, {\n            colorStop: '70%',\n            color: applyZLight(gradientColor, 0.7)\n          }, {\n            colorStop: '100%',\n            color: gradientColor\n          }];\n          this.drawGradient(optiong, gradientElement, series);\n        }\n        options.fill = 'url(#' + optiong.id + ')';\n      }\n      this.element = chart.renderer.drawPath(this.options, new Int32Array([series.clipRect.x, series.clipRect.y]));\n      appendChildElement(series.chart.enableCanvas, series.seriesElement, this.element, chart.redraw);\n    }\n  };\n  /**\n   * Draws a gradient using the provided options and gradient element.\n   *\n   * @param {OptionGradient} optiong - The gradient options for drawing the gradient.\n   * @param {Object} gradientElement - The gradient element to which the gradient is applied.\n   * @param {Series} series - The series associated with the gradient.\n   * @returns {void}\n   */\n  ColumnBase.prototype.drawGradient = function (optiong, gradientElement, series) {\n    var chart = series.chart;\n    var defElement = chart.renderer.createDefs();\n    var xmlns = 'http://www.w3.org/2000/svg';\n    var linearGradientElement = document.createElementNS(xmlns, 'linearGradient');\n    linearGradientElement.setAttribute('id', optiong.id);\n    linearGradientElement.setAttribute('x1', optiong.x1);\n    linearGradientElement.setAttribute('y1', optiong.y1);\n    linearGradientElement.setAttribute('x2', optiong.x2);\n    linearGradientElement.setAttribute('y2', optiong.y2);\n    for (var i = 0; i < gradientElement.length; i++) {\n      var stopElement = document.createElementNS(xmlns, 'stop');\n      stopElement.setAttribute('offset', gradientElement[i].colorStop);\n      stopElement.setAttribute('stop-color', gradientElement[i].color);\n      stopElement.setAttribute('stop-opacity', '1');\n      linearGradientElement.appendChild(stopElement);\n    }\n    series.seriesElement.appendChild(defElement);\n    defElement.appendChild(linearGradientElement);\n  };\n  /**\n   * To get the position of each series.\n   *\n   * @param {Series} series - The series for which side-by-side positions are calculated.\n   * @returns {void}\n   * @private\n   */\n  ColumnBase.prototype.getSideBySidePositions = function (series) {\n    var chart = series.chart;\n    for (var _i = 0, _a = chart.columns; _i < _a.length; _i++) {\n      var columnItem = _a[_i];\n      for (var _b = 0, _c = chart.rows; _b < _c.length; _b++) {\n        var item = _c[_b];\n        this.findRectPosition(series.findSeriesCollection(columnItem, item, false));\n      }\n    }\n  };\n  ColumnBase.prototype.findRectPosition = function (seriesCollection) {\n    var groupingValues = [];\n    var vSeries = {\n      rectCount: 0,\n      position: null\n    };\n    for (var i = 0; i < seriesCollection.length; i++) {\n      var value = seriesCollection[i];\n      if (value.type.indexOf('Stacking') !== -1 || value.groupName !== '') {\n        var groupName = value.type.indexOf('Stacking') !== -1 ? value.stackingGroup : value.type + value.groupName;\n        if (groupName) {\n          if (groupingValues[groupName] === undefined) {\n            value.position = vSeries.rectCount;\n            groupingValues[groupName] = vSeries.rectCount++;\n          } else {\n            value.position = groupingValues[groupName];\n          }\n        } else {\n          if (vSeries.position === null) {\n            value.position = vSeries.rectCount;\n            vSeries.position = vSeries.rectCount++;\n          } else {\n            value.position = vSeries.position;\n          }\n        }\n      } else {\n        value.position = vSeries.rectCount++;\n      }\n    }\n    for (var i = 0; i < seriesCollection.length; i++) {\n      var value = seriesCollection[i];\n      value.rectCount = vSeries.rectCount;\n    }\n  };\n  /**\n   * Updates the location of the symbol based on the point and rect coordinates.\n   *\n   * @param {Points} point - The point for which the symbol location is updated.\n   * @param {Rect} rect - The rect representing the symbol location.\n   * @param {Series} series - The series to which the point belongs.\n   * @returns {void}\n   */\n  ColumnBase.prototype.updateSymbolLocation = function (point, rect, series) {\n    if (!series.chart.requireInvertedAxis) {\n      this.updateXRegion(point, rect, series);\n    } else {\n      this.updateYRegion(point, rect, series);\n    }\n    if (series.type === 'Histogram') {\n      point.minimum = +point.x - series.histogramValues.binWidth / 2;\n      point.maximum = +point.x + series.histogramValues.binWidth / 2;\n    }\n  };\n  /**\n   * Updates the x-region of the symbol based on the point and rect coordinates.\n   *\n   * @param {Points} point - The point for which the x-region is updated.\n   * @param {Rect} rect - The rect representing the x-region.\n   * @param {Series} series - The series to which the point belongs.\n   * @returns {void}\n   */\n  ColumnBase.prototype.updateXRegion = function (point, rect, series) {\n    point.symbolLocations.push({\n      x: rect.x + rect.width / 2,\n      y: series.seriesType === 'BoxPlot' || series.seriesType.indexOf('HighLow') !== -1 || point.yValue >= 0 === !series.yAxis.isAxisInverse ? rect.y : rect.y + rect.height\n    });\n    this.getRegion(point, rect, series);\n    if (series.type === 'RangeColumn') {\n      point.symbolLocations.push({\n        x: rect.x + rect.width / 2,\n        y: rect.y + rect.height\n      });\n    }\n  };\n  /**\n   * Updates the y-region of the symbol based on the point and rect coordinates.\n   *\n   * @param {Points} point - The point for which the y-region is updated.\n   * @param {Rect} rect - The rect representing the y-region.\n   * @param {Series} series - The series to which the point belongs.\n   * @returns {void}\n   */\n  ColumnBase.prototype.updateYRegion = function (point, rect, series) {\n    point.symbolLocations.push({\n      x: series.seriesType === 'BoxPlot' || series.seriesType.indexOf('HighLow') !== -1 || point.yValue >= 0 === !series.yAxis.isAxisInverse ? rect.x + rect.width : rect.x,\n      y: rect.y + rect.height / 2\n    });\n    this.getRegion(point, rect, series);\n    if (series.type === 'RangeColumn') {\n      point.symbolLocations.push({\n        x: rect.x,\n        y: rect.y + rect.height / 2\n      });\n    }\n  };\n  /**\n   * To render the marker for the series.\n   *\n   * @param {Series} series - The series for which markers are rendered.\n   * @returns {void}\n   * @private\n   */\n  ColumnBase.prototype.renderMarker = function (series) {\n    if (series.marker && series.marker.visible) {\n      series.chart.markerRender.render(series);\n    }\n  };\n  /**\n   * To get the marker region when Y value is 0\n   *\n   * @param {Points} point point\n   * @param {rect} rect rect\n   * @param {Series} series series\n   * @returns {void}\n   */\n  ColumnBase.prototype.getRegion = function (point, rect, series) {\n    if (point.y === 0) {\n      var markerWidth = series.marker && series.marker.width ? series.marker.width : 0;\n      var markerHeight = series.marker && series.marker.height ? series.marker.height : 0;\n      point.regions.push(new Rect(point.symbolLocations[0].x - markerWidth, point.symbolLocations[0].y - markerHeight, 2 * markerWidth, 2 * markerHeight));\n    } else {\n      point.regions.push(rect);\n    }\n  };\n  /**\n   * Triggers the point render event.\n   *\n   * @param {Series} series - The series associated with the point.\n   * @param {Points} point - The data point for which the event is triggered.\n   * @param {string} fill - The fill color of the point.\n   * @param {BorderModel} border - The border settings of the point.\n   * @returns {IPointRenderEventArgs} - The event arguments.\n   */\n  ColumnBase.prototype.triggerEvent = function (series, point, fill, border) {\n    var argsData = {\n      cancel: false,\n      name: pointRender,\n      series: series,\n      point: point,\n      fill: series.setPointColor(point, fill),\n      border: series.setBorderColor(point, border),\n      cornerRadius: series.cornerRadius\n    };\n    series.chart.trigger(pointRender, argsData);\n    point.color = argsData.fill;\n    return argsData;\n  };\n  /**\n   * Draws a rectangle for the data point.\n   *\n   * @param {Series} series - The series associated with the point.\n   * @param {Points} point - The data point for which the rectangle is drawn.\n   * @param {Rect} rect - The rect bounds.\n   * @param {IPointRenderEventArgs} argsData - The event arguments.\n   * @returns {void}\n   */\n  ColumnBase.prototype.drawRectangle = function (series, point, rect, argsData) {\n    var chart = series.chart;\n    var check = chart.requireInvertedAxis ? rect.height : rect.width;\n    if (check <= 0) {\n      return null;\n    }\n    var direction;\n    if (point.y === 0) {\n      // For 0 values corner radius will not calculate\n      direction = this.calculateRoundedRectPath(rect, 0, 0, 0, 0);\n    } else {\n      var topLeft = void 0;\n      var topRight = void 0;\n      var bottomLeft = void 0;\n      var bottomRight = void 0;\n      var isNegative = point.y < 0;\n      if (chart.requireInvertedAxis) {\n        topLeft = isNegative ? argsData.cornerRadius.topRight : argsData.cornerRadius.topLeft;\n        topRight = isNegative ? argsData.cornerRadius.topLeft : argsData.cornerRadius.topRight;\n        bottomLeft = isNegative ? argsData.cornerRadius.bottomRight : argsData.cornerRadius.bottomLeft;\n        bottomRight = isNegative ? argsData.cornerRadius.bottomLeft : argsData.cornerRadius.bottomRight;\n      } else {\n        topLeft = isNegative ? argsData.cornerRadius.bottomLeft : argsData.cornerRadius.topLeft;\n        topRight = isNegative ? argsData.cornerRadius.bottomRight : argsData.cornerRadius.topRight;\n        bottomLeft = isNegative ? argsData.cornerRadius.topLeft : argsData.cornerRadius.bottomLeft;\n        bottomRight = isNegative ? argsData.cornerRadius.topRight : argsData.cornerRadius.bottomRight;\n      }\n      direction = this.calculateRoundedRectPath(rect, topLeft, topRight, bottomLeft, bottomRight, chart.requireInvertedAxis);\n    }\n    var name = series.category === 'Indicator' ? chart.element.id + '_Indicator_' + series.index + '_' + series.name + '_Point_' + point.index : chart.element.id + '_Series_' + series.index + '_Point_' + (series.removedPointIndex !== null && series.removedPointIndex <= point.index ? point.index + 1 : point.index);\n    var previousElement = redrawElement(chart.redraw, name);\n    var previousDirection = previousElement ? previousElement.getAttribute('d') : '';\n    this.options = new PathOption(name, argsData.fill, argsData.border.width, argsData.border.color, series.opacity, series.border.dashArray, series.columnFacet === 'Cylinder' ? '' : direction);\n    this.element = chart.renderer.drawPath(this.options, new Int32Array([series.clipRect.x, series.clipRect.y]));\n    if (series.removedPointIndex !== null && series.removedPointIndex <= point.index) {\n      this.element.id = chart.element.id + '_Series_' + series.index + '_Point_' + point.index;\n    }\n    switch (series.seriesType) {\n      case 'XY':\n        this.element.setAttribute('role', 'img');\n        this.element.setAttribute('aria-label', series.accessibility.accessibilityDescriptionFormat ? series.formatAccessibilityDescription(point, series) : point.x + ':' + point.yValue + ', ' + series.name);\n        break;\n      case 'HighLow':\n        this.element.setAttribute('role', 'img');\n        this.element.setAttribute('aria-label', series.accessibility.accessibilityDescriptionFormat ? series.formatAccessibilityDescription(point, series) : point.x + ':' + point.high + ', ' + point.low + ', ' + series.name);\n        break;\n    }\n    if (!(series.columnFacet === 'Cylinder' && (chart.redraw || !chart.enableAnimation) && series.seriesElement.querySelector('#' + this.element.id))) {\n      appendChildElement(series.chart.enableCanvas, series.seriesElement, this.element, chart.redraw);\n    }\n    if (!series.chart.enableCanvas) {\n      pathAnimation(this.element, series.columnFacet === 'Cylinder' ? '' : direction, chart.redraw, previousDirection, chart.duration);\n    }\n  };\n  /**\n   * To animate the series.\n   *\n   * @param {Series} series - The series to be animated.\n   * @returns {void}\n   * @private\n   */\n  ColumnBase.prototype.animate = function (series) {\n    var rectElements = series.seriesElement.childNodes;\n    var count = series.category === 'Indicator' ? 0 : 1;\n    var visiblePoints = getVisiblePoints(series);\n    for (var _i = 0, visiblePoints_1 = visiblePoints; _i < visiblePoints_1.length; _i++) {\n      var point = visiblePoints_1[_i];\n      if (!point.symbolLocations.length && !(series.type === 'BoxAndWhisker' && point.regions.length)) {\n        continue;\n      }\n      if ((series.type === 'Column' || series.type === 'Bar' || series.type === 'StackingColumn' || series.type === 'StackingColumn100' || series.type === 'StackingBar' || series.type === 'StackingBar100') && series.columnFacet === 'Cylinder') {\n        for (var j = 0; j < rectElements.length; j++) {\n          this.animateRect(rectElements[j], series, point);\n        }\n      } else {\n        this.animateRect(rectElements[count], series, point);\n        count++;\n      }\n    }\n  };\n  /**\n   * Animates the rect element.\n   *\n   * @param {HTMLElement} element - The rect element to be animated.\n   * @param {Series} series - The series associated with the rect.\n   * @param {Points} point - The data point associated with the rect.\n   * @returns {void}\n   */\n  ColumnBase.prototype.animateRect = function (element, series, point) {\n    var option = series.animation;\n    var duration = series.chart.animated ? series.chart.duration : option.duration;\n    var effect = getAnimationFunction('Linear');\n    var isPlot = point.yValue < 0;\n    var x;\n    var y;\n    var elementHeight = +point.regions[0].height;\n    var elementWidth = +point.regions[0].width;\n    var centerX;\n    var centerY;\n    if (!series.chart.requireInvertedAxis) {\n      x = +point.regions[0].x;\n      if (series.type.indexOf('Stacking') > -1) {\n        y = (1 - valueToCoefficient(0, series.yAxis)) * series.yAxis.rect.height;\n        centerX = x;\n        centerY = y;\n      } else {\n        y = +point.regions[0].y;\n        centerY = series.seriesType.indexOf('HighLow') !== -1 || series.type.indexOf('Waterfall') !== -1 ? y + elementHeight / 2 : isPlot !== series.yAxis.isAxisInverse ? y : y + elementHeight;\n        centerX = isPlot ? x : x + elementWidth;\n      }\n    } else {\n      y = +point.regions[0].y;\n      if (series.type.indexOf('Stacking') > -1) {\n        x = valueToCoefficient(0, series.yAxis) * series.yAxis.rect.width;\n        centerX = x;\n        centerY = y;\n      } else {\n        x = +point.regions[0].x;\n        centerY = isPlot ? y : y + elementHeight;\n        centerX = series.seriesType.indexOf('HighLow') !== -1 || series.type.indexOf('Waterfall') !== -1 ? x + elementWidth / 2 : isPlot !== series.yAxis.isAxisInverse ? x + elementWidth : x;\n      }\n    }\n    var value;\n    if (!isNullOrUndefined(element)) {\n      element.style.visibility = 'hidden';\n      new Animation({}).animate(element, {\n        duration: duration === 0 && animationMode === 'Enable' ? 1000 : duration,\n        delay: option.delay,\n        progress: function (args) {\n          if (args.timeStamp >= args.delay) {\n            element.style.visibility = 'visible';\n            if (!series.chart.requireInvertedAxis) {\n              elementHeight = elementHeight ? elementHeight : 1;\n              value = effect(args.timeStamp - args.delay, 0, elementHeight, args.duration);\n              element.setAttribute('transform', 'translate(' + centerX + ' ' + centerY + ') scale(1,' + value / elementHeight + ') translate(' + -centerX + ' ' + -centerY + ')');\n            } else {\n              elementWidth = elementWidth ? elementWidth : 1;\n              value = effect(args.timeStamp - args.delay, 0, elementWidth, args.duration);\n              element.setAttribute('transform', 'translate(' + centerX + ' ' + centerY + ') scale(' + value / elementWidth + ', 1) translate(' + -centerX + ' ' + -centerY + ')');\n            }\n          }\n        },\n        end: function () {\n          var annotations = document.getElementById(series.chart.element.id + '_Annotation_Collections');\n          if (annotations) {\n            annotations.style.visibility = 'visible';\n          }\n          var stackLabelGroup = document.getElementById(series.chart.element.id + '_StackLabelGroup');\n          if (stackLabelGroup) {\n            stackLabelGroup.setAttribute('visibility', 'visible');\n          }\n          element.setAttribute('transform', 'translate(0,0)');\n          var seriesElement = series.seriesElement;\n          if (element === seriesElement.lastElementChild || point.index === series.points.length - 1 || series.type === 'Waterfall' && element === seriesElement.children[seriesElement.childElementCount - 2]) {\n            series.chart.trigger('animationComplete', {\n              series: series.chart.isBlazor ? {} : series\n            });\n            if (series.type === 'Waterfall') {\n              var rectElements = seriesElement.childNodes;\n              for (var i = 0; i < rectElements.length; i++) {\n                if (rectElements[i].id.indexOf('Connector') !== -1) {\n                  rectElements[i].style.visibility = 'visible';\n                  rectElements[i].setAttribute('transform', 'translate(0,0)');\n                }\n              }\n            }\n          }\n        }\n      });\n    }\n  };\n  /**\n   * Calculates the path for a rounded rectangle.\n   *\n   * @param {Rect} rect - The bounding rectangle.\n   * @param {number} topLeft - The radius of the top-left corner.\n   * @param {number} topRight - The radius of the top-right corner.\n   * @param {number} bottomLeft - The radius of the bottom-left corner.\n   * @param {number} bottomRight - The radius of the bottom-right corner.\n   * @param {boolean} inverted - Indicates whether the rectangle is inverted.\n   * @returns {string} The SVG path string representing the rounded rectangle.\n   */\n  ColumnBase.prototype.calculateRoundedRectPath = function (rect, topLeft, topRight, bottomLeft, bottomRight, inverted) {\n    if (inverted === void 0) {\n      inverted = false;\n    }\n    var halfValue = inverted ? rect.width / 2 : rect.height / 2;\n    topLeft = Math.min(topLeft, halfValue);\n    topRight = Math.min(topRight, halfValue);\n    bottomLeft = Math.min(bottomLeft, halfValue);\n    bottomRight = Math.min(bottomRight, halfValue);\n    return 'M' + ' ' + rect.x + ' ' + (topLeft + rect.y) + ' Q ' + rect.x + ' ' + rect.y + ' ' + (rect.x + topLeft) + ' ' + rect.y + ' ' + 'L' + ' ' + (rect.x + rect.width - topRight) + ' ' + rect.y + ' Q ' + (rect.x + rect.width) + ' ' + rect.y + ' ' + (rect.x + rect.width) + ' ' + (rect.y + topRight) + ' ' + 'L ' + (rect.x + rect.width) + ' ' + (rect.y + rect.height - bottomRight) + ' Q ' + (rect.x + rect.width) + ' ' + (rect.y + rect.height) + ' ' + (rect.x + rect.width - bottomRight) + ' ' + (rect.y + rect.height) + ' ' + 'L ' + (rect.x + bottomLeft) + ' ' + (rect.y + rect.height) + ' Q ' + rect.x + ' ' + (rect.y + rect.height) + ' ' + rect.x + ' ' + (rect.y + rect.height - bottomLeft) + ' ' + 'L' + ' ' + rect.x + ' ' + (topLeft + rect.y) + ' ' + 'Z';\n  };\n  return ColumnBase;\n}();\nexport { ColumnBase };","map":{"version":3,"names":["Animation","animationMode","isNullOrUndefined","remove","DoubleRange","appendChildElement","redrawElement","pathAnimation","valueToCoefficient","getVisiblePoints","colorNameToHex","checkColorFormat","applyZLight","getAnimationFunction","getPoint","getMinPointsDelta","PathOption","Rect","pointRender","ColumnBase","prototype","getSideBySideInfo","series","isRectSeries","chart","enableSideBySidePlacement","position","columnWidthInPixel","getSideBySidePositions","type","rectCount","visibleSeries","seriesSpacing","columnSpacing","pointSpacing","columnWidth","isNaN","Math","min","minimumPointDelta","xAxis","width","radius","location","doubleRange","start","end","groupName","indexOf","mainColumnWidth_1","filter","mainWidth","mainDoubleRange","difference","delta","getRectangle","x1","y1","x2","y2","point1","yAxis","requireInvertedAxis","point2","x","y","abs","drawCylinder","options","element","cylinderSeriesOption","rect","height","enableCanvas","ctx","canvasRender","canvasCtx","save","gradientColor","fill","clipRect","arc","PI","rx","ry","cx1","cx2","cy1","cy2","cx","cy","xl","yl","xPos","yPos","step","rxt","ryt","gx1","gx2","gy1","gy2","ini","fillStyle","lineWidth","strokeStyle","globalAlpha","opacity","isColumn","stacking","isLastSeries","color","gradient","createLinearGradient","addColorStop","j","i","beginPath","cos","sin","moveTo","lineTo","stroke","id","clip","restore","fillColor","format","AEx","AEy","LX","LY","GX","GY","X","Y","X1","Y1","X2","Y2","d","toString","renderer","drawPath","Int32Array","seriesElement","redraw","optiong","document","getElementById","gradientElement","colorStop","drawGradient","defElement","createDefs","xmlns","linearGradientElement","createElementNS","setAttribute","length","stopElement","appendChild","_i","_a","columns","columnItem","_b","_c","rows","item","findRectPosition","findSeriesCollection","seriesCollection","groupingValues","vSeries","value","stackingGroup","undefined","updateSymbolLocation","point","updateXRegion","updateYRegion","minimum","histogramValues","binWidth","maximum","symbolLocations","push","seriesType","yValue","isAxisInverse","getRegion","renderMarker","marker","visible","markerRender","render","markerWidth","markerHeight","regions","triggerEvent","border","argsData","cancel","name","setPointColor","setBorderColor","cornerRadius","trigger","drawRectangle","check","direction","calculateRoundedRectPath","topLeft","topRight","bottomLeft","bottomRight","isNegative","category","index","removedPointIndex","previousElement","previousDirection","getAttribute","dashArray","columnFacet","accessibility","accessibilityDescriptionFormat","formatAccessibilityDescription","high","low","enableAnimation","querySelector","duration","animate","rectElements","childNodes","count","visiblePoints","visiblePoints_1","animateRect","option","animation","animated","effect","isPlot","elementHeight","elementWidth","centerX","centerY","style","visibility","delay","progress","args","timeStamp","annotations","stackLabelGroup","lastElementChild","points","children","childElementCount","isBlazor","inverted","halfValue"],"sources":["C:/Users/mkfun/Desktop/ct assignment/admin/node_modules/@syncfusion/ej2-charts/src/chart/series/column-base.js"],"sourcesContent":["import { Animation, animationMode, isNullOrUndefined, remove } from '@syncfusion/ej2-base';\nimport { DoubleRange } from '../utils/double-range';\nimport { appendChildElement, redrawElement, pathAnimation, valueToCoefficient, getVisiblePoints, colorNameToHex, checkColorFormat, applyZLight } from '../../common/utils/helper';\nimport { getAnimationFunction, getPoint, getMinPointsDelta } from '../../common/utils/helper';\nimport { PathOption, Rect } from '@syncfusion/ej2-svg-base';\nimport { pointRender } from '../../common/model/constants';\n/**\n * Base class for column series.\n * This class provides common properties and methods for column series in the chart.\n *\n * @private\n */\nvar ColumnBase = /** @class */ (function () {\n    function ColumnBase() {\n    }\n    ColumnBase.prototype.getSideBySideInfo = function (series) {\n        series.isRectSeries = true;\n        if ((series.chart.enableSideBySidePlacement && !series.position) || !isNullOrUndefined(series.columnWidthInPixel)) {\n            this.getSideBySidePositions(series);\n        }\n        if (series.columnWidthInPixel) {\n            return new DoubleRange(0, 0);\n        }\n        var position = series.type === 'Histogram' || !series.chart.enableSideBySidePlacement ? 0 : series.position;\n        var rectCount = series.type === 'Histogram' || !series.chart.enableSideBySidePlacement ? 1 : series.rectCount;\n        var visibleSeries = series.chart.visibleSeries;\n        var seriesSpacing = series.chart.enableSideBySidePlacement ? series.columnSpacing : 0; // Column Spacing\n        var pointSpacing = (series.columnWidth === null || isNaN(+series.columnWidth)) ? ((series.type === 'Histogram') ? 1 : 0.7) :\n            Math.min(series.columnWidth, 1); // Column width\n        var minimumPointDelta = getMinPointsDelta(series.xAxis, visibleSeries);\n        var width = minimumPointDelta * pointSpacing;\n        var radius;\n        var location = (position) / rectCount - 0.5;\n        var doubleRange = new DoubleRange(location, location + (1 / rectCount));\n        if (!(isNaN(doubleRange.start) || isNaN(doubleRange.end))) {\n            if (series.groupName && series.type.indexOf('Stacking') === -1) {\n                var mainColumnWidth_1 = 0.7;\n                series.chart.series.filter(function (series) {\n                    if (series.columnWidth > mainColumnWidth_1) {\n                        mainColumnWidth_1 = series.columnWidth;\n                    }\n                });\n                var mainWidth = minimumPointDelta * mainColumnWidth_1;\n                var mainDoubleRange = new DoubleRange(doubleRange.start * mainWidth, doubleRange.end * mainWidth);\n                var difference = ((mainDoubleRange.delta) - (doubleRange.end * width - doubleRange.start * width)) / 2;\n                doubleRange = new DoubleRange(mainDoubleRange.start + difference, mainDoubleRange.end - difference);\n            }\n            else {\n                doubleRange = new DoubleRange(doubleRange.start * width, doubleRange.end * width);\n            }\n            radius = seriesSpacing * doubleRange.delta;\n            doubleRange = new DoubleRange(doubleRange.start + radius / 2, doubleRange.end - radius / 2);\n        }\n        return doubleRange;\n    };\n    /**\n     * Gets the rectangle bounds based on two points.\n     *\n     * @param {number} x1 - The x-coordinate of the first point.\n     * @param {number} y1 - The y-coordinate of the first point.\n     * @param {number} x2 - The x-coordinate of the second point.\n     * @param {number} y2 - The y-coordinate of the second point.\n     * @param {Series} series - The series associated with the rectangle.\n     * @returns {Rect} - The rectangle bounds.\n     */\n    ColumnBase.prototype.getRectangle = function (x1, y1, x2, y2, series) {\n        var point1 = getPoint(x1, y1, series.xAxis, series.yAxis, series.chart.requireInvertedAxis);\n        var point2 = getPoint(x2, y2, series.xAxis, series.yAxis, series.chart.requireInvertedAxis);\n        return new Rect(Math.min(point1.x, point2.x), Math.min(point1.y, point2.y), Math.abs(point2.x - point1.x), Math.abs(point2.y - point1.y));\n    };\n    /**\n     * Draws a cylinder using the provided options and element.\n     *\n     * @param {PathOption} options - The path options for drawing the cylinder.\n     * @param {HTMLElement} element - The HTML element to which the cylinder is drawn.\n     * @param {CylinderSeriesOption} cylinderSeriesOption - The options specific to the cylinder series.\n     * @param {Rect} rect - The rectangle bounds within which the cylinder is drawn.\n     * @param {Series} series - The series associated with the cylinder.\n     * @returns {void}\n     */\n    ColumnBase.prototype.drawCylinder = function (options, element, cylinderSeriesOption, rect, series) {\n        var width = rect.width;\n        var height = rect.height;\n        if (series.chart.enableCanvas) {\n            var ctx = series.chart.canvasRender.ctx;\n            var canvasCtx = ctx;\n            ctx.save();\n            var gradientColor = colorNameToHex(options.fill);\n            var x = rect.x + series.clipRect.x;\n            var y = rect.y + series.clipRect.y;\n            var arc = 2 * Math.PI + 0.1;\n            var rx = void 0;\n            var ry = void 0;\n            var cx1 = void 0;\n            var cx2 = void 0;\n            var cy1 = void 0;\n            var cy2 = void 0;\n            var x1 = void 0;\n            var x2 = void 0;\n            var y1 = void 0;\n            var y2 = void 0;\n            var cx = void 0;\n            var cy = void 0;\n            var xl = void 0;\n            var yl = void 0;\n            var xPos = void 0;\n            var yPos = void 0;\n            var step = void 0;\n            var rxt = void 0;\n            var ryt = void 0;\n            var gx1 = 0;\n            var gx2 = 0;\n            var gy1 = 0;\n            var gy2 = 0;\n            var ini = 0;\n            ctx.fillStyle = applyZLight(gradientColor, 0.9);\n            ctx.lineWidth = 0;\n            ctx.strokeStyle = applyZLight(gradientColor, 0.9);\n            ctx.globalAlpha = options.opacity;\n            if (cylinderSeriesOption.isColumn) {\n                gx1 = x;\n                gx2 = width + x;\n                rx = width / 2;\n                ry = rx / 4;\n                cx2 = cx1 = x + rx;\n                y2 = cy1 = y - ry;\n                x2 = x;\n                x1 = x + width;\n                cy2 = y1 = y + height - ry;\n                step = Math.PI;\n                rxt = -rx;\n                ryt = ry;\n                if (cylinderSeriesOption.stacking) {\n                    if (!cylinderSeriesOption.isLastSeries) {\n                        y2 = cy1 = y + ry;\n                    }\n                }\n            }\n            else {\n                gy2 = height + y;\n                gy1 = y;\n                ry = height / 2;\n                rx = ry / 4;\n                x2 = cx1 = x + rx;\n                x1 = cx2 = x + width + rx;\n                y1 = y + height;\n                y2 = y;\n                cy2 = cy1 = y + ry;\n                ini = Math.PI / 2;\n                step = Math.PI * 1.5;\n                if (cylinderSeriesOption.stacking) {\n                    if (!cylinderSeriesOption.isLastSeries) {\n                        x1 = cx2 = x + width - rx;\n                    }\n                }\n                ry = -ry;\n                rx = -rx;\n                rxt = rx;\n                ryt = -ry;\n            }\n            var color = applyZLight(gradientColor, 0.7);\n            var gradient = ctx.createLinearGradient(gx1, gy1, gx2, gy2);\n            gradient.addColorStop(0, gradientColor);\n            gradient.addColorStop(0.3, color);\n            gradient.addColorStop(0.7, color);\n            gradient.addColorStop(1, gradientColor);\n            for (var j = 1; j <= 4; j++) {\n                var i = 0;\n                if (j < 4) {\n                    ctx.beginPath();\n                }\n                if (j % 2 === 0) {\n                    cx = cx2;\n                    cy = cy2;\n                    xl = x2;\n                    yl = y2;\n                }\n                else {\n                    cx = cx1;\n                    cy = cy1;\n                    xl = x1;\n                    yl = y1;\n                }\n                if (j === 4) {\n                    rx = rxt;\n                    ry = ryt;\n                    ctx.fillStyle = gradient;\n                }\n                if (j > 2) {\n                    i = ini;\n                    arc = step;\n                }\n                for (; i <= arc; i += 0.1) {\n                    xPos = cx - (rx * Math.cos(i));\n                    yPos = cy + (ry * Math.sin(i));\n                    if (i === 0) {\n                        ctx.moveTo(xPos, yPos);\n                    }\n                    else {\n                        ctx.lineTo(xPos, yPos);\n                    }\n                }\n                if (j > 2) {\n                    ctx.lineTo(xl, yl);\n                }\n                if (j !== 3) {\n                    ctx.stroke();\n                    ctx.fill();\n                }\n            }\n            if (options.id.indexOf('Series') >= 0) {\n                ctx.clip();\n                ctx.restore();\n                ctx = canvasCtx;\n            }\n        }\n        else {\n            var chart = series.chart;\n            var x = rect.x;\n            var y = rect.y;\n            var id = options.id;\n            var gradientColor = options.fill;\n            var fillColor = gradientColor;\n            var format = checkColorFormat(gradientColor);\n            if (!format) {\n                gradientColor = colorNameToHex(gradientColor);\n            }\n            var AEx = 0;\n            var AEy = 0;\n            var LX = 0;\n            var LY = 0;\n            var GX = 0;\n            var GY = 0;\n            var X = void 0;\n            var Y = void 0;\n            var X1 = void 0;\n            var Y1 = void 0;\n            var X2 = void 0;\n            var Y2 = void 0;\n            var rx = void 0;\n            var ry = void 0;\n            var i = 2;\n            if (cylinderSeriesOption.isColumn) {\n                rx = width / 2;\n                ry = rx / 4;\n                X = X1 = x;\n                Y = ry < y ? y - ry : cylinderSeriesOption.stacking ? y + ry : (y - ry);\n                Y1 = Y;\n                AEx = 2 * rx;\n                LY = ry < y ? height : (height < 2 * ry ? height : cylinderSeriesOption.stacking ? height - (2 * ry) : height);\n                X2 = X;\n                Y2 = ry < y ? Y + height : (height < Y ? height + Y : cylinderSeriesOption.stacking ? height + (y - ry) : height + Y);\n                GX = 100;\n                if (cylinderSeriesOption.stacking) {\n                    if (!cylinderSeriesOption.isLastSeries) {\n                        Y = Y1 = y + ry;\n                        LY = height < rx / 2 ? height : height - rx / 2;\n                    }\n                }\n            }\n            else {\n                ry = height / 2;\n                rx = ry / 4;\n                Y = Y1 = y;\n                X = X1 = Math.abs(x - rx);\n                AEy = 2 * ry;\n                LX = width;\n                X2 = X + width;\n                Y2 = Y;\n                GY = 100;\n                if (cylinderSeriesOption.stacking) {\n                    if (!cylinderSeriesOption.isLastSeries) {\n                        X2 = (X + width - rx * 2);\n                        LX = width - rx * 2;\n                    }\n                }\n            }\n            remove(this.element);\n            while (i--) {\n                options.d = 'M' + X.toString() + ',' + Y.toString() + 'a' + rx.toString() + ',' + ry.toString() + ' 0 1,0 ' + AEx.toString() + ',' + AEy.toString() + 'a' + rx.toString() + ',' + ry.toString() + ' 0 1,0 ' + (-1 * AEx).toString() + ',' + (-1 * AEy).toString();\n                options.id = id + '_' + 'Region_' + i;\n                options.fill = applyZLight(gradientColor, 0.9);\n                if (i % 2 === 0 && series.type !== 'StackingBar100' && series.type !== 'StackingBar' && series.type !== 'Bar') {\n                    options.fill = options.fill + '10';\n                }\n                this.element = chart.renderer.drawPath(this.options, new Int32Array([series.clipRect.x, series.clipRect.y]));\n                appendChildElement(series.chart.enableCanvas, series.seriesElement, this.element, chart.redraw);\n                X = X2;\n                Y = Y2;\n            }\n            options.d = 'M' + X1.toString() + ',' + Y1.toString() + 'a' + rx.toString() + ',' + ry.toString() + ' 0 1,0 ' + AEx.toString() + ',' + AEy.toString() + 'l' + LX.toString() + ' ' + LY.toString() + 'a' + rx.toString() + ',' + ry.toString() + ' 0 1,1 ' + (-1 * AEx).toString() + ',' + (-1 * AEy).toString() + ' z';\n            options.id = id + '_' + 'Region_2';\n            options.fill = applyZLight(gradientColor, 0.7);\n            var optiong = void 0;\n            if (fillColor.indexOf('url') === -1) {\n                if (!document.getElementById(id)) {\n                    optiong = { 'id': id, x1: '0%', y1: '0%', x2: GX.toString() + '%', y2: GY.toString() + '%' };\n                    var gradientElement = [{ colorStop: '0%', color: gradientColor }, { colorStop: '30%', color: applyZLight(gradientColor, 0.7) }, { colorStop: '70%', color: applyZLight(gradientColor, 0.7) }, { colorStop: '100%', color: gradientColor }];\n                    this.drawGradient(optiong, gradientElement, series);\n                }\n                options.fill = 'url(#' + optiong.id + ')';\n            }\n            this.element = chart.renderer.drawPath(this.options, new Int32Array([series.clipRect.x, series.clipRect.y]));\n            appendChildElement(series.chart.enableCanvas, series.seriesElement, this.element, chart.redraw);\n        }\n    };\n    /**\n     * Draws a gradient using the provided options and gradient element.\n     *\n     * @param {OptionGradient} optiong - The gradient options for drawing the gradient.\n     * @param {Object} gradientElement - The gradient element to which the gradient is applied.\n     * @param {Series} series - The series associated with the gradient.\n     * @returns {void}\n     */\n    ColumnBase.prototype.drawGradient = function (optiong, gradientElement, series) {\n        var chart = series.chart;\n        var defElement = chart.renderer.createDefs();\n        var xmlns = 'http://www.w3.org/2000/svg';\n        var linearGradientElement = document.createElementNS(xmlns, 'linearGradient');\n        linearGradientElement.setAttribute('id', optiong.id);\n        linearGradientElement.setAttribute('x1', optiong.x1);\n        linearGradientElement.setAttribute('y1', optiong.y1);\n        linearGradientElement.setAttribute('x2', optiong.x2);\n        linearGradientElement.setAttribute('y2', optiong.y2);\n        for (var i = 0; i < gradientElement.length; i++) {\n            var stopElement = document.createElementNS(xmlns, 'stop');\n            stopElement.setAttribute('offset', gradientElement[i].colorStop);\n            stopElement.setAttribute('stop-color', gradientElement[i].color);\n            stopElement.setAttribute('stop-opacity', '1');\n            linearGradientElement.appendChild(stopElement);\n        }\n        series.seriesElement.appendChild(defElement);\n        defElement.appendChild(linearGradientElement);\n    };\n    /**\n     * To get the position of each series.\n     *\n     * @param {Series} series - The series for which side-by-side positions are calculated.\n     * @returns {void}\n     * @private\n     */\n    ColumnBase.prototype.getSideBySidePositions = function (series) {\n        var chart = series.chart;\n        for (var _i = 0, _a = chart.columns; _i < _a.length; _i++) {\n            var columnItem = _a[_i];\n            for (var _b = 0, _c = chart.rows; _b < _c.length; _b++) {\n                var item = _c[_b];\n                this.findRectPosition(series.findSeriesCollection(columnItem, item, false));\n            }\n        }\n    };\n    ColumnBase.prototype.findRectPosition = function (seriesCollection) {\n        var groupingValues = [];\n        var vSeries = { rectCount: 0, position: null };\n        for (var i = 0; i < seriesCollection.length; i++) {\n            var value = seriesCollection[i];\n            if (value.type.indexOf('Stacking') !== -1 || value.groupName !== '') {\n                var groupName = value.type.indexOf('Stacking') !== -1 ? value.stackingGroup : value.type + value.groupName;\n                if (groupName) {\n                    if (groupingValues[groupName] === undefined) {\n                        value.position = vSeries.rectCount;\n                        groupingValues[groupName] = vSeries.rectCount++;\n                    }\n                    else {\n                        value.position = groupingValues[groupName];\n                    }\n                }\n                else {\n                    if (vSeries.position === null) {\n                        value.position = vSeries.rectCount;\n                        vSeries.position = vSeries.rectCount++;\n                    }\n                    else {\n                        value.position = vSeries.position;\n                    }\n                }\n            }\n            else {\n                value.position = vSeries.rectCount++;\n            }\n        }\n        for (var i = 0; i < seriesCollection.length; i++) {\n            var value = seriesCollection[i];\n            value.rectCount = vSeries.rectCount;\n        }\n    };\n    /**\n     * Updates the location of the symbol based on the point and rect coordinates.\n     *\n     * @param {Points} point - The point for which the symbol location is updated.\n     * @param {Rect} rect - The rect representing the symbol location.\n     * @param {Series} series - The series to which the point belongs.\n     * @returns {void}\n     */\n    ColumnBase.prototype.updateSymbolLocation = function (point, rect, series) {\n        if (!series.chart.requireInvertedAxis) {\n            this.updateXRegion(point, rect, series);\n        }\n        else {\n            this.updateYRegion(point, rect, series);\n        }\n        if (series.type === 'Histogram') {\n            point.minimum = +point.x - series.histogramValues.binWidth / 2;\n            point.maximum = +point.x + series.histogramValues.binWidth / 2;\n        }\n    };\n    /**\n     * Updates the x-region of the symbol based on the point and rect coordinates.\n     *\n     * @param {Points} point - The point for which the x-region is updated.\n     * @param {Rect} rect - The rect representing the x-region.\n     * @param {Series} series - The series to which the point belongs.\n     * @returns {void}\n     */\n    ColumnBase.prototype.updateXRegion = function (point, rect, series) {\n        point.symbolLocations.push({\n            x: rect.x + (rect.width) / 2,\n            y: (series.seriesType === 'BoxPlot' || series.seriesType.indexOf('HighLow') !== -1 ||\n                (point.yValue >= 0 === !series.yAxis.isAxisInverse)) ? rect.y : (rect.y + rect.height)\n        });\n        this.getRegion(point, rect, series);\n        if (series.type === 'RangeColumn') {\n            point.symbolLocations.push({\n                x: rect.x + (rect.width) / 2,\n                y: rect.y + rect.height\n            });\n        }\n    };\n    /**\n     * Updates the y-region of the symbol based on the point and rect coordinates.\n     *\n     * @param {Points} point - The point for which the y-region is updated.\n     * @param {Rect} rect - The rect representing the y-region.\n     * @param {Series} series - The series to which the point belongs.\n     * @returns {void}\n     */\n    ColumnBase.prototype.updateYRegion = function (point, rect, series) {\n        point.symbolLocations.push({\n            x: (series.seriesType === 'BoxPlot' || series.seriesType.indexOf('HighLow') !== -1 ||\n                (point.yValue >= 0 === !series.yAxis.isAxisInverse)) ? rect.x + rect.width : rect.x,\n            y: rect.y + rect.height / 2\n        });\n        this.getRegion(point, rect, series);\n        if (series.type === 'RangeColumn') {\n            point.symbolLocations.push({\n                x: rect.x,\n                y: rect.y + rect.height / 2\n            });\n        }\n    };\n    /**\n     * To render the marker for the series.\n     *\n     * @param {Series} series - The series for which markers are rendered.\n     * @returns {void}\n     * @private\n     */\n    ColumnBase.prototype.renderMarker = function (series) {\n        if (series.marker && series.marker.visible) {\n            series.chart.markerRender.render(series);\n        }\n    };\n    /**\n     * To get the marker region when Y value is 0\n     *\n     * @param {Points} point point\n     * @param {rect} rect rect\n     * @param {Series} series series\n     * @returns {void}\n     */\n    ColumnBase.prototype.getRegion = function (point, rect, series) {\n        if (point.y === 0) {\n            var markerWidth = (series.marker && series.marker.width) ? series.marker.width : 0;\n            var markerHeight = (series.marker && series.marker.height) ? series.marker.height : 0;\n            point.regions.push(new Rect(point.symbolLocations[0].x - markerWidth, point.symbolLocations[0].y - markerHeight, 2 * markerWidth, 2 * markerHeight));\n        }\n        else {\n            point.regions.push(rect);\n        }\n    };\n    /**\n     * Triggers the point render event.\n     *\n     * @param {Series} series - The series associated with the point.\n     * @param {Points} point - The data point for which the event is triggered.\n     * @param {string} fill - The fill color of the point.\n     * @param {BorderModel} border - The border settings of the point.\n     * @returns {IPointRenderEventArgs} - The event arguments.\n     */\n    ColumnBase.prototype.triggerEvent = function (series, point, fill, border) {\n        var argsData = {\n            cancel: false, name: pointRender, series: series, point: point,\n            fill: series.setPointColor(point, fill),\n            border: series.setBorderColor(point, border),\n            cornerRadius: series.cornerRadius\n        };\n        series.chart.trigger(pointRender, argsData);\n        point.color = argsData.fill;\n        return argsData;\n    };\n    /**\n     * Draws a rectangle for the data point.\n     *\n     * @param {Series} series - The series associated with the point.\n     * @param {Points} point - The data point for which the rectangle is drawn.\n     * @param {Rect} rect - The rect bounds.\n     * @param {IPointRenderEventArgs} argsData - The event arguments.\n     * @returns {void}\n     */\n    ColumnBase.prototype.drawRectangle = function (series, point, rect, argsData) {\n        var chart = series.chart;\n        var check = chart.requireInvertedAxis ? rect.height : rect.width;\n        if (check <= 0) {\n            return null;\n        }\n        var direction;\n        if (point.y === 0) {\n            // For 0 values corner radius will not calculate\n            direction = this.calculateRoundedRectPath(rect, 0, 0, 0, 0);\n        }\n        else {\n            var topLeft = void 0;\n            var topRight = void 0;\n            var bottomLeft = void 0;\n            var bottomRight = void 0;\n            var isNegative = point.y < 0;\n            if (chart.requireInvertedAxis) {\n                topLeft = isNegative ? argsData.cornerRadius.topRight : argsData.cornerRadius.topLeft;\n                topRight = isNegative ? argsData.cornerRadius.topLeft : argsData.cornerRadius.topRight;\n                bottomLeft = isNegative ? argsData.cornerRadius.bottomRight : argsData.cornerRadius.bottomLeft;\n                bottomRight = isNegative ? argsData.cornerRadius.bottomLeft : argsData.cornerRadius.bottomRight;\n            }\n            else {\n                topLeft = isNegative ? argsData.cornerRadius.bottomLeft : argsData.cornerRadius.topLeft;\n                topRight = isNegative ? argsData.cornerRadius.bottomRight : argsData.cornerRadius.topRight;\n                bottomLeft = isNegative ? argsData.cornerRadius.topLeft : argsData.cornerRadius.bottomLeft;\n                bottomRight = isNegative ? argsData.cornerRadius.topRight : argsData.cornerRadius.bottomRight;\n            }\n            direction = this.calculateRoundedRectPath(rect, topLeft, topRight, bottomLeft, bottomRight, chart.requireInvertedAxis);\n        }\n        var name = series.category === 'Indicator' ? chart.element.id + '_Indicator_' + series.index + '_' + series.name +\n            '_Point_' + point.index : chart.element.id + '_Series_' + series.index + '_Point_' + ((series.removedPointIndex !== null && series.removedPointIndex <= point.index) ? (point.index + 1) : point.index);\n        var previousElement = redrawElement(chart.redraw, name);\n        var previousDirection = previousElement ? previousElement.getAttribute('d') : '';\n        this.options = new PathOption(name, argsData.fill, argsData.border.width, argsData.border.color, series.opacity, series.border.dashArray, (series.columnFacet === 'Cylinder') ? '' : direction);\n        this.element = chart.renderer.drawPath(this.options, new Int32Array([series.clipRect.x, series.clipRect.y]));\n        if (series.removedPointIndex !== null && series.removedPointIndex <= point.index) {\n            this.element.id = chart.element.id + '_Series_' + series.index + '_Point_' + point.index;\n        }\n        switch (series.seriesType) {\n            case 'XY':\n                this.element.setAttribute('role', 'img');\n                this.element.setAttribute('aria-label', series.accessibility.accessibilityDescriptionFormat ? series.formatAccessibilityDescription(point, series) : (point.x + ':' + point.yValue + ', ' + series.name));\n                break;\n            case 'HighLow':\n                this.element.setAttribute('role', 'img');\n                this.element.setAttribute('aria-label', series.accessibility.accessibilityDescriptionFormat ? series.formatAccessibilityDescription(point, series) : (point.x + ':' + point.high + ', ' + point.low + ', ' + series.name));\n                break;\n        }\n        if (!(series.columnFacet === 'Cylinder' && (chart.redraw || !chart.enableAnimation) && series.seriesElement.querySelector('#' + this.element.id))) {\n            appendChildElement(series.chart.enableCanvas, series.seriesElement, this.element, chart.redraw);\n        }\n        if (!series.chart.enableCanvas) {\n            pathAnimation(this.element, (series.columnFacet === 'Cylinder') ? '' : direction, chart.redraw, previousDirection, chart.duration);\n        }\n    };\n    /**\n     * To animate the series.\n     *\n     * @param {Series} series - The series to be animated.\n     * @returns {void}\n     * @private\n     */\n    ColumnBase.prototype.animate = function (series) {\n        var rectElements = series.seriesElement.childNodes;\n        var count = series.category === 'Indicator' ? 0 : 1;\n        var visiblePoints = getVisiblePoints(series);\n        for (var _i = 0, visiblePoints_1 = visiblePoints; _i < visiblePoints_1.length; _i++) {\n            var point = visiblePoints_1[_i];\n            if (!point.symbolLocations.length && !(series.type === 'BoxAndWhisker' && point.regions.length)) {\n                continue;\n            }\n            if ((series.type === 'Column' || series.type === 'Bar' || series.type === 'StackingColumn' || series.type === 'StackingColumn100' || series.type === 'StackingBar' || series.type === 'StackingBar100') && series.columnFacet === 'Cylinder') {\n                for (var j = 0; j < rectElements.length; j++) {\n                    this.animateRect(rectElements[j], series, point);\n                }\n            }\n            else {\n                this.animateRect(rectElements[count], series, point);\n                count++;\n            }\n        }\n    };\n    /**\n     * Animates the rect element.\n     *\n     * @param {HTMLElement} element - The rect element to be animated.\n     * @param {Series} series - The series associated with the rect.\n     * @param {Points} point - The data point associated with the rect.\n     * @returns {void}\n     */\n    ColumnBase.prototype.animateRect = function (element, series, point) {\n        var option = series.animation;\n        var duration = series.chart.animated ? series.chart.duration : option.duration;\n        var effect = getAnimationFunction('Linear');\n        var isPlot = point.yValue < 0;\n        var x;\n        var y;\n        var elementHeight = +point.regions[0].height;\n        var elementWidth = +point.regions[0].width;\n        var centerX;\n        var centerY;\n        if (!series.chart.requireInvertedAxis) {\n            x = +point.regions[0].x;\n            if (series.type.indexOf('Stacking') > -1) {\n                y = (1 - valueToCoefficient(0, series.yAxis)) * (series.yAxis.rect.height);\n                centerX = x;\n                centerY = y;\n            }\n            else {\n                y = +point.regions[0].y;\n                centerY = (series.seriesType.indexOf('HighLow') !== -1 || series.type.indexOf('Waterfall') !== -1) ? y + elementHeight / 2 :\n                    (isPlot !== series.yAxis.isAxisInverse) ? y : y + elementHeight;\n                centerX = isPlot ? x : x + elementWidth;\n            }\n        }\n        else {\n            y = +point.regions[0].y;\n            if (series.type.indexOf('Stacking') > -1) {\n                x = (valueToCoefficient(0, series.yAxis)) * series.yAxis.rect.width;\n                centerX = x;\n                centerY = y;\n            }\n            else {\n                x = +point.regions[0].x;\n                centerY = isPlot ? y : y + elementHeight;\n                centerX = (series.seriesType.indexOf('HighLow') !== -1 || series.type.indexOf('Waterfall') !== -1) ? x + elementWidth / 2 :\n                    (isPlot !== series.yAxis.isAxisInverse) ? x + elementWidth : x;\n            }\n        }\n        var value;\n        if (!isNullOrUndefined(element)) {\n            element.style.visibility = 'hidden';\n            new Animation({}).animate(element, {\n                duration: (duration === 0 && animationMode === 'Enable') ? 1000 : duration,\n                delay: option.delay,\n                progress: function (args) {\n                    if (args.timeStamp >= args.delay) {\n                        element.style.visibility = 'visible';\n                        if (!series.chart.requireInvertedAxis) {\n                            elementHeight = elementHeight ? elementHeight : 1;\n                            value = effect(args.timeStamp - args.delay, 0, elementHeight, args.duration);\n                            element.setAttribute('transform', 'translate(' + centerX + ' ' + centerY +\n                                ') scale(1,' + (value / elementHeight) + ') translate(' + (-centerX) + ' ' + (-centerY) + ')');\n                        }\n                        else {\n                            elementWidth = elementWidth ? elementWidth : 1;\n                            value = effect(args.timeStamp - args.delay, 0, elementWidth, args.duration);\n                            element.setAttribute('transform', 'translate(' + centerX + ' ' + centerY +\n                                ') scale(' + (value / elementWidth) + ', 1) translate(' + (-centerX) + ' ' + (-centerY) + ')');\n                        }\n                    }\n                },\n                end: function () {\n                    var annotations = document.getElementById(series.chart.element.id + '_Annotation_Collections');\n                    if (annotations) {\n                        annotations.style.visibility = 'visible';\n                    }\n                    var stackLabelGroup = document.getElementById(series.chart.element.id + '_StackLabelGroup');\n                    if (stackLabelGroup) {\n                        stackLabelGroup.setAttribute('visibility', 'visible');\n                    }\n                    element.setAttribute('transform', 'translate(0,0)');\n                    var seriesElement = series.seriesElement;\n                    if (element === seriesElement.lastElementChild || point.index === series.points.length - 1 ||\n                        (series.type === 'Waterfall' && element === seriesElement.children[seriesElement.childElementCount - 2])) {\n                        series.chart.trigger('animationComplete', { series: series.chart.isBlazor ? {} : series });\n                        if (series.type === 'Waterfall') {\n                            var rectElements = seriesElement.childNodes;\n                            for (var i = 0; i < rectElements.length; i++) {\n                                if (rectElements[i].id.indexOf('Connector') !== -1) {\n                                    rectElements[i].style.visibility = 'visible';\n                                    rectElements[i].setAttribute('transform', 'translate(0,0)');\n                                }\n                            }\n                        }\n                    }\n                }\n            });\n        }\n    };\n    /**\n     * Calculates the path for a rounded rectangle.\n     *\n     * @param {Rect} rect - The bounding rectangle.\n     * @param {number} topLeft - The radius of the top-left corner.\n     * @param {number} topRight - The radius of the top-right corner.\n     * @param {number} bottomLeft - The radius of the bottom-left corner.\n     * @param {number} bottomRight - The radius of the bottom-right corner.\n     * @param {boolean} inverted - Indicates whether the rectangle is inverted.\n     * @returns {string} The SVG path string representing the rounded rectangle.\n     */\n    ColumnBase.prototype.calculateRoundedRectPath = function (rect, topLeft, topRight, bottomLeft, bottomRight, inverted) {\n        if (inverted === void 0) { inverted = false; }\n        var halfValue = inverted ? rect.width / 2 : rect.height / 2;\n        topLeft = Math.min(topLeft, halfValue);\n        topRight = Math.min(topRight, halfValue);\n        bottomLeft = Math.min(bottomLeft, halfValue);\n        bottomRight = Math.min(bottomRight, halfValue);\n        return 'M' + ' ' + rect.x + ' ' + (topLeft + rect.y) +\n            ' Q ' + rect.x + ' ' + rect.y + ' ' + (rect.x + topLeft) + ' ' +\n            rect.y + ' ' + 'L' + ' ' + (rect.x + rect.width - topRight) + ' ' + rect.y +\n            ' Q ' + (rect.x + rect.width) + ' ' + rect.y + ' ' +\n            (rect.x + rect.width) + ' ' + (rect.y + topRight) + ' ' + 'L ' +\n            (rect.x + rect.width) + ' ' + (rect.y + rect.height - bottomRight)\n            + ' Q ' + (rect.x + rect.width) + ' ' + (rect.y + rect.height) + ' ' + (rect.x + rect.width - bottomRight) + ' ' +\n            (rect.y + rect.height) + ' ' + 'L ' + (rect.x + bottomLeft) + ' ' + (rect.y + rect.height) + ' Q ' + rect.x + ' ' +\n            (rect.y + rect.height) + ' ' + rect.x + ' ' + (rect.y + rect.height - bottomLeft) + ' ' + 'L' + ' ' + rect.x + ' ' +\n            (topLeft + rect.y) + ' ' + 'Z';\n    };\n    return ColumnBase;\n}());\nexport { ColumnBase };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}