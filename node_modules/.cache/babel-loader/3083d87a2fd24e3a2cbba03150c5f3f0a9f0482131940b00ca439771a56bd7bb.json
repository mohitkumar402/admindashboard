{"ast":null,"code":"import { createElement, isNullOrUndefined, Animation } from '@syncfusion/ej2-base';\nimport { DataUtil } from '@syncfusion/ej2-data';\nimport { subtractThickness, valueToCoefficient, sum, redrawElement, isBreakLabel, ChartLocation, withInBounds, rotateTextSize, removeElement, calculateScrollbarOffset } from '../../common/utils/helper';\nimport { subArray, inside, appendChildElement, stringToNumber } from '../../common/utils/helper';\nimport { Thickness, logBase, createZoomingLabels, getElement } from '../../common/utils/helper';\nimport { Size, Rect, measureText, TextOption, PathOption } from '@syncfusion/ej2-svg-base';\nimport { textElement, textTrim, getRotatedRectangleCoordinates, isRotatedRectIntersect, isZoomSet } from '../../common/utils/helper';\n/**\n * Specifies the Cartesian Axis Layout.\n */\nvar axisPadding = 10;\nvar CartesianAxisLayoutPanel = /** @class */function () {\n  /** @private */\n  /**\n   * Constructor for creating the chart.\n   *\n   * @param {Chart} chartModule - Specifies the Chart model.\n   * @private */\n  function CartesianAxisLayoutPanel(chartModule) {\n    this.chart = chartModule;\n    this.padding = 5;\n  }\n  /**\n   * Measure the axis size.\n   *\n   * @returns {void}\n   * @private\n   */\n  CartesianAxisLayoutPanel.prototype.measureAxis = function (rect) {\n    var chart = this.chart;\n    var chartAreaWidth = chart.chartArea.width ? stringToNumber(chart.chartArea.width, chart.availableSize.width) : null;\n    this.crossAt(chart);\n    this.seriesClipRect = new Rect(rect.x, rect.y, rect.width, rect.height);\n    this.initialClipRect = rect;\n    this.leftSize = 0;\n    this.rightSize = 0;\n    this.topSize = 0;\n    this.bottomSize = 0;\n    //Measure Axis size with initial Rect\n    this.measureRowAxis(chart, this.initialClipRect);\n    this.initialClipRect = subtractThickness(this.initialClipRect, new Thickness(this.leftSize, this.rightSize, 0, 0));\n    this.measureColumnAxis(chart, this.initialClipRect);\n    this.initialClipRect = subtractThickness(this.initialClipRect, new Thickness(0, 0, this.topSize, this.bottomSize));\n    if (!this.chart.delayRedraw) {\n      this.calculateAxisSize(this.initialClipRect);\n    }\n    this.leftSize = 0;\n    this.rightSize = 0;\n    this.topSize = 0;\n    this.bottomSize = 0;\n    //Measure Axis size with series Rect\n    this.measureRowAxis(chart, this.initialClipRect);\n    this.seriesClipRect = subtractThickness(this.seriesClipRect, new Thickness(this.leftSize, this.rightSize, 0, 0));\n    this.measureColumnAxis(chart, this.initialClipRect);\n    this.seriesClipRect = subtractThickness(this.seriesClipRect, new Thickness(0, 0, this.topSize, this.bottomSize));\n    if (chartAreaWidth) {\n      this.calculateFixedChartArea(chart, chartAreaWidth);\n    }\n    if (!this.chart.delayRedraw) {\n      chart.refreshAxis();\n      this.calculateAxisSize(this.seriesClipRect);\n    }\n  };\n  CartesianAxisLayoutPanel.prototype.calculateFixedChartArea = function (chart, chartAreaWidth) {\n    this.seriesClipRect.width = chartAreaWidth;\n    this.seriesClipRect.x = chart.availableSize.width - chart.margin.right - chartAreaWidth - (chart.legendSettings.position === 'Right' ? chart.legendModule.legendBounds.width : 0);\n    for (var _i = 0, _a = chart.rows; _i < _a.length; _i++) {\n      var item = _a[_i];\n      this.seriesClipRect.x -= sum(item.farSizes);\n    }\n  };\n  CartesianAxisLayoutPanel.prototype.measureRowAxis = function (chart, rect) {\n    var row;\n    this.calculateRowSize(rect);\n    for (var _i = 0, _a = chart.rows; _i < _a.length; _i++) {\n      var item = _a[_i];\n      row = item;\n      row.nearSizes = [];\n      row.farSizes = [];\n      row.insideNearSizes = [];\n      row.insideFarSizes = [];\n      this.arrangeAxis(row);\n      this.measureDefinition(row, chart, new Size(chart.availableSize.width, row.computedHeight));\n      if (this.leftSize < sum(row.nearSizes)) {\n        this.leftSize = sum(row.nearSizes);\n      }\n      if (this.rightSize < sum(row.farSizes)) {\n        this.rightSize = sum(row.farSizes);\n      }\n    }\n  };\n  CartesianAxisLayoutPanel.prototype.measureColumnAxis = function (chart, rect) {\n    var column;\n    this.calculateColumnSize(rect);\n    for (var _i = 0, _a = chart.columns; _i < _a.length; _i++) {\n      var item = _a[_i];\n      column = item;\n      column.farSizes = [];\n      column.nearSizes = [];\n      column.insideNearSizes = [];\n      column.insideFarSizes = [];\n      this.arrangeAxis(column);\n      this.measureDefinition(column, chart, new Size(column.computedWidth, chart.availableSize.height));\n      if (this.bottomSize < sum(column.nearSizes)) {\n        this.bottomSize = sum(column.nearSizes);\n      }\n      if (this.topSize < sum(column.farSizes)) {\n        this.topSize = sum(column.farSizes);\n      }\n    }\n  };\n  /**\n   * Measure the column and row in chart.\n   *\n   * @returns {void}\n   * @private\n   */\n  CartesianAxisLayoutPanel.prototype.measureDefinition = function (definition, chart, size) {\n    var ele;\n    for (var _i = 0, _a = definition.axes; _i < _a.length; _i++) {\n      var axis = _a[_i];\n      ele = axis.scrollbarSettings.height;\n      axis.scrollBarHeight = chart.scrollBarModule && chart.zoomModule && chart.zoomSettings.enableScrollbar && axis.enableScrollbarOnZooming && chart.zoomModule.isZoomed && (axis.zoomFactor < 1 || axis.zoomPosition > 0) ? ele : 0;\n      axis.scrollBarHeight = chart.scrollBarModule && (chart.zoomModule && chart.zoomSettings.enableScrollbar && axis.enableScrollbarOnZooming && chart.zoomModule.isZoomed && (axis.zoomFactor < 1 || axis.zoomPosition > 0) || axis.scrollbarSettings.enable) ? ele : 0;\n      axis.getModule(chart);\n      axis.baseModule.calculateRangeAndInterval(size, axis);\n      definition.computeSize(axis, axis.scrollBarHeight, definition, chart);\n    }\n    if (definition.farSizes.length > 0) {\n      definition.farSizes[definition.farSizes.length - 1] -= axisPadding;\n    }\n    if (definition.nearSizes.length > 0) {\n      definition.nearSizes[definition.nearSizes.length - 1] -= axisPadding;\n    }\n  };\n  /**\n   * Measure the axis.\n   *\n   * @param {Rect} rect - The rect for measuring the axis.\n   * @returns {void}\n   * @private\n   */\n  CartesianAxisLayoutPanel.prototype.calculateAxisSize = function (rect) {\n    var chart = this.chart;\n    var row;\n    var column;\n    var definition;\n    var axis;\n    var nearCount = 0;\n    var farCount = 0;\n    var size = 0;\n    var x;\n    var y;\n    var axisOffset;\n    this.calculateRowSize(rect);\n    for (var i = 0, len = chart.rows.length; i < len; i++) {\n      row = chart.rows[i];\n      nearCount = 0;\n      farCount = 0;\n      for (var j = 0, len_1 = row.axes.length; j < len_1; j++) {\n        axis = row.axes[j];\n        axisOffset = axis.plotOffset;\n        if (axis.rect.height === 0) {\n          axis.rect.height = row.computedHeight;\n          size = 0;\n          for (var k = i + 1, len_2 = i + axis.span; k < len_2; k++) {\n            definition = chart.rows[k];\n            size += definition.computedHeight;\n          }\n          axis.rect.y = row.computedTop - size + (axis.plotOffsetTop ? axis.plotOffsetTop : axisOffset);\n          axis.rect.height = axis.rect.height + size - this.getAxisOffsetValue(axis.plotOffsetTop, axis.plotOffsetBottom, axis.plotOffset);\n          axis.rect.width = 0;\n        }\n        if (axis.isAxisOpposedPosition) {\n          if (axis.labelPosition === 'Inside' && axis.orientation === 'Vertical') {\n            if (farCount > 0) {\n              x = rect.x + rect.width + sum(subArray(row.farSizes, farCount)) + axis.maxLabelSize.width + axis.multiLevelLabelHeight + (axis.tickPosition === 'Inside' ? axis.majorTickLines.height : 0) + axis.labelPadding;\n            } else {\n              x = rect.x + rect.width - sum(subArray(row.insideFarSizes, farCount));\n            }\n          } else {\n            x = rect.x + rect.width + sum(subArray(row.farSizes, farCount));\n          }\n          axis.rect.x = axis.rect.x >= x ? axis.rect.x : x;\n          farCount++;\n        } else {\n          if (axis.labelPosition === 'Inside' && axis.orientation === 'Vertical') {\n            if (nearCount > 0) {\n              x = rect.x - sum(subArray(row.nearSizes, nearCount)) - axis.maxLabelSize.width - axis.multiLevelLabelHeight - (axis.tickPosition === 'Inside' ? axis.majorTickLines.height : 0) - axis.labelPadding;\n            } else {\n              x = rect.x + sum(subArray(row.insideNearSizes, nearCount));\n            }\n          } else {\n            x = rect.x - sum(subArray(row.nearSizes, nearCount));\n          }\n          axis.rect.x = axis.rect.x <= x ? axis.rect.x : x;\n          nearCount++;\n        }\n      }\n    }\n    this.calculateColumnSize(rect);\n    for (var i = 0, len = chart.columns.length; i < len; i++) {\n      column = chart.columns[i];\n      nearCount = 0;\n      farCount = 0;\n      for (var j = 0, len_3 = column.axes.length; j < len_3; j++) {\n        axis = column.axes[j];\n        axisOffset = axis.plotOffset;\n        if (axis.rect.width === 0) {\n          for (var k = i, len_4 = i + axis.span; k < len_4; k++) {\n            definition = chart.columns[k];\n            axis.rect.width += definition.computedWidth;\n          }\n          axis.rect.x = column.computedLeft + (axis.plotOffsetLeft ? axis.plotOffsetLeft : axisOffset);\n          axis.rect.width -= this.getAxisOffsetValue(axis.plotOffsetLeft, axis.plotOffsetRight, axis.plotOffset);\n          axis.rect.height = 0;\n        }\n        if (axis.isAxisOpposedPosition) {\n          if (axis.labelPosition === 'Inside' && axis.orientation === 'Horizontal') {\n            if (farCount > 0) {\n              y = rect.y - sum(subArray(column.farSizes, farCount)) - axis.maxLabelSize.height - axis.multiLevelLabelHeight - (axis.tickPosition === 'Inside' ? axis.majorTickLines.height : 0) - axis.labelPadding;\n            } else {\n              y = rect.y + sum(subArray(column.insideFarSizes, farCount));\n            }\n          } else {\n            y = rect.y - sum(subArray(column.farSizes, farCount));\n          }\n          axis.rect.y = axis.rect.y <= y ? axis.rect.y : y;\n          farCount++;\n        } else {\n          if (axis.labelPosition === 'Inside' && axis.orientation === 'Horizontal') {\n            if (nearCount > 0) {\n              y = rect.y + rect.height + sum(subArray(column.nearSizes, nearCount)) + axis.maxLabelSize.height + axis.multiLevelLabelHeight + (axis.tickPosition === 'Inside' ? axis.majorTickLines.height : 0) + axis.labelPadding;\n            } else {\n              y = rect.y + rect.height - sum(subArray(column.insideNearSizes, nearCount));\n            }\n          } else {\n            y = rect.y + rect.height + sum(subArray(column.nearSizes, nearCount));\n          }\n          axis.rect.y = axis.rect.y >= y ? axis.rect.y : y;\n          nearCount++;\n        }\n      }\n    }\n  };\n  /**\n   * Measure the axis.\n   *\n   * @returns {void}\n   * @private\n   */\n  CartesianAxisLayoutPanel.prototype.measure = function () {\n    var chart = this.chart;\n    var row;\n    var column;\n    var definition;\n    var actualIndex;\n    var span;\n    for (var _i = 0, _a = chart.axisCollections; _i < _a.length; _i++) {\n      var axis = _a[_i];\n      //definition.Axes = axis;\n      if (axis.orientation === 'Vertical') {\n        chart.verticalAxes.push(axis);\n        actualIndex = this.getActualRow(axis);\n        row = chart.rows[actualIndex];\n        this.pushAxis(row, axis);\n        span = actualIndex + axis.span > chart.rows.length ? chart.rows.length : actualIndex + axis.span;\n        for (var j = actualIndex + 1; j < span; j++) {\n          definition = chart.rows[j];\n          definition.axes[row.axes.length - 1] = axis;\n          chart.rows[j] = definition;\n        }\n        chart.rows[actualIndex] = row;\n      } else {\n        chart.horizontalAxes.push(axis);\n        actualIndex = this.getActualColumn(axis);\n        column = chart.columns[actualIndex];\n        this.pushAxis(column, axis);\n        span = actualIndex + axis.span > chart.columns.length ? chart.columns.length : actualIndex + axis.span;\n        for (var j = actualIndex + 1; j < span; j++) {\n          definition = chart.columns[j];\n          definition.axes[column.axes.length - 1] = axis;\n          chart.columns[j] = definition;\n        }\n        chart.columns[actualIndex] = column;\n      }\n      axis.isRTLEnabled = chart.enableRtl;\n      axis.setIsInversedAndOpposedPosition();\n    }\n  };\n  CartesianAxisLayoutPanel.prototype.getAxisOffsetValue = function (position1, position2, plotOffset) {\n    var rangeOffset = position1 ? position1 + (position2 ? position2 : plotOffset) : position2 ? position2 + plotOffset : 2 * plotOffset;\n    return rangeOffset;\n  };\n  CartesianAxisLayoutPanel.prototype.crossAt = function (chart) {\n    for (var _i = 0, _a = chart.axisCollections; _i < _a.length; _i++) {\n      var axis = _a[_i];\n      if (axis.crossesAt === null) {\n        continue;\n      }\n      if (!axis.crossesInAxis) {\n        if (chart.requireInvertedAxis) {\n          axis.crossInAxis = axis.orientation === 'Horizontal' ? chart.primaryXAxis : chart.primaryYAxis;\n        } else {\n          axis.crossInAxis = axis.orientation === 'Horizontal' ? chart.primaryYAxis : chart.primaryXAxis;\n        }\n        axis.crossAt = this.updateCrossAt(axis.crossInAxis, axis.crossesAt);\n        continue;\n      } else {\n        for (var i = 2, len = chart.axisCollections.length; i < len; i++) {\n          if (axis.crossesInAxis === chart.axisCollections[i].name) {\n            axis.crossInAxis = chart.axisCollections[i];\n            axis.crossAt = this.updateCrossAt(axis.crossInAxis, axis.crossesAt);\n            continue;\n          }\n        }\n      }\n    }\n  };\n  CartesianAxisLayoutPanel.prototype.updateCrossAt = function (axis, crossAt) {\n    switch (axis.valueType) {\n      case 'DateTime':\n        {\n          var option = {\n            skeleton: 'full',\n            type: 'dateTime'\n          };\n          var dateParser = this.chart.intl.getDateParser(option);\n          var dateFormatter = this.chart.intl.getDateFormat(option);\n          return Date.parse(dateParser(dateFormatter(new Date(DataUtil.parse.parseJson({\n            val: crossAt\n          }).val))));\n        }\n      case 'Category':\n        return parseFloat(crossAt) ? parseFloat(crossAt) : axis.labels.indexOf(crossAt);\n      case 'Logarithmic':\n        return logBase(crossAt, axis.logBase);\n      default:\n        return crossAt;\n    }\n  };\n  CartesianAxisLayoutPanel.prototype.pushAxis = function (definition, axis) {\n    for (var i = 0, len = definition.axes.length; i <= len; i++) {\n      if (!definition.axes[i]) {\n        definition.axes[i] = axis;\n        break;\n      }\n    }\n  };\n  CartesianAxisLayoutPanel.prototype.arrangeAxis = function (definition) {\n    var axisCollection = [];\n    for (var i = 0, len = definition.axes.length; i <= len; i++) {\n      if (definition.axes[i]) {\n        axisCollection.push(definition.axes[i]);\n      }\n    }\n    definition.axes = axisCollection;\n  };\n  CartesianAxisLayoutPanel.prototype.getActualColumn = function (axis) {\n    var actualLength = this.chart.columns.length;\n    var pos = axis.columnIndex;\n    var result = pos >= actualLength ? actualLength - 1 : pos < 0 ? 0 : pos;\n    return result;\n  };\n  CartesianAxisLayoutPanel.prototype.getActualRow = function (axis) {\n    var actualLength = this.chart.rows.length;\n    var pos = axis.rowIndex;\n    var result = pos >= actualLength ? actualLength - 1 : pos < 0 ? 0 : pos;\n    return result;\n  };\n  /**\n   * Measure the row size.\n   *\n   * @returns {void}\n   */\n  CartesianAxisLayoutPanel.prototype.calculateRowSize = function (rect) {\n    /** Calculate row size */\n    var chart = this.chart;\n    var row;\n    var rowTop = rect.y + rect.height;\n    var height = 0;\n    var remainingHeight = Math.max(0, rect.height);\n    for (var i = 0, len = chart.rows.length; i < len; i++) {\n      row = chart.rows[i];\n      if (row.height.indexOf('%') !== -1) {\n        height = Math.min(remainingHeight, rect.height * parseInt(row.height, 10) / 100);\n      } else {\n        height = Math.min(remainingHeight, parseInt(row.height, 10));\n      }\n      height = i !== len - 1 ? height : remainingHeight;\n      row.computedHeight = height;\n      rowTop -= height;\n      row.computedTop = rowTop;\n      remainingHeight -= height;\n    }\n  };\n  /**\n   * Measure the row size.\n   *\n   * @param {Rect} rect rect\n   * @returns {void}\n   */\n  CartesianAxisLayoutPanel.prototype.calculateColumnSize = function (rect) {\n    /** Calculate column size */\n    var chart = this.chart;\n    var column;\n    var columnLeft = rect.x;\n    var width = 0;\n    var remainingWidth = Math.max(0, rect.width);\n    for (var i = 0, len = chart.columns.length; i < len; i++) {\n      column = chart.columns[i];\n      if (column.width.indexOf('%') !== -1) {\n        width = Math.min(remainingWidth, rect.width * parseInt(column.width, 10) / 100);\n      } else {\n        width = Math.min(remainingWidth, parseInt(column.width, 10));\n      }\n      width = i !== len - 1 ? width : remainingWidth;\n      column.computedWidth = width;\n      column.computedLeft = columnLeft;\n      columnLeft += width;\n      remainingWidth -= width;\n    }\n  };\n  /**\n   * To render the axis element.\n   *\n   * @returns {void}\n   * @private\n   */\n  CartesianAxisLayoutPanel.prototype.renderAxes = function () {\n    var chart = this.chart;\n    var axis;\n    var axisElement = chart.renderer.createGroup({\n      id: chart.element.id + 'AxisInsideCollection'\n    });\n    var axisLineElement = chart.renderer.createGroup({\n      id: chart.element.id + 'AxisOutsideCollection'\n    });\n    if (axisLineElement) {\n      axisLineElement.setAttribute('aria-hidden', 'true');\n    }\n    var outsideElement;\n    var isInside;\n    if (chart.scrollBarModule) {\n      chart.scrollBarModule.topScrollBarCount = 0;\n      chart.scrollBarModule.bottomScrollBarCount = 0;\n      chart.scrollBarModule.leftScrollBarCount = 0;\n      chart.scrollBarModule.rightScrollBarCount = 0;\n    }\n    for (var i = 0, len = chart.axisCollections.length; i < len; i++) {\n      var axisVisibility = true;\n      axis = chart.axisCollections[i];\n      axis.index = i;\n      this.element = chart.renderer.createGroup({\n        id: chart.element.id + 'AxisGroup' + i + 'Inside'\n      });\n      if (this.element) {\n        this.element.setAttribute('aria-hidden', 'true');\n      }\n      outsideElement = chart.renderer.createGroup({\n        id: chart.element.id + 'AxisGroup' + i + 'Outside'\n      });\n      if (outsideElement) {\n        outsideElement.setAttribute('aria-hidden', 'true');\n      }\n      for (var _i = 0, _a = axis.series; _i < _a.length; _i++) {\n        var series = _a[_i];\n        if (axis.name === series.yAxisName || axis.name === series.xAxisName) {\n          axisVisibility = series.visible;\n          if (series.category === 'Pareto' && !series.paretoOptions.showAxis && series.type === 'Line') {\n            axisVisibility = false;\n          }\n          if (!axisVisibility) {\n            continue;\n          } else {\n            break;\n          }\n        }\n      }\n      if (!axisVisibility) {\n        if (axis.zoomingScrollBar) {\n          axis.zoomingScrollBar.removeScrollSvg();\n        }\n        continue;\n      }\n      isInside = this.findAxisPosition(axis);\n      this.drawAxis(axis, i, isInside, outsideElement, axisElement, axisLineElement);\n    }\n    this.drawPaneLines(chart, axisElement);\n    appendChildElement(chart.enableCanvas, chart.svgObject, axisElement, chart.redraw);\n    return axisLineElement;\n  };\n  /**\n   * To render the axis scrollbar\n   *\n   * @param {Chart} chart chart\n   * @param {Axis} axis axis\n   * @returns {void}\n   */\n  CartesianAxisLayoutPanel.prototype.renderScrollbar = function (chart, axis) {\n    var isZoomed = isNullOrUndefined(chart.zoomModule) ? false : chart.zoomModule.isZoomed;\n    if (!axis.zoomingScrollBar) {\n      chart.scrollBarModule.injectTo(axis, chart);\n    }\n    if ((isZoomed && (axis.zoomFactor < 1 || axis.zoomPosition > 0) || axis.scrollbarSettings.enable && (axis.zoomFactor <= 1 || axis.zoomPosition >= 0)) && !axis.zoomingScrollBar.isScrollUI) {\n      if (!chart.scrollElement) {\n        chart.scrollElement = redrawElement(chart.redraw, chart.element.id + '_scrollElement') || createElement('div', {\n          id: chart.element.id + '_scrollElement'\n        });\n      }\n      appendChildElement(false, chart.scrollElement, axis.zoomingScrollBar.render(true), true);\n    } else if (axis.zoomFactor === 1 && axis.zoomPosition === 0 && axis.zoomingScrollBar.svgObject && !axis.scrollbarSettings.enable) {\n      axis.zoomingScrollBar.destroy();\n    } else if (axis.zoomingScrollBar.svgObject) {\n      var topOffset = (axis.isAxisOpposedPosition && axis.orientation === 'Horizontal' ? -16 : 0) + axis.rect.y + Math.max(0.5, axis.lineStyle.width / 2);\n      var leftOffset = (axis.isAxisOpposedPosition && axis.orientation !== 'Horizontal' ? 16 : 0) + axis.rect.x - (axis.orientation === 'Vertical' ? axis.scrollbarSettings.height : 0);\n      if (axis.orientation !== 'Horizontal' && (axis.scrollbarSettings.position === 'Left' || axis.scrollbarSettings.position === 'Right')) {\n        leftOffset = calculateScrollbarOffset(axis.zoomingScrollBar, false);\n      } else if (axis.orientation === 'Horizontal' && (axis.scrollbarSettings.position === 'Top' || axis.scrollbarSettings.position === 'Bottom')) {\n        topOffset = calculateScrollbarOffset(axis.zoomingScrollBar, true);\n      }\n      axis.zoomingScrollBar.svgObject.style.top = topOffset + 'px';\n      axis.zoomingScrollBar.svgObject.style.left = leftOffset + 'px';\n    }\n    if (axis.zoomingScrollBar.isScrollUI) {\n      axis.zoomingScrollBar.isScrollUI = false;\n    }\n  };\n  /**\n   * Draws pane lines for the specified chart.\n   *\n   * @param {Chart} chart -The chart for which pane lines are to be drawn.\n   * @param {Element} [axisElement] -Optional. The axis element to which the pane lines are associated.\n   * @returns {void}\n   * @private\n   */\n  CartesianAxisLayoutPanel.prototype.drawPaneLines = function (chart, axisElement) {\n    this.element = chart.renderer.createGroup({\n      id: chart.element.id + 'DefinitionLine'\n    });\n    for (var j = 0, len = chart.rows.length; j < len; j++) {\n      var row = chart.rows[j];\n      if (row.border.color) {\n        this.drawBottomLine(row, j, true);\n      }\n    }\n    for (var j = 0, len = chart.columns.length; j < len; j++) {\n      var column = chart.columns[j];\n      if (column.border.color) {\n        this.drawBottomLine(column, j, false);\n      }\n    }\n    axisElement = axisElement ? axisElement : getElement(chart.element.id + 'AxisInsideCollection');\n    if (!this.chart.enableCanvas) {\n      axisElement.appendChild(this.element);\n    }\n  };\n  /**\n   * Draws an axis for the specified axis configuration.\n   *\n   * @private\n   * @param {Axis} axis -The axis configuration to be drawn.\n   * @param {number} index -The index of the axis.\n   * @param {boolean} isInside -Indicates whether the axis is inside or outside the plot area.\n   * @param {Element} outsideElement -The element where the axis should be drawn if it's outside the plot area.\n   * @param {Element} axisElement -The element representing the axis.\n   * @param {Element} axisLineElement -The element representing the axis line.\n   * @returns {void}\n   */\n  CartesianAxisLayoutPanel.prototype.drawAxis = function (axis, index, isInside, outsideElement, axisElement, axisLineElement) {\n    axis.updateCrossValue();\n    var axisName = '';\n    if (axis.orientation === 'Horizontal') {\n      if (axis.visible && axis.internalVisibility && axis.lineStyle.width > 0) {\n        this.drawAxisLine(axis, index, axis.plotOffset, 0, 0, 0, axis.plotOffsetLeft, axis.plotOffsetRight, isInside ? outsideElement : this.element, axis.updatedRect);\n      }\n      axisName = 'X';\n    } else {\n      if (axis.visible && axis.internalVisibility && axis.lineStyle.width > 0) {\n        this.drawAxisLine(axis, index, 0, axis.plotOffset, axis.plotOffsetBottom, axis.plotOffsetTop, 0, 0, isInside ? outsideElement : this.element, axis.updatedRect);\n      }\n      axisName = 'Y';\n    }\n    if (axis.majorGridLines.width > 0 || axis.majorTickLines.width > 0 || axis.minorTickLines.width > 0 || axis.minorGridLines.width > 0) {\n      this['draw' + axisName + 'AxisGridLine'](axis, index, isInside || axis.tickPosition === 'Inside' ? outsideElement : this.element, axis.updatedRect);\n    }\n    if (axis.visible && axis.internalVisibility) {\n      this['draw' + axisName + 'AxisLabels'](axis, index, isInside || axis.labelPosition === 'Inside' ? outsideElement : this.element, axis.placeNextToAxisLine ? axis.updatedRect : axis.rect);\n      this['draw' + axisName + 'AxisBorder'](axis, index, isInside || axis.labelPosition === 'Inside' ? outsideElement : this.element, axis.placeNextToAxisLine ? axis.updatedRect : axis.rect);\n      this['draw' + axisName + 'AxisTitle'](axis, index, isInside ? outsideElement : this.element, axis.placeNextToAxisLine ? axis.updatedRect : axis.rect);\n    }\n    if (!this.chart.enableCanvas) {\n      axisElement.appendChild(this.element);\n      if (outsideElement && outsideElement.childNodes.length > 0) {\n        axisLineElement.appendChild(outsideElement);\n      }\n    }\n    if (this.chart.scrollBarModule && (this.chart.zoomSettings.enableScrollbar && axis.enableScrollbarOnZooming || axis.scrollbarSettings.enable)) {\n      this.renderScrollbar(this.chart, axis);\n    } else {\n      if (axis.zoomingScrollBar) {\n        axis.zoomingScrollBar.destroy();\n      }\n    }\n  };\n  /**\n   * To find the axis position\n   *\n   * @param {Axis} axis axis\n   * @returns {boolean} axis position\n   * @private\n   */\n  CartesianAxisLayoutPanel.prototype.findAxisPosition = function (axis) {\n    return axis.crossAt !== null && axis.isInside(axis.crossInAxis.visibleRange);\n  };\n  /**\n   * To render the bootom line of the columns and rows\n   *\n   * @param {Row | Column} definition definition\n   * @param {number} index index\n   * @param {boolean} isRow isRow\n   * @returns {void}\n   */\n  CartesianAxisLayoutPanel.prototype.drawBottomLine = function (definition, index, isRow) {\n    var chart = this.chart;\n    var optionsLine = {};\n    var x1;\n    var x2;\n    var y1;\n    var y2;\n    var definitionName;\n    if (isRow) {\n      definition = definition;\n      y1 = y2 = definition.computedTop + definition.computedHeight;\n      x1 = this.seriesClipRect.x;\n      x2 = x1 + this.seriesClipRect.width;\n      definitionName = 'Row';\n    } else {\n      definition = definition;\n      x1 = x2 = definition.computedLeft;\n      y1 = this.seriesClipRect.y;\n      y2 = y1 + this.seriesClipRect.height;\n      definitionName = 'Column';\n    }\n    optionsLine = {\n      'id': chart.element.id + '_AxisBottom_' + definitionName + index,\n      x1: x1,\n      y1: y1,\n      x2: x2,\n      y2: y2,\n      'stroke-width': definition.border.width,\n      'stroke': definition.border.color\n    };\n    this.htmlObject = chart.renderer.drawLine(optionsLine);\n    appendChildElement(chart.enableCanvas, this.element, this.htmlObject);\n  };\n  /**\n   * To render the axis line\n   *\n   * @param {Axis} axis axis\n   * @param {number} index index\n   * @param {number} plotX plotX\n   * @param {number} plotY plotY\n   * @param {number} plotBottom plotBottom\n   * @param {number} plotTop plotTop\n   * @param {number} plotLeft plotLeft\n   * @param {number} plotRight plotRight\n   * @param {Element} parent parent\n   * @param {Rect} rect rect\n   * @returns {void}\n   */\n  CartesianAxisLayoutPanel.prototype.drawAxisLine = function (axis, index, plotX, plotY, plotBottom, plotTop, plotLeft, plotRight, parent, rect) {\n    var chart = this.chart;\n    var optionsLine = {};\n    var element = getElement(chart.element.id + 'AxisLine_' + index);\n    var direction = element ? element.getAttribute('d') : '';\n    element = null;\n    optionsLine = {\n      'id': chart.element.id + 'AxisLine_' + index,\n      'd': 'M ' + (rect.x - plotX - plotLeft) + ' ' + (rect.y - plotY - plotTop) + ' L ' + (rect.x + rect.width + plotX + plotRight) + ' ' + (rect.y + rect.height + plotY + plotBottom),\n      'stroke-dasharray': axis.lineStyle.dashArray,\n      'stroke-width': axis.lineStyle.width,\n      'stroke': axis.lineStyle.color || chart.themeStyle.axisLine\n    };\n    this.htmlObject = chart.renderer.drawPath(optionsLine);\n    appendChildElement(chart.enableCanvas, parent, this.htmlObject, chart.redraw, true, 'x', 'y', null, direction, null, null, null, chart.duration);\n  };\n  /**\n   * To render the yAxis grid line\n   *\n   * @param {Axis} axis axis\n   * @param {number} index index\n   * @param {Element} parent parent\n   * @param {Rect} rect rect\n   * @returns {void}\n   */\n  CartesianAxisLayoutPanel.prototype.drawYAxisGridLine = function (axis, index, parent, rect) {\n    var isLogAxis = axis.valueType === 'Logarithmic';\n    var isCategoryAxis = axis.valueType.indexOf('Category') > -1;\n    var tempInterval;\n    var pointY = 0;\n    var majorGrid = '';\n    var majorTick = '';\n    var minorGridDirection;\n    var isOpposed = axis.isAxisOpposedPosition;\n    var tickSize = isOpposed ? axis.majorTickLines.height : -axis.majorTickLines.height;\n    var axisLineSize = isOpposed ? axis.lineStyle.width * 0.5 : -axis.lineStyle.width * 0.5;\n    var ticksbwtLabel = axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks' ? 0.5 : 0;\n    var scrollBarHeight = isNullOrUndefined(axis.crossesAt) && axis.scrollbarSettings.position !== 'Right' && axis.scrollbarSettings.position !== 'Left' ? isOpposed ? axis.scrollBarHeight : -axis.scrollBarHeight : 0;\n    var isTickInside = axis.tickPosition === 'Inside';\n    var ticks = isTickInside ? rect.x - tickSize - axisLineSize : rect.x + tickSize + axisLineSize + scrollBarHeight;\n    var length = axis.visibleLabels.length;\n    var chartThemeStyle = this.chart.themeStyle;\n    var count = 1;\n    if (axis.valueType.indexOf('Category') > -1 && axis.labelPlacement === 'BetweenTicks' && length > 0 && !this.chart.stockChart) {\n      length += 1;\n    }\n    var minorGridLines = axis.minorGridLines;\n    var minorTickLines = axis.minorTickLines;\n    //Gridlines\n    for (var i = 0; i < length; i++) {\n      tempInterval = !axis.visibleLabels[i] ? axis.visibleLabels[i - 1].value + axis.visibleRange.interval - ticksbwtLabel : axis.visibleLabels[i].value - ticksbwtLabel;\n      pointY = valueToCoefficient(tempInterval, axis) * rect.height;\n      pointY = pointY * -1 + (rect.y + rect.height);\n      if (pointY >= rect.y && rect.y + rect.height >= pointY) {\n        if (this.chart.redraw && !this.chart.enableCanvas && this.chart.zoomRedraw && axis.visible && axis.majorGridLines.width && i !== 0 && !getElement(this.chart.element.id + '_MajorGridLine_' + index + '_' + i)) {\n          majorGrid = 'M ' + this.seriesClipRect.x + ' ' + (this.seriesClipRect.y + (axis.isInversed ? this.seriesClipRect.height + this.seriesClipRect.height / (i ? i : 1) * count : -(this.seriesClipRect.height / (i ? i : 1) * count))) + ' L ' + (this.seriesClipRect.x + this.seriesClipRect.width) + ' ' + (this.seriesClipRect.y + (axis.isInversed ? this.seriesClipRect.height + this.seriesClipRect.height / (i ? i : 1) * count : -(this.seriesClipRect.height / (i ? i : 1) * count)));\n          this.updateAxisElement(axis, index, majorGrid, i, '_MajorGridLine_', this.element, false);\n          getElement(parent.id).appendChild(this.element.childNodes[this.element.childNodes.length - 1]);\n        }\n        if (inside(tempInterval, axis.visibleRange) || this.isBorder(axis, i, pointY)) {\n          majorGrid = 'M ' + this.seriesClipRect.x + ' ' + pointY + ' L ' + (this.seriesClipRect.x + this.seriesClipRect.width) + ' ' + pointY;\n          this.renderGridLine(axis, index, majorGrid, axis.majorGridLines, '_MajorGridLine_', i, this.element, chartThemeStyle.majorGridLine, axis.majorGridLines.dashArray);\n        }\n        if (this.chart.redraw && this.chart.zoomRedraw && axis.majorTickLines.width && i !== 0 && !getElement(this.chart.element.id + '_MajorTickLine_' + index + '_' + i) && !this.chart.enableCanvas && axis.visible) {\n          majorTick = 'M ' + this.seriesClipRect.x + ' ' + (this.seriesClipRect.y + (axis.isInversed ? this.seriesClipRect.height + this.seriesClipRect.height / (i ? i : 1) * count : -(this.seriesClipRect.height / (i ? i : 1) * count))) + ' L ' + ticks + ' ' + (this.seriesClipRect.y + (axis.isInversed ? this.seriesClipRect.height + this.seriesClipRect.height / (i ? i : 1) * count : -(this.seriesClipRect.height / (i ? i : 1) * count)));\n          this.updateAxisElement(axis, index, majorTick, i, '_MajorTickLine_', parent, false);\n          getElement(parent.id).appendChild(this.element.childNodes[this.element.childNodes.length - 1]);\n          count += 1;\n        }\n        majorTick = 'M ' + (rect.x + axisLineSize + (isTickInside ? scrollBarHeight : 0)) + ' ' + pointY + ' L ' + ticks + ' ' + pointY;\n        this.renderGridLine(axis, index, majorTick, axis.majorTickLines, '_MajorTickLine_', i, parent, chartThemeStyle.majorTickLine);\n        if ((minorGridLines.width > 0 || minorTickLines.width > 0) && axis.minorTicksPerInterval > 0) {\n          if (i === 0 && isZoomSet(axis) && !isLogAxis && !isCategoryAxis) {\n            this.renderMinorGridOnZooming(axis, tempInterval, rect, i, index, chartThemeStyle, parent);\n          }\n          minorGridDirection = this.drawAxisMinorLine(axis, tempInterval, rect, i);\n          this.renderGridLine(axis, index, minorGridDirection[0], minorGridLines, '_MinorGridLine_', i, this.element, chartThemeStyle.minorGridLine, minorGridLines.dashArray);\n          this.renderGridLine(axis, index, minorGridDirection[1], minorTickLines, '_MinorTickLine_', i, parent, chartThemeStyle.minorTickLine);\n          if (i === length - 1 && isZoomSet(axis) && isLogAxis && !isCategoryAxis) {\n            this.renderMinorGridOnZooming(axis, tempInterval + axis.visibleRange.interval, rect, i, index, chartThemeStyle, parent);\n          }\n        }\n      }\n    }\n    if (length && this.previousYLabel > length && !this.chart.enableCanvas && axis.visible && this.chart.zoomRedraw && this.chart.redraw) {\n      for (var i = length; i < this.previousYLabel; i++) {\n        var pointYValue = this.seriesClipRect.y + (axis.isInversed ? this.seriesClipRect.height / length * (i - length + 1) + this.seriesClipRect.height : -(this.seriesClipRect.height / length * (i - length + 1)));\n        if (axis.majorGridLines.width) {\n          majorGrid = 'M ' + this.seriesClipRect.x + ' ' + +pointYValue + ' L ' + (this.seriesClipRect.x + this.seriesClipRect.width) + ' ' + pointYValue;\n          this.updateAxisElement(axis, index, majorGrid, i, '_MajorGridLine_', this.element, true);\n        }\n        if (axis.majorTickLines.width) {\n          majorTick = 'M ' + this.seriesClipRect.x + ' ' + pointYValue + ' L ' + ticks + ' ' + pointYValue;\n          this.updateAxisElement(axis, index, majorTick, i, '_MajorTickLine_', parent, true);\n        }\n      }\n    }\n  };\n  /**\n   * To check the border of the axis\n   *\n   * @param {Axis} axis axis\n   * @param {number} index index\n   * @param {number} value value\n   * @returns {boolean} check the border of the axis\n   */\n  CartesianAxisLayoutPanel.prototype.isBorder = function (axis, index, value) {\n    var border = this.chart.chartArea.border;\n    var rect = this.seriesClipRect;\n    var orientation = axis.orientation;\n    var start = orientation === 'Horizontal' ? rect.x : rect.y;\n    var size = orientation === 'Horizontal' ? rect.width : rect.height;\n    var startIndex = orientation === 'Horizontal' ? 0 : axis.visibleLabels.length - 1;\n    var endIndex = orientation === 'Horizontal' ? axis.visibleLabels.length - 1 : 0;\n    if (axis.plotOffset > 0) {\n      return true;\n    } else if ((value === start || value === start + size) && (border.width <= 0 || border.color === 'transparent')) {\n      return true;\n    } else if (value !== start && index === startIndex || value !== start + size && index === endIndex) {\n      return true;\n    }\n    return false;\n  };\n  /**\n   * To render the yAxis label\n   *\n   * @param {Axis} axis axis\n   * @param {number} index index\n   * @param {Element} parent parent\n   * @param {Rect} rect rect\n   * @returns {void}\n   * @private\n   */\n  CartesianAxisLayoutPanel.prototype.drawYAxisLabels = function (axis, index, parent, rect) {\n    var chart = this.chart;\n    var label;\n    var pointX = 0;\n    var pointY = 0;\n    var elementSize;\n    var labelSpace = axis.labelPadding;\n    var options;\n    var isAxisBreakLabel;\n    var isLabelInside = axis.labelPosition === 'Inside';\n    var isOpposed = axis.isAxisOpposedPosition;\n    var RotatedWidth;\n    var tickSpace = axis.labelPosition === axis.tickPosition ? axis.majorTickLines.height : 0;\n    var padding = tickSpace + labelSpace + axis.lineStyle.width * 0.5;\n    var angle = axis.angle % 360;\n    var isVerticalAngle = angle === -90 || angle === 90 || angle === 270 || angle === -270;\n    padding += isVerticalAngle ? isLabelInside ? 5 : -5 : 0;\n    padding = isOpposed ? padding : -padding;\n    var labelElement = chart.renderer.createGroup({\n      id: chart.element.id + 'AxisLabels' + index\n    });\n    var scrollBarHeight = isNullOrUndefined(axis.crossesAt) && axis.scrollbarSettings.position !== 'Left' && axis.scrollbarSettings.position !== 'Right' ? axis.scrollBarHeight * (isOpposed ? 1 : -1) : 0;\n    var textHeight;\n    var textPadding;\n    var maxLineWidth;\n    var pixel = 10;\n    var isInverse = axis.isAxisInverse;\n    var count = 1;\n    var previousEnd = isInverse ? rect.y : rect.y + rect.height;\n    var labelPadding;\n    var intervalLength;\n    var labelHeight;\n    var yAxisLabelX;\n    var isLabelOnAxisLineLeft = !isOpposed && !isLabelInside || isOpposed && isLabelInside;\n    if (isLabelInside) {\n      labelPadding = !isLabelOnAxisLineLeft ? -padding : padding;\n    } else {\n      labelPadding = !isLabelOnAxisLineLeft ? -padding + (chart.enableRtl ? -scrollBarHeight : scrollBarHeight) : padding + (chart.enableRtl ? -scrollBarHeight : scrollBarHeight);\n    }\n    var sizeWidth = [];\n    var breakLabelSizeWidth = [];\n    axis.visibleLabels.map(function (item) {\n      sizeWidth.push(item.size['width']);\n      breakLabelSizeWidth.push(item.breakLabelSize['width']);\n    });\n    var LabelMaxWidth = Math.max.apply(Math, sizeWidth);\n    var breakLabelMaxWidth = Math.max.apply(Math, breakLabelSizeWidth);\n    RotatedWidth = LabelMaxWidth;\n    if (angle >= -45 && angle <= 45 && angle !== 0) {\n      RotatedWidth = LabelMaxWidth * Math.cos(angle * Math.PI / 180);\n      if (RotatedWidth < 0) {\n        RotatedWidth = -RotatedWidth;\n      }\n    }\n    for (var i = 0, len = axis.visibleLabels.length; i < len; i++) {\n      label = axis.visibleLabels[i];\n      isAxisBreakLabel = isBreakLabel(axis.visibleLabels[i].originalText);\n      elementSize = isAxisBreakLabel ? axis.visibleLabels[i].breakLabelSize : axis.visibleLabels[i].size;\n      pointY = valueToCoefficient(axis.visibleLabels[i].value, axis) * rect.height + (chart.stockChart ? 7 : 0);\n      pointY = Math.floor(pointY * -1 + (rect.y + rect.height));\n      textHeight = elementSize.height / 8 * axis.visibleLabels[i].text.length / 2;\n      textPadding = chart.requireInvertedAxis && axis.labelPosition === 'Inside' ? 0 : elementSize.height / 4 * 3 + 3;\n      intervalLength = rect.height / axis.visibleLabels.length;\n      labelHeight = (axis.labelIntersectAction === 'Trim' || axis.labelIntersectAction === 'Wrap') && angle !== 0 && elementSize.width > intervalLength ? intervalLength : elementSize.width;\n      pointY = isAxisBreakLabel ? axis.labelPosition === 'Inside' ? pointY - elementSize.height / 2 - textHeight + textPadding : pointY - textHeight : axis.labelPosition === 'Inside' ? pointY + textPadding : pointY;\n      if (axis.labelPosition === 'Inside' && (i === 0 && !axis.isInversed || i === len - 1 && axis.isInversed)) {\n        if (chart.stockChart) {\n          pointY -= textPadding;\n        } else {\n          pointY -= textPadding - (chart.requireInvertedAxis && axis.labelPosition === 'Inside' ? 0 : axis.opposedPosition ? -padding : padding);\n        }\n      }\n      if (axis.majorGridLines.width > axis.majorTickLines.width) {\n        maxLineWidth = axis.majorGridLines.width;\n      } else {\n        maxLineWidth = axis.majorTickLines.width;\n      }\n      if (axis.labelStyle.textAlignment === 'Far') {\n        pointY = pointY - maxLineWidth - pixel;\n      } else if (axis.labelStyle.textAlignment === 'Near') {\n        pointY = pointY + maxLineWidth + pixel;\n      }\n      // label X value adjustment (Start)\n      if (isLabelInside) {\n        yAxisLabelX = labelPadding + (angle === 0 ? elementSize.width : isAxisBreakLabel ? breakLabelMaxWidth : LabelMaxWidth) / 2;\n      } else {\n        yAxisLabelX = labelPadding - (angle === 0 ? elementSize.width : isAxisBreakLabel ? breakLabelMaxWidth : RotatedWidth) / 2;\n      }\n      if (axis.enableWrap && chart.requireInvertedAxis && angle && (!axis.opposedPosition && axis.labelPosition === 'Inside' || axis.opposedPosition && axis.labelPosition === 'Outside')) {\n        yAxisLabelX = axis.opposedPosition ? yAxisLabelX - LabelMaxWidth / 2 : yAxisLabelX + LabelMaxWidth / 2;\n      }\n      pointX = isOpposed ? axis.scrollBarHeight !== 0 && axis.scrollbarSettings.position !== 'Right' && axis.scrollbarSettings.position !== 'Left' ? rect.x + axis.scrollBarHeight + padding - yAxisLabelX : rect.x - yAxisLabelX : rect.x + yAxisLabelX;\n      if (isVerticalAngle) {\n        pointX += isOpposed ? 5 : -5;\n      }\n      yAxisLabelX = labelPadding;\n      options = new TextOption(chart.element.id + index + '_AxisLabel_' + i, pointX, pointY, 'middle', label.text, '', 'middle', angle);\n      switch (axis.edgeLabelPlacement) {\n        case 'None':\n          break;\n        case 'Hide':\n          if ((i === 0 || isInverse && i === len - 1) && options.y > rect.y || (i === len - 1 || isInverse && i === 0) && options.y - elementSize.height * 0.5 < rect.y) {\n            options.text = '';\n          }\n          break;\n        case 'Shift':\n          if ((i === 0 || isInverse && i === len - 1) && options.y > rect.y + rect.height) {\n            options.y = pointY = rect.y + rect.height;\n          } else if ((i === len - 1 || isInverse && i === 0) && options.y <= 0) {\n            options.y = pointY = rect.y + elementSize.height * 0.5;\n          }\n          break;\n      }\n      // ------- Hide Calculation (Start) -------------\n      var previousYValue = options.y;\n      var currentYValue = options.y - labelHeight;\n      if (isAxisBreakLabel) {\n        previousYValue = options.y - labelHeight / 2;\n        currentYValue = options.y + labelHeight / 2;\n      }\n      if ((angle === 90 || angle === 270) && axis.labelIntersectAction === 'Hide' && i !== 0 && (!isInverse ? previousYValue >= previousEnd : currentYValue <= previousEnd)) {\n        continue;\n      }\n      previousEnd = isInverse ? previousYValue : currentYValue;\n      // ------- Hide Calculation (End) -------------\n      options.transform = 'rotate(' + angle + ',' + pointX + ',' + pointY + ')';\n      if (this.chart.redraw && this.chart.zoomRedraw && !getElement(options.id) && !this.chart.enableCanvas && axis.visible) {\n        var optionsY = options.y;\n        options.y = this.seriesClipRect.y + (axis.isInversed ? this.seriesClipRect.height + this.seriesClipRect.height / (i ? i : 1) * count : -(this.seriesClipRect.height / (i ? i : 1) * count));\n        this.updateAxisElement(axis, index, '', i, '_AxisLabel_', labelElement, false, options, label);\n        options.y = optionsY;\n        count += 1;\n      }\n      textElement(chart.renderer, options, label.labelStyle, label.labelStyle.color || chart.themeStyle.axisLabelFont.color, labelElement, false, chart.redraw, true, true, chart.duration, null, null, null, chart.enableCanvas, null, chart.themeStyle.axisLabelFont, new ChartLocation(pointX, pointY));\n    }\n    if (this.previousYLabel && axis.visibleLabels.length && this.previousYLabel > axis.visibleLabels.length && !this.chart.enableCanvas && axis.visible && this.chart.zoomRedraw && chart.redraw && options.text) {\n      for (var i = axis.visibleLabels.length; i < this.previousYLabel; i++) {\n        options.y = this.seriesClipRect.y + (axis.isInversed ? this.seriesClipRect.height + this.seriesClipRect.height / axis.visibleLabels.length * (i - axis.visibleLabels.length + 1) : -(this.seriesClipRect.height / axis.visibleLabels.length * (i - axis.visibleLabels.length + 1)));\n        options.id = chart.element.id + index + '_AxisLabel_' + i;\n        this.updateAxisElement(axis, index, '', i, '_AxisLabel_', labelElement, true, options, label);\n      }\n    } else {\n      this.previousYLabel = axis.visibleLabels.length;\n    }\n    if (!this.chart.enableCanvas) {\n      if (!chart.delayRedraw) {\n        appendChildElement(chart.enableCanvas, parent, labelElement, chart.redraw);\n      } else if (axis.visible && axis.internalVisibility) {\n        this.createZoomingLabel(this.chart, labelElement, axis, index, rect);\n      }\n    }\n  };\n  /**\n   * Animates the template element.\n   *\n   * @param {Axis} axis axis\n   * @param {Element} element - The element to animate.\n   * @param {number} duration - The duration of the animation.\n   * @param {boolean} label - Label.\n   * @param {Rect} bounds - The bounding rectangle.\n   * @param {boolean} isRemove isRemoved\n   * @param {number} i index of the element\n   * @returns {void}\n   * @private\n   */\n  CartesianAxisLayoutPanel.prototype.rangeAnimate = function (axis, element, duration, label, bounds, isRemove, i) {\n    var _this = this;\n    if (element) {\n      new Animation({}).animate(element, {\n        duration: duration,\n        progress: function () {\n          var animateElement = getElement(element.id);\n          animateElement.style.animation = '';\n          if (label) {\n            if (withInBounds(parseFloat(animateElement.getAttribute('x')), parseFloat(animateElement.getAttribute('y')), bounds)) {\n              animateElement.style.visibility = 'visible';\n            } else {\n              animateElement.style.visibility = 'hidden';\n            }\n          } else {\n            var direction = animateElement.getAttribute('d').split(' ');\n            if (withInBounds(parseFloat(direction[1]), parseFloat(direction[2]), bounds)) {\n              animateElement.style.visibility = 'visible';\n            } else {\n              animateElement.style.visibility = 'hidden';\n            }\n          }\n        },\n        end: function () {\n          var animateElement = getElement(element.id);\n          animateElement.style.visibility = '';\n          if (isRemove && i >= axis.visibleLabels.length) {\n            removeElement(animateElement);\n            if (label) {\n              if (axis.orientation === 'Vertical') {\n                _this.previousYLabel = axis.visibleLabels.length;\n              } else {\n                _this.previousXLabel = axis.visibleLabels.length;\n              }\n            }\n          }\n        }\n      });\n    }\n  };\n  /**\n   * To get X value based on lineBreakAlignment for Y axis line break labels only.\n   *\n   * @param {number} x text x position\n   * @param {Axis} axis y axis values\n   * @param {number} textWidth axis label width\n   * @returns {number} returns suitable axis label x position\n   */\n  CartesianAxisLayoutPanel.prototype.getAxisLabelXvalue = function (x, axis, textWidth) {\n    var anchor = axis.lineBreakAlignment;\n    var isLabelInside = axis.labelPosition === 'Inside';\n    var isOpposed = axis.isAxisOpposedPosition;\n    if (isOpposed && isLabelInside || !isOpposed && !isLabelInside) {\n      return anchor === 'Right' ? x : anchor === 'Center' ? x - textWidth / 2 : x - textWidth;\n    } else {\n      return anchor === 'Left' ? x : anchor === 'Center' ? x + textWidth / 2 : x + textWidth;\n    }\n  };\n  /**\n   * To render the yAxis label border.\n   *\n   * @param {Axis} axis axis\n   * @param {number} index index\n   * @param {Element} parent parent\n   * @param {Rect} rect rect\n   * @returns {void}\n   */\n  CartesianAxisLayoutPanel.prototype.drawYAxisBorder = function (axis, index, parent, rect) {\n    if (axis.border.width > 0) {\n      var startY = void 0;\n      var pointY = void 0;\n      var scrollBarHeight = axis.labelPosition === 'Outside' && axis.scrollbarSettings.position !== 'Right' && axis.scrollbarSettings.position !== 'Left' ? axis.scrollBarHeight : 0;\n      var isOpposed = axis.isAxisOpposedPosition;\n      scrollBarHeight = (isOpposed ? 1 : -1) * scrollBarHeight;\n      var gap = rect.height / axis.visibleRange.delta * (axis.valueType === 'DateTime' ? axis.dateTimeInterval : axis.visibleRange.interval);\n      var endY = void 0;\n      var length_1 = axis.maxLabelSize.width + 10 + (axis.tickPosition === axis.labelPosition ? axis.majorTickLines.height : 0);\n      var labelBorder = '';\n      var ticksbwtLabel = axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks' ? -0.5 : 0;\n      var endX = isOpposed && axis.labelPosition === 'Inside' || !isOpposed && axis.labelPosition === 'Outside' ? rect.x - length_1 + scrollBarHeight : rect.x + length_1 + scrollBarHeight;\n      for (var i = 0, len = axis.visibleLabels.length; i < len; i++) {\n        pointY = valueToCoefficient(axis.visibleLabels[i].value + ticksbwtLabel, axis);\n        pointY = (axis.isAxisInverse ? 1 - pointY : pointY) * rect.height;\n        if (axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks') {\n          startY = pointY * -1 + (rect.y + rect.height);\n          endY = pointY * -1 - gap + (rect.y + rect.height);\n        } else {\n          startY = pointY * -1 + gap / 2 + (rect.y + rect.height);\n          endY = pointY * -1 - gap / 2 + (rect.y + rect.height);\n        }\n        switch (axis.border.type) {\n          case 'Rectangle':\n          case 'WithoutTopBorder':\n            if (startY > rect.y + rect.height) {\n              labelBorder += 'M' + ' ' + endX + ' ' + (rect.y + rect.height) + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ';\n            } else if (Math.floor(rect.y) > endY) {\n              labelBorder += 'M' + ' ' + (rect.x + scrollBarHeight) + ' ' + startY + ' ' + 'L' + ' ' + endX + ' ' + startY + ' ' + 'L' + ' ' + endX + ' ' + rect.y + ' ';\n            } else {\n              labelBorder += 'M' + ' ' + (rect.x + scrollBarHeight) + ' ' + startY + ' ' + 'L' + ' ' + endX + ' ' + startY + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ';\n              if (i === axis.visibleLabels.length - 1) {\n                labelBorder += 'M' + ' ' + (rect.x + scrollBarHeight) + ' ' + endY + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ';\n              }\n            }\n            break;\n          case 'WithoutTopandBottomBorder':\n            if (!(startY > rect.y + rect.height) && !(endY < Math.floor(rect.y))) {\n              labelBorder += 'M' + ' ' + (rect.x + scrollBarHeight) + ' ' + startY + ' ' + 'L' + ' ' + endX + ' ' + startY + ' ' + 'M' + ' ' + endX + ' ' + endY + ' ' + 'L' + ' ' + (rect.x + scrollBarHeight) + ' ' + endY;\n            }\n            break;\n        }\n      }\n      labelBorder += axis.border.type === 'Rectangle' ? 'M' + ' ' + (rect.x + scrollBarHeight) + ' ' + rect.y + ' ' + 'L' + ' ' + (rect.x + scrollBarHeight) + ' ' + (rect.y + rect.height) + ' ' : '';\n      if (labelBorder !== '') {\n        this.createAxisBorderElement(axis, index, labelBorder, parent);\n      }\n    }\n    for (var i = 0; i < this.chart.visibleSeries.length; i++) {\n      if (axis.multiLevelLabels.length > 0 && this.chart.multiLevelLabelModule && this.chart.visibleSeries[i].visible) {\n        this.chart.multiLevelLabelModule.renderYAxisMultiLevelLabels(axis, index, parent, rect);\n        break;\n      }\n    }\n  };\n  /**\n   * To render the yAxis title\n   *\n   * @param {Axis} axis axis\n   * @param {number} index index\n   * @param {Element} parent parent\n   * @param {Rect} rect rect\n   * @returns {void}\n   */\n  CartesianAxisLayoutPanel.prototype.drawYAxisTitle = function (axis, index, parent, rect) {\n    if (axis.title) {\n      var chart = this.chart;\n      var isRotated = false;\n      var isOpposed = axis.isAxisOpposedPosition;\n      var labelRotation = (axis.titleRotation == null ? isOpposed ? 90 : -90 : axis.titleRotation) % 360;\n      var padding = (axis.tickPosition === 'Inside' ? 0 : axis.majorTickLines.height + axis.titlePadding) + (axis.labelPosition === 'Inside' ? 0 : axis.maxLabelSize.width + axis.multiLevelLabelHeight + this.padding);\n      padding = axis.tickPosition !== 'Outside' && (axis.tickPosition === 'Inside' || axis.labelPosition === 'Inside') ? axis.titlePadding === 5 ? padding : padding + axis.titlePadding : padding;\n      padding = isOpposed ? padding + (axis.scrollbarSettings.position === 'Right' || axis.scrollbarSettings.position === 'Left' ? 0 : axis.scrollBarHeight) : -padding - (axis.scrollbarSettings.position === 'Right' || axis.scrollbarSettings.position === 'Left' ? 0 : axis.scrollBarHeight);\n      if (labelRotation !== -90 && !isOpposed || labelRotation !== 90 && isOpposed) {\n        padding += axis.isAxisOpposedPosition ? axis.titleSize.width / 2 + (axis.labelPosition === 'Inside' ? axis.labelPadding !== 5 ? 0 : axis.labelPadding : axis.labelPadding) : -axis.titleSize.width / 2 - (axis.labelPosition === 'Inside' ? axis.labelPadding !== 5 ? 0 : axis.labelPadding : axis.labelPadding);\n        isRotated = true;\n      }\n      var x = rect.x + padding;\n      var y = void 0;\n      var anchor = void 0;\n      if (axis.titleStyle.textAlignment === 'Center') {\n        anchor = 'middle';\n        y = rect.y + rect.height * 0.5;\n      } else if (axis.titleStyle.textAlignment === 'Near') {\n        anchor = axis.opposedPosition ? 'end' : 'start';\n        y = rect.height + rect.y;\n      } else {\n        anchor = axis.opposedPosition ? 'start' : 'end';\n        y = rect.y;\n      }\n      var titleSize = axis.titleSize.height * (axis.titleCollection.length - 1);\n      var options = new TextOption(chart.element.id + '_AxisTitle_' + index, x, y + (isRotated ? -titleSize : -(axis.labelPosition === 'Inside' ? axis.labelPadding !== 5 ? 0 : axis.labelPadding : axis.labelPadding) - titleSize), anchor, axis.titleCollection, 'rotate(' + labelRotation + ',' + x + ',' + y + ')', null, labelRotation);\n      var element = textElement(chart.renderer, options, axis.titleStyle, axis.titleStyle.color || chart.themeStyle.axisTitleFont.color, parent, null, null, null, null, null, null, null, null, chart.enableCanvas, null, chart.themeStyle.axisTitleFont, new ChartLocation(x, y));\n      element.setAttribute('aria-hidden', 'true');\n    }\n  };\n  /**\n   * xAxis grid line calculation performed here\n   *\n   * @param {Axis} axis axis\n   * @param {number} index index\n   * @param {Element} parent parent\n   * @param {Rect} rect rect\n   * @returns {void}\n   */\n  CartesianAxisLayoutPanel.prototype.drawXAxisGridLine = function (axis, index, parent, rect) {\n    var isLogAxis = axis.valueType === 'Logarithmic';\n    var isCategoryAxis = axis.valueType.indexOf('Category') > -1;\n    var tempInterval;\n    var pointX = 0;\n    var majorGrid = '';\n    var majorTick = '';\n    var minorDirection;\n    var count = 1;\n    var isOpposed = axis.isAxisOpposedPosition;\n    var tickSize = isOpposed ? -axis.majorTickLines.height : axis.majorTickLines.height;\n    var axisLineSize = isOpposed ? -axis.lineStyle.width * 0.5 : axis.lineStyle.width * 0.5;\n    var scrollBarHeight = isNullOrUndefined(axis.crossesAt) && axis.scrollbarSettings.position !== 'Top' && axis.scrollbarSettings.position !== 'Bottom' ? isOpposed ? -axis.scrollBarHeight : axis.scrollBarHeight : 0;\n    var ticksbwtLabel = axis.valueType.indexOf('Category') > -1 && axis.labelPlacement === 'BetweenTicks' && !this.chart.stockChart ? 0.5 : 0;\n    var length = axis.visibleLabels.length;\n    var isTickInside = axis.tickPosition === 'Inside';\n    var ticks = isTickInside ? rect.y - tickSize - axisLineSize : rect.y + tickSize + axisLineSize + scrollBarHeight;\n    var chartThemeStyle = this.chart.themeStyle;\n    if (axis.valueType.indexOf('Category') > -1 && length > 0 && axis.labelPlacement === 'BetweenTicks' && !this.chart.stockChart) {\n      length += 1;\n    }\n    var numericIDs = this.calculateGridLineId(parent, length);\n    for (var i = 0; i < length; i++) {\n      if (axis.valueType !== 'DateTimeCategory') {\n        tempInterval = axis.visibleLabels[i] ? axis.visibleLabels[i].value - ticksbwtLabel : axis.visibleLabels[i - 1].value + axis.visibleRange.interval - ticksbwtLabel;\n      } else {\n        tempInterval = axis.visibleLabels[i] ? axis.visibleLabels[i].value - ticksbwtLabel : axis.visibleRange.max;\n      }\n      pointX = valueToCoefficient(tempInterval, axis) * rect.width + rect.x;\n      if (pointX >= rect.x && rect.x + rect.width >= pointX) {\n        if (inside(tempInterval, axis.visibleRange) || this.isBorder(axis, i, pointX)) {\n          if (this.chart.redraw && (this.chart.pointsAdded && !this.chart.pointsRemoved || this.chart.zoomRedraw) && axis.majorGridLines.width && i !== 0 && axis.visible && !getElement(this.chart.element.id + '_MajorGridLine_' + index + '_' + i) && !this.chart.enableCanvas) {\n            var pointXValue = this.seriesClipRect.x + (this.chart.enableRtl !== axis.isInversed ? -(this.seriesClipRect.width / length * count) : this.seriesClipRect.width + this.seriesClipRect.width / (i ? i : 1) * count);\n            majorGrid = 'M ' + pointXValue + ' ' + (this.seriesClipRect.y + this.seriesClipRect.height) + ' L ' + pointXValue + ' ' + this.seriesClipRect.y;\n            this.renderGridLine(axis, index, majorGrid, axis.majorGridLines, '_MajorGridLine_', i, this.element, chartThemeStyle.majorGridLine, axis.majorGridLines.dashArray, numericIDs['MajorGridLine'] && numericIDs['MajorGridLine'].ids ? numericIDs['MajorGridLine'].ids[i] : null, numericIDs['MajorGridLine'] ? numericIDs['MajorGridLine'].isPointRemoved : false);\n            this.rangeAnimate(axis, this.element.childNodes[this.element.childNodes.length - 1], this.chart.duration, false, new Rect(this.seriesClipRect.x, axis.rect.y, this.seriesClipRect.x + this.seriesClipRect.width, this.chart.availableSize.height), false, i);\n            if (getElement(parent.id)) {\n              getElement(parent.id).appendChild(this.element.childNodes[this.element.childNodes.length - 1]);\n            }\n          }\n          majorGrid = 'M ' + pointX + ' ' + (this.seriesClipRect.y + this.seriesClipRect.height) + ' L ' + pointX + ' ' + this.seriesClipRect.y;\n          this.renderGridLine(axis, index, majorGrid, axis.majorGridLines, '_MajorGridLine_', i, this.element, chartThemeStyle.majorGridLine, axis.majorGridLines.dashArray, numericIDs['MajorGridLine'] && numericIDs['MajorGridLine'].ids ? numericIDs['MajorGridLine'].ids[i] : null, numericIDs['MajorGridLine'] ? numericIDs['MajorGridLine'].isPointRemoved : false);\n        }\n        if (this.chart.redraw && this.chart.zoomRedraw && axis.majorTickLines.width && !getElement(this.chart.element.id + '_MajorTickLine_' + index + '_' + i) && !this.chart.enableCanvas && axis.visible) {\n          majorTick = 'M ' + (this.seriesClipRect.x + (this.chart.enableRtl !== axis.isInversed ? -(this.seriesClipRect.width / length * count) : this.seriesClipRect.width + this.seriesClipRect.width / (i ? i : 1) * count)) + ' ' + (rect.y + axisLineSize + (isTickInside ? scrollBarHeight : 0)) + ' L ' + (this.seriesClipRect.x + (this.chart.enableRtl !== axis.isInversed ? -(this.seriesClipRect.width / length * count) : this.seriesClipRect.width + this.seriesClipRect.width / (i ? i : 1) * count)) + ' ' + ticks;\n          this.updateAxisElement(axis, index, majorTick, i, '_MajorTickLine_', parent, false);\n          getElement(parent.id).appendChild(this.element.childNodes[this.element.childNodes.length - 1]);\n          count += 1;\n        }\n        majorTick = 'M ' + pointX + ' ' + (rect.y + axisLineSize + (isTickInside ? scrollBarHeight : 0)) + ' L ' + pointX + ' ' + ticks;\n        this.renderGridLine(axis, index, majorTick, axis.majorTickLines, '_MajorTickLine_', i, parent, chartThemeStyle.majorTickLine, null, numericIDs['MajorTickLine'] && numericIDs['MajorTickLine'].ids ? numericIDs['MajorTickLine'].ids[i] : null, numericIDs['MajorTickLine'] ? numericIDs['MajorTickLine'].isPointRemoved : false);\n        if (axis.minorTicksPerInterval > 0 && (axis.minorGridLines.width > 0 || axis.minorTickLines.width > 0)) {\n          if (i === 0 && isZoomSet(axis) && !isLogAxis && !isCategoryAxis) {\n            this.renderMinorGridOnZooming(axis, tempInterval, rect, i, index, chartThemeStyle, parent);\n          }\n          minorDirection = this.drawAxisMinorLine(axis, tempInterval, rect, i);\n          this.renderGridLine(axis, index, minorDirection[0], axis.minorGridLines, '_MinorGridLine_', i, this.element, chartThemeStyle.minorGridLine, axis.minorGridLines.dashArray, numericIDs['MinorGridLine'] && numericIDs['MinorGridLine'].ids ? numericIDs['MinorGridLine'].ids[i] : null, numericIDs['MinorGridLine'] ? numericIDs['MinorGridLine'].isPointRemoved : false);\n          this.renderGridLine(axis, index, minorDirection[1], axis.minorTickLines, '_MinorTickLine_', i, parent, chartThemeStyle.minorTickLine, null, numericIDs['MinorTickLine'] && numericIDs['MinorTickLine'].ids ? numericIDs['MinorTickLine'].ids[i] : null, numericIDs['MinorTickLine'] ? numericIDs['MinorTickLine'].isPointRemoved : false);\n          if (i === length - 1 && isZoomSet(axis) && isLogAxis && !isCategoryAxis) {\n            this.renderMinorGridOnZooming(axis, tempInterval + axis.visibleRange.interval, rect, i, index, chartThemeStyle, parent);\n          }\n        }\n      }\n    }\n    if (length && this.previousXLabel > length && !this.chart.enableCanvas && axis.visible && this.chart.zoomRedraw && this.chart.redraw) {\n      for (var i = length; i < this.previousXLabel; i++) {\n        var pointXValue = this.seriesClipRect.x + (this.chart.enableRtl !== axis.isInversed ? -(this.seriesClipRect.width / length * (i - length + 1)) : this.seriesClipRect.width + this.seriesClipRect.width / length * (i - length + 1));\n        if (axis.majorGridLines.width) {\n          majorGrid = 'M ' + pointXValue + ' ' + (this.seriesClipRect.y + this.seriesClipRect.height) + ' L ' + pointXValue + ' ' + this.seriesClipRect.y;\n          this.updateAxisElement(axis, index, majorGrid, i, '_MajorGridLine_', this.element, true);\n        }\n        if (axis.majorTickLines.width) {\n          majorTick = 'M ' + pointXValue + ' ' + (rect.y + axisLineSize + (isTickInside ? scrollBarHeight : 0)) + ' L ' + pointXValue + ' ' + ticks;\n          this.updateAxisElement(axis, index, majorTick, i, '_MajorTickLine_', parent, true);\n        }\n      }\n    }\n  };\n  CartesianAxisLayoutPanel.prototype.calculateGridLineId = function (parent, length) {\n    var _this = this;\n    var numericIDs = {};\n    if (this.chart.pointsRemoved) {\n      var elementTypes = ['MajorGridLine', 'MajorTickLine', 'MinorGridLine', 'MinorTickLine'];\n      elementTypes.forEach(function (type) {\n        var parentElement = getElement(parent.id);\n        var elements = parentElement.querySelectorAll('[id*=\"_' + type + '_\"]');\n        var elementArray = [];\n        for (var i = 0; i < elements.length; i++) {\n          elementArray.push(elements[i]);\n        }\n        var len = type === 'MajorGridLine' && _this.chart.chartArea.border.width ? length - 2 : length;\n        len = type === 'MinorGridLine' || type === 'MinorTickLine' ? length - 1 : len;\n        if (elementArray.length > 0 && elementArray.length > len) {\n          var elementsLength = elementArray.length;\n          for (var k = 0; k < elementsLength - len; k++) {\n            if (elementArray[k]) {\n              parentElement.removeChild(elementArray[k]);\n            }\n            elementArray.shift();\n          }\n          var numericIds = elementArray.map(function (element) {\n            var parts = element.id.split('_');\n            return parseInt(parts[parts.length - 1], 10);\n          });\n          numericIDs[type] = {\n            ids: numericIds,\n            isPointRemoved: true\n          };\n        }\n      });\n    }\n    return numericIDs;\n  };\n  /**\n   * To render missing minor grid lines while zooming\n   *\n   * @param {Axis} axis axis\n   * @param {number} tempInterval tempInterval\n   * @param {Rect} rect rect\n   * @param {number} i i\n   * @param {number} index index\n   * @param {IThemeStyle} chartThemeStyle chartThemeStyle\n   * @param {Element} parent parent\n   * @returns {void}\n   */\n  CartesianAxisLayoutPanel.prototype.renderMinorGridOnZooming = function (axis, tempInterval, rect, i, index, chartThemeStyle, parent) {\n    var minorDirection = this.drawAxisMinorLine(axis, tempInterval, rect, i, true);\n    this.renderGridLine(axis, index, minorDirection[0], axis.minorGridLines, '_MinorGridLine_', -1, this.element, chartThemeStyle.minorGridLine, axis.minorGridLines.dashArray);\n    this.renderGridLine(axis, index, minorDirection[1], axis.minorTickLines, '_MinorTickLine_', -1, parent, chartThemeStyle.minorTickLine);\n  };\n  /**\n   * To calcualte the axis minor line\n   *\n   * @param {Axis} axis axis\n   * @param {number} tempInterval tempInterval\n   * @param {Rect} rect rect\n   * @param {number} labelIndex labelIndex\n   * @param {boolean} isFirstLabel isFirstLabel\n   * @returns {string[]} axis minor line path\n   */\n  CartesianAxisLayoutPanel.prototype.drawAxisMinorLine = function (axis, tempInterval, rect, labelIndex, isFirstLabel) {\n    var value = tempInterval;\n    var coor = 0;\n    var position = 0;\n    var range = axis.visibleRange;\n    var isTickInside = axis.tickPosition === 'Inside';\n    var direction = [];\n    var tickSize = axis.isAxisOpposedPosition ? -axis.minorTickLines.height : axis.minorTickLines.height;\n    var logStart;\n    var logEnd;\n    var logInterval = 1;\n    var logPosition = 1;\n    var ticksX = isTickInside ? rect.y - tickSize : rect.y + tickSize;\n    var ticksY = isTickInside ? rect.x + tickSize : rect.x - tickSize;\n    var minorGird = '';\n    var minorTick = '';\n    var isInverse = axis.isAxisInverse;\n    if (axis.valueType === 'Logarithmic') {\n      logStart = Math.pow(axis.logBase, value - range.interval);\n      logEnd = Math.pow(axis.logBase, value);\n      logInterval = (logEnd - logStart) / (axis.minorTicksPerInterval + 1);\n      logPosition = logStart + logInterval;\n    }\n    if (axis.orientation === 'Horizontal') {\n      for (var j = 0; j < axis.minorTicksPerInterval; j++) {\n        value = this.findLogNumeric(axis, logPosition, value, labelIndex, isFirstLabel);\n        logPosition += logInterval;\n        if (inside(value, range)) {\n          position = (value - range.min) / (range.max - range.min);\n          position = Math.ceil((isInverse ? 1 - position : position) * rect.width);\n          coor = Math.floor(position + rect.x);\n          if (this.chart.enableCanvas) {\n            if (minorGird === '') {\n              minorGird = 'M ' + coor + ' ' + this.seriesClipRect.y + ' L ' + coor + ' ' + (this.seriesClipRect.y + this.seriesClipRect.height);\n            } else {\n              minorGird = minorGird + ' M ' + coor + ' ' + this.seriesClipRect.y + ' L ' + coor + ' ' + (this.seriesClipRect.y + this.seriesClipRect.height);\n            }\n            coor = Math.floor(position + rect.x);\n            if (minorTick === '') {\n              minorTick = minorTick.concat('M' + ' ' + coor + ' ' + rect.y + ' L ' + coor + ' ' + (ticksX + axis.scrollBarHeight));\n            } else {\n              minorTick = minorTick.concat(' M' + ' ' + coor + ' ' + rect.y + ' L ' + coor + ' ' + (ticksX + axis.scrollBarHeight));\n            }\n          } else {\n            minorGird = minorGird.concat('M' + ' ' + coor + ' ' + this.seriesClipRect.y + 'L ' + coor + ' ' + (this.seriesClipRect.y + this.seriesClipRect.height));\n            coor = Math.floor(position + rect.x);\n            minorTick = minorTick.concat('M' + ' ' + coor + ' ' + rect.y + 'L ' + coor + ' ' + (ticksX + axis.scrollBarHeight));\n          }\n        }\n      }\n    } else {\n      for (var j = 0; j < axis.minorTicksPerInterval; j++) {\n        value = this.findLogNumeric(axis, logPosition, value, labelIndex, isFirstLabel);\n        if (inside(value, range)) {\n          position = (value - range.min) / (range.max - range.min);\n          position = Math.ceil((isInverse ? 1 - position : position) * rect.height) * -1; // For inversed axis\n          coor = Math.floor(position + rect.y + rect.height);\n          if (this.chart.enableCanvas) {\n            if (minorGird === '') {\n              minorGird = 'M ' + this.seriesClipRect.x + ' ' + coor + ' L ' + (this.seriesClipRect.x + this.seriesClipRect.width) + ' ' + coor;\n            } else {\n              minorGird = minorGird + ' M ' + this.seriesClipRect.x + ' ' + coor + ' L ' + (this.seriesClipRect.x + this.seriesClipRect.width) + ' ' + coor;\n            }\n            coor = Math.floor(position + rect.y + rect.height);\n            if (minorTick === '') {\n              minorTick = minorTick.concat('M' + ' ' + rect.x + ' ' + coor + ' L ' + (ticksY - axis.scrollBarHeight) + ' ' + coor + ' ');\n            } else {\n              minorTick = minorTick.concat(' M' + ' ' + rect.x + ' ' + coor + ' L ' + (ticksY - axis.scrollBarHeight) + ' ' + coor + ' ');\n            }\n          } else {\n            minorGird = minorGird.concat('M' + ' ' + this.seriesClipRect.x + ' ' + coor + 'L ' + (this.seriesClipRect.x + this.seriesClipRect.width) + ' ' + coor + ' ');\n            coor = Math.floor(position + rect.y + rect.height);\n            minorTick = minorTick.concat('M' + ' ' + rect.x + ' ' + coor + 'L ' + (ticksY - axis.scrollBarHeight) + ' ' + coor + ' ');\n          }\n        }\n        logPosition += logInterval;\n      }\n    }\n    direction.push(minorGird);\n    direction.push(minorTick);\n    return direction;\n  };\n  /**\n   * To find the numeric value of the log\n   *\n   * @param {Axis} axis axis\n   * @param {number} logPosition logPosition\n   * @param {number} value value\n   * @param {number} labelIndex labelIndex\n   * @param {boolean} isFirstLabel isFirstLabel\n   * @returns {number} value\n   */\n  CartesianAxisLayoutPanel.prototype.findLogNumeric = function (axis, logPosition, value, labelIndex, isFirstLabel) {\n    var range = axis.visibleRange;\n    var tempValue;\n    if (axis.valueType === 'Logarithmic') {\n      value = logBase(logPosition, axis.logBase);\n    } else if (axis.valueType === 'DateTime') {\n      tempValue = axis.dateTimeInterval / (axis.minorTicksPerInterval + 1);\n      value = isFirstLabel ? value - tempValue : value + tempValue;\n    } else if (axis.valueType === 'DateTimeCategory') {\n      var padding = axis.labelPlacement === 'BetweenTicks' ? 0.5 : 0;\n      value += ((axis.visibleLabels[labelIndex + 1] ? axis.visibleLabels[labelIndex + 1].value - padding : axis.visibleRange.max) - (axis.visibleLabels[labelIndex] ? axis.visibleLabels[labelIndex].value - padding : axis.visibleRange.min)) / (axis.minorTicksPerInterval + 1);\n    } else {\n      tempValue = range.interval / (axis.minorTicksPerInterval + 1);\n      value = isFirstLabel ? value - tempValue : value + tempValue;\n    }\n    return value;\n  };\n  /**\n   * To render the xAxis Labels\n   *\n   * @param {Axis} axis axis\n   * @param {number} index index\n   * @param {Element} parent parent\n   * @param {Rect} rect rect\n   * @returns {void}\n   * @private\n   */\n  CartesianAxisLayoutPanel.prototype.drawXAxisLabels = function (axis, index, parent, rect) {\n    var chart = this.chart;\n    var pointX = 0;\n    var pointY = 0;\n    var previousLabel = 0;\n    var labelSpace = axis.labelPadding;\n    var labelHeight;\n    var elementSize;\n    var labelPadding;\n    var anchor;\n    var pixel = 10;\n    var labelElement = chart.renderer.createGroup({\n      id: chart.element.id + 'AxisLabels' + index\n    });\n    var islabelInside = axis.labelPosition === 'Inside';\n    var isOpposed = axis.isAxisOpposedPosition;\n    var tickSpace = axis.labelPosition === axis.tickPosition ? axis.majorTickLines.height : 0;\n    var padding = tickSpace + labelSpace + axis.lineStyle.width * 0.5;\n    var angle = axis.angle % 360;\n    var isHorizontalAngle = angle === 0 || angle === -180 || angle === 180;\n    var options;\n    var labelWidth;\n    var isInverse = axis.isAxisInverse;\n    var isLeft;\n    var count = 1;\n    var previousEnd = isInverse ? rect.x + rect.width : rect.x;\n    var width = 0;\n    var length = axis.visibleLabels.length;\n    var intervalLength;\n    var label;\n    var isAxisBreakLabel;\n    var scrollBarHeight = axis.scrollbarSettings.enable || !islabelInside && isNullOrUndefined(axis.crossesAt) && (axis.zoomFactor < 1 || axis.zoomPosition > 0) ? axis.scrollbarSettings.position === 'Top' || axis.scrollbarSettings.position === 'Bottom' ? 0 : axis.scrollBarHeight : 0;\n    var newPoints = [];\n    var isRotatedLabelIntersect = false;\n    var textPoints = [];\n    var rotatedLabelSize = new Size(0, 0);\n    padding += angle === 90 || angle === 270 || angle === -90 || angle === -270 ? islabelInside ? 5 : -5 : 0;\n    var isLabelUnderAxisLine = !isOpposed && !islabelInside || isOpposed && islabelInside;\n    var axislabelElement = getElement(chart.element.id + 'AxisLabels' + index);\n    var pointsRemoved = this.removeAxisLabelElements(axis, axislabelElement);\n    var legendWidth = chart.legendModule && chart.legendSettings.position === 'Right' && chart.legendModule.legendBounds.height + chart.legendModule.legendBounds.y >= axis.rect.y ? chart.legendModule.legendBounds.width : 0;\n    var isEndAnchor = isLabelUnderAxisLine ? 360 >= angle && angle >= 180 || -1 >= angle && angle >= -180 : 1 <= angle && angle <= 180 || -181 >= angle && angle >= -360;\n    for (var i = 0, len = length; i < len; i++) {\n      label = axis.visibleLabels[i];\n      isAxisBreakLabel = isBreakLabel(label.originalText) || axis.labelIntersectAction === 'Wrap' && label.text.length > 1;\n      pointX = valueToCoefficient(label.value, axis) * rect.width + rect.x;\n      elementSize = label.size;\n      if (axis.enableWrap) {\n        elementSize.height = measureText(label.text, axis.labelStyle, chart.themeStyle.axisLabelFont).height;\n      }\n      intervalLength = rect.width / length;\n      labelWidth = isAxisBreakLabel ? label.breakLabelSize.width : elementSize.width;\n      width = (axis.labelIntersectAction === 'Trim' || axis.labelIntersectAction === 'Wrap') && angle === 0 && labelWidth > intervalLength ? intervalLength : labelWidth;\n      labelHeight = elementSize.height / 4;\n      pointX -= isAxisBreakLabel || angle !== 0 ? 0 : width / 2;\n      // label X value adjustment for label rotation (Start)\n      if (angle !== 0) {\n        if (isAxisBreakLabel) {\n          pointX -= axis.lineBreakAlignment === 'Left' ? label.breakLabelSize.width / 2 : axis.lineBreakAlignment === 'Right' ? -(label.breakLabelSize.width / 2) : 0;\n        } else {\n          pointX -= angle === -90 || angle === 270 ? -labelHeight : angle === 90 || angle === -270 ? labelHeight : 0;\n        }\n      }\n      // label X value adjustment for label rotation (End)\n      if (axis.labelStyle.textAlignment === 'Far') {\n        pointX = pointX + width - pixel;\n      } else if (axis.labelStyle.textAlignment === 'Near') {\n        pointX = pointX - width + pixel;\n      }\n      // For line break label alignment like left, right & center in angle 0\n      if (isAxisBreakLabel && axis.lineBreakAlignment !== 'Center' && angle === 0) {\n        pointX += axis.lineBreakAlignment === 'Left' ? -(width / 2) : width / 2;\n      }\n      var paddingForBreakLabel = isAxisBreakLabel ? isHorizontalAngle ? axis.opposedPosition || islabelInside ? 0 : elementSize.height : label.breakLabelSize.width / 2 : 0;\n      padding = isAxisBreakLabel ? tickSpace + labelSpace + axis.lineStyle.width * 0.5 : padding;\n      // label Y value adjustment (Start)\n      if (islabelInside && angle) {\n        if (isAxisBreakLabel) {\n          pointY = isOpposed ? rect.y + padding + paddingForBreakLabel : rect.y - padding - paddingForBreakLabel;\n        } else {\n          pointY = isOpposed ? rect.y + padding + labelHeight : rect.y - padding - labelHeight;\n        }\n      } else {\n        if (isAxisBreakLabel) {\n          labelPadding = !isLabelUnderAxisLine ? -(padding + scrollBarHeight + paddingForBreakLabel) : padding + scrollBarHeight + (angle ? paddingForBreakLabel : 3 * labelHeight);\n        } else {\n          labelPadding = !isLabelUnderAxisLine ? -(padding + scrollBarHeight + (angle ? labelHeight : label.index > 1 ? 2 * labelHeight : 0)) : padding + scrollBarHeight + (angle ? 1 : 3) * labelHeight;\n        }\n        pointY = rect.y + labelPadding * label.index;\n      }\n      // label Y value adjustment (End)\n      if (isAxisBreakLabel) {\n        anchor = this.getAnchor(axis); // for break label self alignment\n      } else {\n        anchor = chart.enableRtl ? isEndAnchor ? '' : 'end' : chart.isRtlEnabled || isEndAnchor ? 'end' : 'start';\n      }\n      options = new TextOption(chart.element.id + index + '_AxisLabel_' + i, pointX, pointY, anchor);\n      options.id = pointsRemoved && axislabelElement && axislabelElement.children[i] ? axislabelElement.children[i].id : options.id;\n      if (angle !== 0) {\n        rotatedLabelSize = rotateTextSize(label.labelStyle, label.originalText, angle, chart, chart.themeStyle.axisLabelFont);\n        isLeft = angle < 0 && angle > -90 || angle < -180 && angle > -270 || angle > 90 && angle < 180 || angle > 270 && angle < 360;\n      }\n      if (axis.edgeLabelPlacement) {\n        switch (axis.edgeLabelPlacement) {\n          case 'None':\n            break;\n          case 'Hide':\n            if ((i === 0 || isInverse && i === len - 1) && options.x < rect.x || (i === len - 1 || isInverse && i === 0) && options.x + (angle === 0 ? width : rotatedLabelSize.width) > rect.x + rect.width) {\n              continue;\n            }\n            break;\n          case 'Shift':\n            if (i === len - 2 && axis.labelIntersectAction !== 'MultipleRows') {\n              if (anchor === 'start' || anchor === '') {\n                previousLabel = options.x + width; // For start anchor\n              } else if (anchor === 'middle') {\n                previousLabel = options.x + width / 2; // For middle anchor\n              } else {\n                previousLabel = options.x; // For end anchor\n              }\n            }\n            if ((i === 0 || isInverse && i === len - 1) && (options.x < rect.x || angle !== 0 && isLeft && options.x < rect.x || axis.lineBreakAlignment === 'Center' && options.x - label.size.width / label.text.length / 2 < rect.x && angle === 0)) {\n              intervalLength -= rect.x - options.x;\n              if (anchor === '' || anchor === 'start') {\n                if (options.x <= 0) {\n                  pointX = options.x = 0;\n                } else {\n                  pointX = options.x;\n                }\n                intervalLength = rect.width / length;\n              } else if (isLeft && angle !== 0) {\n                intervalLength = rect.width / length;\n                if (rect.x + intervalLength > options.x + rotatedLabelSize.width) {\n                  options.x = pointX = rect.x + padding;\n                } else {\n                  options.x = pointX = rect.x + intervalLength - padding;\n                }\n              } else if (isAxisBreakLabel && axis.lineBreakAlignment === 'Center' && axis.labelPlacement === 'OnTicks' && angle === 0) {\n                var maxWidth = 0;\n                for (var i_1 = 0; i_1 < label.text.length; i_1++) {\n                  var breakLabelWidth = measureText(label.text[i_1], axis.labelStyle, chart.themeStyle.axisLabelFont).width;\n                  if (breakLabelWidth > maxWidth) {\n                    maxWidth = breakLabelWidth;\n                  }\n                }\n                options.x = pointX = rect.x + maxWidth / 2;\n              } else if (!(anchor === 'start' && options.x > 0)) {\n                options.x = pointX = !isHorizontalAngle ? rect.x + padding : rect.x;\n              }\n            } else if ((i === len - 1 || isInverse && i === 0) && (options.x + width > chart.availableSize.width - chart.border.width - legendWidth && (anchor === 'start' || anchor === '') && angle === 0 || anchor === '' && angle !== 0 && !isLeft && options.x + rotatedLabelSize.width > chart.availableSize.width - chart.border.width - legendWidth || anchor === 'middle' && angle !== 0 && !isLeft && options.x + rotatedLabelSize.width / 2 > chart.availableSize.width - chart.border.width - legendWidth || anchor === 'end' && angle !== 0 && !isLeft && options.x > chart.availableSize.width - chart.border.width - legendWidth || anchor === 'end' && options.x > chart.availableSize.width - chart.border.width - legendWidth && angle === 0 || anchor === 'middle' && options.x + width / 2 > chart.availableSize.width - chart.border.width - legendWidth && angle === 0)) {\n              var axisLabelWidth = angle !== 0 ? rotatedLabelSize.width : width;\n              var shiftedXValue = void 0;\n              //Apply a default 5px padding between the edge label and the chart container\n              var padding_1 = 5;\n              if (anchor === 'start' || anchor === '') {\n                shiftedXValue = options.x - (options.x + axisLabelWidth - chart.availableSize.width + chart.border.width + padding_1 + legendWidth);\n              } else if (anchor === 'middle') {\n                shiftedXValue = options.x - (options.x + axisLabelWidth / 2 - chart.availableSize.width + chart.border.width + padding_1 + legendWidth);\n              } else {\n                shiftedXValue = options.x - (options.x - (chart.availableSize.width + chart.border.width + padding_1 + legendWidth));\n              }\n              // Check for overlap with previous label\n              if (previousLabel !== 0 && shiftedXValue < previousLabel) {\n                var maxAvailableWidth = chart.availableSize.width - previousLabel;\n                label.text = textTrim(maxAvailableWidth, label.originalText, axis.labelStyle, chart.isRtlEnabled, chart.themeStyle.axisLabelFont);\n              } else {\n                options.x = pointX = shiftedXValue;\n              }\n            }\n            break;\n        }\n      }\n      options.text = this.getLabelText(label, axis, intervalLength);\n      options.labelRotation = angle;\n      // ------- Hide Calculation (Start) -------------\n      // Currect label actual start value (Start)\n      var xValue = void 0;\n      var xValue2 = void 0;\n      if (isAxisBreakLabel && angle === 0) {\n        if (axis.lineBreakAlignment === 'Right') {\n          xValue = options.x - width;\n          xValue2 = options.x;\n        } else if (axis.lineBreakAlignment === 'Center') {\n          xValue = options.x - width / 2;\n          xValue2 = options.x + width / 2;\n        } else {\n          xValue = options.x;\n          xValue2 = options.x + width;\n        }\n      } else {\n        xValue = options.x;\n        xValue2 = options.x + width;\n      }\n      // Currect label actual start value (End)\n      if (angle === 0 && axis.labelIntersectAction === 'Hide' && i !== 0 && (!isInverse ? xValue <= previousEnd : xValue2 >= previousEnd)) {\n        continue;\n      }\n      // Previous label actual end value (Start)\n      if (isAxisBreakLabel) {\n        if (axis.lineBreakAlignment === 'Right') {\n          previousEnd = isInverse ? options.x - width : options.x;\n        } else if (axis.lineBreakAlignment === 'Center') {\n          previousEnd = isInverse ? options.x - width / 2 : options.x + width / 2;\n        } else {\n          previousEnd = isInverse ? options.x : options.x + width;\n        }\n      } else {\n        previousEnd = isInverse ? options.x : options.x + width;\n      }\n      // Previous label actual end value (End)\n      // ------- Hide Calculation (End) -------------\n      // label Rotataion calculation (Start)\n      if (angle !== 0) {\n        var height = void 0;\n        var rect_1 = void 0;\n        if (isAxisBreakLabel) {\n          var xAdjustment = 0;\n          var yAdjustment = 0;\n          height = label.breakLabelSize.height;\n          yAdjustment = label.breakLabelSize.height - 4; // 4 for label bound correction\n          // xAdjustment (Start)\n          if (axis.lineBreakAlignment === 'Center') {\n            xAdjustment = -(label.breakLabelSize.width / 2);\n          } else if (axis.lineBreakAlignment === 'Right') {\n            xAdjustment = -label.breakLabelSize.width;\n          }\n          // xAdjustment (End)\n          if (isLabelUnderAxisLine) {\n            yAdjustment = label.breakLabelSize.height / (options.text.length + 1);\n          }\n          rect_1 = new Rect(options.x + xAdjustment, options.y - yAdjustment, label.breakLabelSize.width, height);\n        } else {\n          height = pointY - (options.y - label.size.height / 2);\n          rect_1 = new Rect(options.x, options.y - (label.size.height / 2 - 5), label.size.width, height);\n        }\n        var rectCoordinates = this.getRectanglePoints(rect_1);\n        var rectCenterX = isAxisBreakLabel ? rect_1.x + rect_1.width / 2 : pointX;\n        var rectCenterY = isAxisBreakLabel ? rect_1.y + rect_1.height / 2 : pointY - height / 2;\n        if (isAxisBreakLabel) {\n          options.transform = 'rotate(' + angle + ',' + rectCenterX + ',' + rectCenterY + ')';\n        } else {\n          options.transform = 'rotate(' + angle + ',' + pointX + ',' + pointY + ')';\n        }\n        newPoints.push(getRotatedRectangleCoordinates(rectCoordinates, rectCenterX, rectCenterY, angle));\n        isRotatedLabelIntersect = false;\n        if (axis.labelIntersectAction !== 'None') {\n          for (var index_1 = i; index_1 > 0; index_1--) {\n            if (newPoints[i] && newPoints[index_1 - 1] && isRotatedRectIntersect(newPoints[i], newPoints[index_1 - 1])) {\n              isRotatedLabelIntersect = true;\n              newPoints[i] = null;\n              break;\n            }\n          }\n        }\n        var rotateAngle = angle > 0 && angle < 90 || angle > 180 && angle < 270 || angle < -90 && angle > -180 || angle < -270 && angle > -360;\n        var textRect = new Rect(options.x, options.y - (elementSize.height / 2 + padding / 2), label.size.width, height);\n        var textRectCoordinates = this.getRectanglePoints(textRect);\n        var rectPoints = [];\n        rectPoints.push(new ChartLocation(rotateAngle ? this.chart.availableSize.width : this.padding, axis.rect.y));\n        rectPoints.push(new ChartLocation(rotateAngle ? this.chart.availableSize.width : this.padding, axis.rect.y + axis.maxLabelSize.height));\n        textPoints.push(getRotatedRectangleCoordinates(textRectCoordinates, rectCenterX, rectCenterY, angle));\n        var newRect = new Rect(0, axis.rect.y, this.chart.availableSize.width, axis.maxLabelSize.height * 2);\n        for (var k = 0; k < textPoints[i].length; k++) {\n          if (!axis.opposedPosition && !withInBounds(textPoints[i][k].x, textPoints[i][k].y, newRect) && typeof options.text === 'string') {\n            var interSectPoint = this.calculateIntersection(textPoints[i][0], textPoints[i][1], rectPoints[0], rectPoints[1]);\n            var rectPoint1 = rotateAngle ? this.chart.availableSize.width - pointX : pointX;\n            var rectPoint2 = interSectPoint.y - axis.rect.y;\n            var trimValue = Math.sqrt(rectPoint1 * rectPoint1 + rectPoint2 * rectPoint2);\n            options.text = textTrim(trimValue, label.text, label.labelStyle, chart.enableRtl, chart.themeStyle.axisLabelFont);\n          }\n        }\n      }\n      if (this.chart.redraw && (chart.pointsAdded && !chart.pointsRemoved || this.chart.zoomRedraw) && !getElement(options.id) && i !== 0 && !this.chart.enableCanvas && axis.visible) {\n        var optionsX = options.x;\n        options.x = this.seriesClipRect.x + (chart.enableRtl !== axis.isInversed ? -(this.seriesClipRect.width / (i ? i : 1) * count) : this.seriesClipRect.width + this.seriesClipRect.width / (i ? i : 1) * count);\n        var transform = options.transform;\n        options.transform = angle ? 'rotate(' + angle + ',' + options.x + ',' + parseFloat(options.transform.split(',')[2]) + ')' : '';\n        var element_1 = textElement(chart.renderer, options, label.labelStyle, label.labelStyle.color || chart.themeStyle.axisLabelFont.color, labelElement, axis.isAxisOpposedPosition !== (axis.labelPosition === 'Inside'), chart.redraw, true, null, chart.duration, null, label.size, isRotatedLabelIntersect, chart.enableCanvas, null, chart.themeStyle.axisLabelFont);\n        this.rangeAnimate(axis, element_1, this.chart.duration, true, new Rect(this.seriesClipRect.x, axis.rect.y, this.seriesClipRect.x + this.seriesClipRect.width, this.chart.availableSize.height), false, i);\n        options.x = optionsX;\n        options.transform = transform;\n        count += 1;\n      }\n      // label Rotataion calculation (End)\n      var element = textElement(chart.renderer, options, label.labelStyle, label.labelStyle.color || chart.themeStyle.axisLabelFont.color, labelElement, axis.isAxisOpposedPosition !== (axis.labelPosition === 'Inside'), chart.redraw, true, null, chart.duration, null, label.size, isRotatedLabelIntersect, chart.enableCanvas, null, chart.themeStyle.axisLabelFont, new ChartLocation(parseFloat(options.transform.split(',')[1]), parseFloat(options.transform.split(',')[2])));\n      if (pointsRemoved) {\n        element.id = chart.element.id + index + '_AxisLabel_' + i;\n      }\n    }\n    if (this.previousXLabel && length && this.previousXLabel > length && !this.chart.enableCanvas && axis.visible && this.chart.zoomRedraw && this.chart.redraw && options.text) {\n      for (var i = length; i < this.previousXLabel; i++) {\n        options.x = this.seriesClipRect.x + (chart.enableRtl !== axis.isInversed ? -(this.seriesClipRect.width / length * (i - length + 1)) : this.seriesClipRect.width + this.seriesClipRect.width / length * (i - length + 1));\n        options.id = chart.element.id + index + '_AxisLabel_' + i;\n        options.transform = angle ? 'rotate(' + angle + ',' + options.x + ',' + parseFloat(options.transform.split(',')[2]) + ')' : '';\n        this.updateAxisElement(axis, index, '', i, '_AxisLabel_', labelElement, true, options, label);\n      }\n    } else {\n      this.previousXLabel = length;\n    }\n    if (!this.chart.enableCanvas) {\n      if (!chart.delayRedraw) {\n        parent.appendChild(labelElement);\n      } else if (axis.visible && axis.internalVisibility) {\n        this.createZoomingLabel(this.chart, labelElement, axis, index, rect);\n      }\n    }\n  };\n  /**\n   * To render the axis grid, tick lines and label\n   *\n   * @param {Axis} axis axis\n   * @param {number} index index\n   * @param {string} gridDirection gridDirection\n   * @param {number} i index of the element\n   * @param {string} elementId elementId\n   * @param {Element} parentElement parent\n   * @param {boolean} isRemove isRemoved\n   * @param {TextOption} option - The options for the text element.\n   * @param {VisibleLabels} label - Label.\n   * @returns {void}\n   */\n  CartesianAxisLayoutPanel.prototype.updateAxisElement = function (axis, index, gridDirection, i, elementId, parentElement, isRemove, option, label) {\n    var element;\n    var isGrid = elementId.indexOf('Grid') > -1;\n    var isLabel = elementId.indexOf('Label') > -1;\n    if (isLabel) {\n      element = textElement(this.chart.renderer, option, label.labelStyle, label.labelStyle.color || this.chart.themeStyle.axisLabelFont.color, parentElement, axis.isAxisOpposedPosition !== (axis.labelPosition === 'Inside'), this.chart.redraw, true, null, this.chart.duration, null, null, null, this.chart.enableCanvas, null, this.chart.themeStyle.axisLabelFont);\n    } else {\n      this.renderGridLine(axis, index, gridDirection, isGrid ? axis.majorGridLines : axis.majorTickLines, elementId, i, this.element, isGrid ? this.chart.themeStyle.majorGridLine : this.chart.themeStyle.majorTickLine, isGrid ? axis.majorGridLines.dashArray : null);\n      if (this.element && parentElement.childNodes) {\n        element = this.element.childNodes[parentElement.childNodes.length - 1];\n      }\n    }\n    this.rangeAnimate(axis, element, this.chart.duration, isLabel, new Rect(axis.orientation === 'Vertical' ? 0 : this.seriesClipRect.x, axis.orientation === 'Vertical' ? this.seriesClipRect.y : axis.rect.y, this.seriesClipRect.width, this.seriesClipRect.height), isRemove, i);\n  };\n  CartesianAxisLayoutPanel.prototype.removeAxisLabelElements = function (axis, axislabelElement) {\n    if (this.chart.pointsRemoved && axislabelElement && axislabelElement.childNodes.length) {\n      var pointsRemoved = false;\n      if (axis.valueType.indexOf('Category') > -1) {\n        var visibleLabelTexts_1 = [];\n        axis.visibleLabels.map(function (label) {\n          if (typeof label.text !== 'string') {\n            visibleLabelTexts_1.push(label.text.join(''));\n          } else {\n            visibleLabelTexts_1.push(label.text);\n          }\n        });\n        for (var i = axislabelElement.childNodes.length - 1; i >= 0; i--) {\n          var childNode = axislabelElement.childNodes[i];\n          if (visibleLabelTexts_1.indexOf(childNode.textContent.trim()) === -1) {\n            axislabelElement.removeChild(childNode);\n            pointsRemoved = true;\n          }\n        }\n      } else if (axislabelElement.childNodes.length > axis.visibleLabels.length) {\n        for (var j = 0; j < axislabelElement.childNodes.length - axis.visibleLabels.length; j++) {\n          axislabelElement.removeChild(axislabelElement.childNodes[j]);\n          pointsRemoved = true;\n        }\n      }\n      return pointsRemoved;\n    }\n    return false;\n  };\n  CartesianAxisLayoutPanel.prototype.calculateIntersection = function (p1, p2, p3, p4) {\n    var c2x = p3.x - p4.x;\n    var c3x = p1.x - p2.x;\n    var c2y = p3.y - p4.y;\n    var c3y = p1.y - p2.y;\n    var d = c3x * c2y - c3y * c2x;\n    var u1 = p1.x * p2.y - p1.y * p2.x;\n    var u4 = p3.x * p4.y - p3.y * p4.x;\n    var px = (u1 * c2x - c3x * u4) / d;\n    var py = (u1 * c2y - c3y * u4) / d;\n    var p = {\n      x: px,\n      y: py\n    };\n    return p;\n  };\n  /**\n   * To get text anchor value for line break labels.\n   *\n   * @param {Axis} axis axis model\n   * @returns {string} returns text anchor\n   */\n  CartesianAxisLayoutPanel.prototype.getAnchor = function (axis) {\n    return axis.lineBreakAlignment === 'Center' ? 'middle' : this.chart.enableRtl ? axis.lineBreakAlignment === 'Left' ? 'end' : 'start' : axis.lineBreakAlignment === 'Left' ? 'start' : 'end';\n  };\n  /**\n   * Get rect coordinates\n   *\n   * @param {Rect} rect rect\n   * @returns {ChartLocation[]} rectangle points\n   */\n  CartesianAxisLayoutPanel.prototype.getRectanglePoints = function (rect) {\n    var point1 = new ChartLocation(rect.x, rect.y);\n    var point2 = new ChartLocation(rect.x + rect.width, rect.y);\n    var point3 = new ChartLocation(rect.x + rect.width, rect.y + rect.height);\n    var point4 = new ChartLocation(rect.x, rect.y + rect.height);\n    return [point1, point2, point3, point4];\n  };\n  /**\n   * To get axis label text\n   *\n   * @param {VisibleLabels} label label\n   * @param {Axis} axis axis\n   * @param {number} intervalLength intervalLength\n   * @returns {string | string[]} label or label collection\n   */\n  CartesianAxisLayoutPanel.prototype.getLabelText = function (label, axis, intervalLength) {\n    if (isBreakLabel(label.originalText)) {\n      var result = [];\n      var str = void 0;\n      for (var index = 0; index < label.text.length; index++) {\n        str = this.findAxisLabel(axis, label.text[index], intervalLength);\n        result.push(str);\n      }\n      return result;\n    } else {\n      return this.findAxisLabel(axis, label.text, intervalLength);\n    }\n  };\n  /**\n   * To render the x-axis label border.\n   *\n   * @param {Axis} axis axis\n   * @param {number} index index\n   * @param {Element} parent parent\n   * @param {Rect} axisRect axisRect\n   * @returns {void}\n   */\n  CartesianAxisLayoutPanel.prototype.drawXAxisBorder = function (axis, index, parent, axisRect) {\n    if (axis.border.width > 0) {\n      var scrollBarHeight = axis.labelPosition === 'Outside' && axis.scrollbarSettings.position !== 'Top' && axis.scrollbarSettings.position !== 'Bottom' ? axis.scrollBarHeight : 0;\n      var isOpposed = axis.isAxisOpposedPosition;\n      var startX = void 0;\n      var startY = axisRect.y + (isOpposed ? -1 : 1) * scrollBarHeight;\n      var padding = 10;\n      var pointX = void 0;\n      var gap = axisRect.width / axis.visibleRange.delta * (axis.valueType === 'DateTime' ? axis.dateTimeInterval : axis.visibleRange.interval);\n      var endX = void 0;\n      var length_2 = axis.maxLabelSize.height + (axis.tickPosition === axis.labelPosition ? axis.majorTickLines.height : 0);\n      var labelBorder = '';\n      var ticksbwtLabel = axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks' ? -0.5 : 0;\n      var endY = isOpposed && axis.labelPosition === 'Inside' || !isOpposed && axis.labelPosition === 'Outside' ? axisRect.y + length_2 + padding + scrollBarHeight : axisRect.y - length_2 - padding - scrollBarHeight;\n      for (var i = 0, len = axis.visibleLabels.length; i < len; i++) {\n        pointX = valueToCoefficient(axis.visibleLabels[i].value + ticksbwtLabel, axis);\n        pointX = (axis.isAxisInverse ? 1 - pointX : pointX) * axisRect.width;\n        if (axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks') {\n          startX = pointX + axisRect.x;\n          endX = pointX + gap + axisRect.x;\n        } else {\n          startX = pointX - gap * 0.5 + axisRect.x;\n          endX = pointX + gap * 0.5 + axisRect.x;\n        }\n        switch (axis.border.type) {\n          case 'Rectangle':\n          case 'WithoutTopBorder':\n            if (startX < axisRect.x && axis.labelPlacement !== 'OnTicks') {\n              labelBorder += 'M' + ' ' + axisRect.x + ' ' + endY + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ';\n            } else if (Math.floor(endX) > axisRect.width + axisRect.x && !(axis.visibleLabels.length === 1) && !(i === axis.visibleLabels.length - 1)) {\n              labelBorder += 'M' + ' ' + startX + ' ' + startY + ' ' + 'L' + ' ' + startX + ' ' + endY + ' ' + 'L' + ' ' + (axisRect.width + axisRect.x) + ' ' + endY + ' ';\n            } else {\n              startX = i === 0 && axis.labelPlacement === 'OnTicks' ? axisRect.x : startX;\n              endX = i === axis.visibleLabels.length - 1 && axis.labelPlacement === 'OnTicks' ? endX - gap * 0.5 : endX;\n              labelBorder += 'M' + ' ' + startX + ' ' + startY + ' ' + 'L' + ' ' + startX + ' ' + endY + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ';\n              if (i === 0) {\n                labelBorder += 'M' + ' ' + startX + ' ' + startY + ' ' + 'L' + ' ' + startX + ' ' + endY + ' ' + 'M ' + startX + ' ' + endY + ' L ' + axisRect.x + ' ' + endY;\n              }\n              if (i === axis.visibleLabels.length - 1) {\n                labelBorder += 'M' + ' ' + endX + ' ' + startY + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ' + 'M ' + endX + ' ' + endY + ' L ' + (axisRect.width + axisRect.x) + ' ' + endY;\n              }\n            }\n            break;\n          case 'WithoutTopandBottomBorder':\n            if (!(startX < axisRect.x) && !(Math.floor(endX) > axisRect.width + axisRect.x)) {\n              labelBorder += 'M' + ' ' + startX + ' ' + startY + ' ' + 'L' + ' ' + startX + ' ' + endY + ' ' + 'M ' + endX + ' ' + startY + ' L ' + endX + ' ' + endY;\n            }\n            break;\n        }\n      }\n      labelBorder += axis.border.type === 'Rectangle' ? 'M ' + ' ' + axisRect.x + ' ' + startY + 'L' + ' ' + (axisRect.x + axisRect.width) + ' ' + startY : '';\n      if (labelBorder !== '') {\n        this.createAxisBorderElement(axis, index, labelBorder, parent);\n      }\n    }\n    for (var i = 0; i < this.chart.visibleSeries.length; i++) {\n      if (this.chart.multiLevelLabelModule && axis.multiLevelLabels.length > 0 && this.chart.visibleSeries[i].visible) {\n        this.chart.multiLevelLabelModule.renderXAxisMultiLevelLabels(axis, index, parent, axisRect);\n        break;\n      }\n    }\n  };\n  /**\n   * To create border element of the axis\n   *\n   * @param {Axis} axis axis\n   * @param {number} index index\n   * @param {string} labelBorder labelBorder\n   * @param {Element} parent parent\n   * @returns {void}\n   */\n  CartesianAxisLayoutPanel.prototype.createAxisBorderElement = function (axis, index, labelBorder, parent) {\n    var element = getElement(this.chart.element.id + '_BorderLine_' + index);\n    var direction = element ? element.getAttribute('d') : '';\n    var borderElement = this.chart.renderer.drawPath(new PathOption(this.chart.element.id + '_BorderLine_' + index, 'transparent', axis.border.width, axis.border.color || this.chart.themeStyle.axisLine, 1, '', labelBorder));\n    borderElement.style.pointerEvents = 'none';\n    appendChildElement(this.chart.enableCanvas, parent, borderElement, this.chart.redraw, false, 'x', 'y', null, direction, true, null, null, this.chart.duration);\n  };\n  /**\n   * To find the axis label of the intersect action\n   *\n   * @param {Axis} axis axis\n   * @param {string} label label\n   * @param {number} width width\n   * @returns {string} label\n   */\n  CartesianAxisLayoutPanel.prototype.findAxisLabel = function (axis, label, width) {\n    return axis.labelIntersectAction === 'Trim' ? axis.angle % 360 === 0 && !axis.enableTrim ? textTrim(width, label, axis.labelStyle, this.chart.enableRtl, this.chart.themeStyle.axisLabelFont) : label : label;\n  };\n  /**\n   * X-Axis Title function performed\n   *\n   * @param {Axis} axis axis\n   * @param {number} index index\n   * @param {Element} parent parent\n   * @param {Rect} rect rect\n   * @returns {void}\n   */\n  CartesianAxisLayoutPanel.prototype.drawXAxisTitle = function (axis, index, parent, rect) {\n    if (axis.title) {\n      var chart = this.chart;\n      var elementSize = measureText(axis.title, axis.titleStyle, this.chart.themeStyle.axisTitleFont);\n      var scrollBarHeight = isNullOrUndefined(axis.crossesAt) && axis.scrollbarSettings.position !== 'Top' && axis.scrollbarSettings.position !== 'Bottom' ? axis.scrollBarHeight : 0;\n      var padding = (axis.tickPosition === 'Inside' ? 0 : axis.majorTickLines.height + axis.titlePadding) + (axis.labelPosition === 'Inside' ? 0 : axis.maxLabelSize.height + axis.multiLevelLabelHeight + axis.labelPadding);\n      padding = axis.tickPosition !== 'Outside' && (axis.tickPosition === 'Inside' || axis.labelPosition === 'Inside') ? axis.titlePadding === 5 ? padding : padding + axis.titlePadding : padding;\n      var titleSize = axis.titleSize.height * (axis.titleCollection.length - 1);\n      padding = axis.isAxisOpposedPosition ? -(padding + elementSize.height / 4 + scrollBarHeight + titleSize) : padding + 3 * elementSize.height / 4 + scrollBarHeight;\n      var labelRotation = axis.titleRotation ? axis.titleRotation : 0;\n      var x = void 0;\n      var y = rect.y + padding;\n      var anchor = void 0;\n      if (axis.titleStyle.textAlignment === 'Center') {\n        anchor = 'middle';\n        x = rect.x + rect.width * 0.5;\n      } else if (axis.titleStyle.textAlignment === 'Near') {\n        anchor = 'start';\n        x = rect.x;\n      } else {\n        anchor = 'end';\n        x = rect.x + rect.width;\n      }\n      if (labelRotation !== 0) {\n        y += axis.opposedPosition ? -(axis.titleSize.height / 2 + elementSize.height / 4) : axis.titleSize.height / 2 - elementSize.height / 4;\n      }\n      var options = new TextOption(chart.element.id + '_AxisTitle_' + index, x, y, anchor, axis.titleCollection, 'rotate(' + labelRotation + ',' + x + ',' + y + ')', null, labelRotation);\n      var element = textElement(chart.renderer, options, axis.titleStyle, axis.titleStyle.color || chart.themeStyle.axisTitleFont.color, parent, null, chart.redraw, chart.redraw, null, null, null, null, null, chart.enableCanvas, null, chart.themeStyle.axisTitleFont, new ChartLocation(x, y));\n      element.setAttribute('aria-hidden', 'true');\n    }\n  };\n  /**\n   * To render the axis grid and tick lines(Both Major and Minor)\n   *\n   * @param {Axis} axis axis\n   * @param {number} index index\n   * @param {string} gridDirection gridDirection\n   * @param {MajorTickLinesModel | MinorTickLinesModel | MajorGridLinesModel | MinorGridLinesModel} gridModel gridModel\n   * @param {string} gridId gridId\n   * @param {number} gridIndex gridIndex\n   * @param {Element} parent parent\n   * @param {string} themeColor themeColor\n   * @param {string} dashArray dashArray\n   * @param {number} removeIndex removeIndex\n   * @param {boolean} isRemoved isRemoved\n   * @returns {void}\n   */\n  CartesianAxisLayoutPanel.prototype.renderGridLine = function (axis, index, gridDirection, gridModel, gridId, gridIndex, parent, themeColor, dashArray, removeIndex, isRemoved) {\n    if (dashArray === void 0) {\n      dashArray = null;\n    }\n    if (removeIndex === void 0) {\n      removeIndex = null;\n    }\n    if (isRemoved === void 0) {\n      isRemoved = false;\n    }\n    var chart = this.chart;\n    var direction;\n    var element;\n    if (gridModel.width > 0 && axis.visible && axis.internalVisibility && gridDirection) {\n      element = getElement(chart.element.id + gridId + index + '_' + (isRemoved ? removeIndex : gridIndex));\n      direction = element ? element.getAttribute('d') : null;\n      element = null;\n      this.htmlObject = chart.renderer.drawPath(new PathOption(chart.element.id + gridId + index + '_' + (isRemoved ? removeIndex : gridIndex), 'transparent', gridModel.width, gridModel.color || themeColor, null, dashArray, gridDirection));\n      appendChildElement(chart.enableCanvas, parent, this.htmlObject, chart.redraw, true, 'x', 'y', null, direction, true, null, null, chart.duration);\n      if (isRemoved) {\n        this.htmlObject.id = chart.element.id + gridId + index + '_' + gridIndex;\n      }\n    }\n  };\n  /**\n   * To Find the parent node of the axis\n   *\n   * @param {string} elementId elementId\n   * @param {Element} label label\n   * @param {number} index index\n   * @returns {Element} parent node of the axis\n   */\n  CartesianAxisLayoutPanel.prototype.findParentNode = function (elementId, label, index) {\n    if (document.getElementById(elementId + 'AxisGroup' + index + 'Inside').contains(document.getElementById(label.id))) {\n      return document.getElementById(elementId + 'AxisGroup' + index + 'Inside');\n    } else {\n      return document.getElementById(elementId + 'AxisGroup' + index + 'Outside');\n    }\n  };\n  /**\n   * Create Zooming Labels Function Called here\n   *\n   * @param {Chart} chart chart\n   * @param {Element} labelElement labelElement\n   * @param {Axis} axis axis\n   * @param {number} index index\n   * @param {Rect} rect rect\n   * @returns {void}\n   */\n  CartesianAxisLayoutPanel.prototype.createZoomingLabel = function (chart, labelElement, axis, index, rect) {\n    var parentNode = this.findParentNode(chart.element.id, labelElement, index);\n    labelElement.setAttribute('opacity', '0.3');\n    var zoomElement = chart.renderer.createGroup({\n      id: chart.element.id + 'AxisLabels_Zoom' + index\n    });\n    zoomElement = createZoomingLabels(chart, axis, zoomElement, index, axis.orientation === 'Vertical', rect);\n    parentNode.replaceChild(labelElement, document.getElementById(labelElement.id));\n    if (getElement(chart.element.id + 'AxisLabels_Zoom' + index)) {\n      parentNode.replaceChild(zoomElement, document.getElementById(zoomElement.id));\n    } else {\n      parentNode.appendChild(zoomElement);\n    }\n  };\n  return CartesianAxisLayoutPanel;\n}();\nexport { CartesianAxisLayoutPanel };","map":{"version":3,"names":["createElement","isNullOrUndefined","Animation","DataUtil","subtractThickness","valueToCoefficient","sum","redrawElement","isBreakLabel","ChartLocation","withInBounds","rotateTextSize","removeElement","calculateScrollbarOffset","subArray","inside","appendChildElement","stringToNumber","Thickness","logBase","createZoomingLabels","getElement","Size","Rect","measureText","TextOption","PathOption","textElement","textTrim","getRotatedRectangleCoordinates","isRotatedRectIntersect","isZoomSet","axisPadding","CartesianAxisLayoutPanel","chartModule","chart","padding","prototype","measureAxis","rect","chartAreaWidth","chartArea","width","availableSize","crossAt","seriesClipRect","x","y","height","initialClipRect","leftSize","rightSize","topSize","bottomSize","measureRowAxis","measureColumnAxis","delayRedraw","calculateAxisSize","calculateFixedChartArea","refreshAxis","margin","right","legendSettings","position","legendModule","legendBounds","_i","_a","rows","length","item","farSizes","row","calculateRowSize","nearSizes","insideNearSizes","insideFarSizes","arrangeAxis","measureDefinition","computedHeight","column","calculateColumnSize","columns","computedWidth","definition","size","ele","axes","axis","scrollbarSettings","scrollBarHeight","scrollBarModule","zoomModule","zoomSettings","enableScrollbar","enableScrollbarOnZooming","isZoomed","zoomFactor","zoomPosition","enable","getModule","baseModule","calculateRangeAndInterval","computeSize","nearCount","farCount","axisOffset","i","len","j","len_1","plotOffset","k","len_2","span","computedTop","plotOffsetTop","getAxisOffsetValue","plotOffsetBottom","isAxisOpposedPosition","labelPosition","orientation","maxLabelSize","multiLevelLabelHeight","tickPosition","majorTickLines","labelPadding","len_3","len_4","computedLeft","plotOffsetLeft","plotOffsetRight","measure","actualIndex","axisCollections","verticalAxes","push","getActualRow","pushAxis","horizontalAxes","getActualColumn","isRTLEnabled","enableRtl","setIsInversedAndOpposedPosition","position1","position2","rangeOffset","crossesAt","crossesInAxis","requireInvertedAxis","crossInAxis","primaryXAxis","primaryYAxis","updateCrossAt","name","valueType","option","skeleton","type","dateParser","intl","getDateParser","dateFormatter","getDateFormat","Date","parse","parseJson","val","parseFloat","labels","indexOf","axisCollection","actualLength","pos","columnIndex","result","rowIndex","rowTop","remainingHeight","Math","max","min","parseInt","columnLeft","remainingWidth","renderAxes","axisElement","renderer","createGroup","id","element","axisLineElement","setAttribute","outsideElement","isInside","topScrollBarCount","bottomScrollBarCount","leftScrollBarCount","rightScrollBarCount","axisVisibility","index","series","yAxisName","xAxisName","visible","category","paretoOptions","showAxis","zoomingScrollBar","removeScrollSvg","findAxisPosition","drawAxis","drawPaneLines","enableCanvas","svgObject","redraw","renderScrollbar","injectTo","isScrollUI","scrollElement","render","destroy","topOffset","lineStyle","leftOffset","style","top","left","border","color","drawBottomLine","appendChild","updateCrossValue","axisName","internalVisibility","drawAxisLine","updatedRect","majorGridLines","minorTickLines","minorGridLines","placeNextToAxisLine","childNodes","visibleRange","isRow","optionsLine","x1","x2","y1","y2","definitionName","htmlObject","drawLine","plotX","plotY","plotBottom","plotTop","plotLeft","plotRight","parent","direction","getAttribute","dashArray","themeStyle","axisLine","drawPath","duration","drawYAxisGridLine","isLogAxis","isCategoryAxis","tempInterval","pointY","majorGrid","majorTick","minorGridDirection","isOpposed","tickSize","axisLineSize","ticksbwtLabel","labelPlacement","isTickInside","ticks","visibleLabels","chartThemeStyle","count","stockChart","value","interval","zoomRedraw","isInversed","updateAxisElement","isBorder","renderGridLine","majorGridLine","majorTickLine","minorTicksPerInterval","renderMinorGridOnZooming","drawAxisMinorLine","minorGridLine","minorTickLine","previousYLabel","pointYValue","start","startIndex","endIndex","drawYAxisLabels","label","pointX","elementSize","labelSpace","options","isAxisBreakLabel","isLabelInside","RotatedWidth","tickSpace","angle","isVerticalAngle","labelElement","textHeight","textPadding","maxLineWidth","pixel","isInverse","isAxisInverse","previousEnd","intervalLength","labelHeight","yAxisLabelX","isLabelOnAxisLineLeft","sizeWidth","breakLabelSizeWidth","map","breakLabelSize","LabelMaxWidth","apply","breakLabelMaxWidth","cos","PI","originalText","floor","text","labelIntersectAction","opposedPosition","labelStyle","textAlignment","enableWrap","edgeLabelPlacement","previousYValue","currentYValue","transform","optionsY","axisLabelFont","createZoomingLabel","rangeAnimate","bounds","isRemove","_this","animate","progress","animateElement","animation","visibility","split","end","previousXLabel","getAxisLabelXvalue","textWidth","anchor","lineBreakAlignment","drawYAxisBorder","startY","gap","delta","dateTimeInterval","endY","length_1","labelBorder","endX","createAxisBorderElement","visibleSeries","multiLevelLabels","multiLevelLabelModule","renderYAxisMultiLevelLabels","drawYAxisTitle","title","isRotated","labelRotation","titleRotation","titlePadding","titleSize","titleStyle","titleCollection","axisTitleFont","drawXAxisGridLine","minorDirection","numericIDs","calculateGridLineId","pointsAdded","pointsRemoved","pointXValue","ids","isPointRemoved","elementTypes","forEach","parentElement","elements","querySelectorAll","elementArray","elementsLength","removeChild","shift","numericIds","parts","labelIndex","isFirstLabel","coor","range","logStart","logEnd","logInterval","logPosition","ticksX","ticksY","minorGird","minorTick","pow","findLogNumeric","ceil","concat","tempValue","drawXAxisLabels","previousLabel","islabelInside","isHorizontalAngle","labelWidth","isLeft","newPoints","isRotatedLabelIntersect","textPoints","rotatedLabelSize","isLabelUnderAxisLine","axislabelElement","removeAxisLabelElements","legendWidth","isEndAnchor","paddingForBreakLabel","getAnchor","isRtlEnabled","children","maxWidth","i_1","breakLabelWidth","axisLabelWidth","shiftedXValue","padding_1","maxAvailableWidth","getLabelText","xValue","xValue2","rect_1","xAdjustment","yAdjustment","rectCoordinates","getRectanglePoints","rectCenterX","rectCenterY","index_1","rotateAngle","textRect","textRectCoordinates","rectPoints","newRect","interSectPoint","calculateIntersection","rectPoint1","rectPoint2","trimValue","sqrt","optionsX","element_1","gridDirection","elementId","isGrid","isLabel","visibleLabelTexts_1","join","childNode","textContent","trim","p1","p2","p3","p4","c2x","c3x","c2y","c3y","d","u1","u4","px","py","p","point1","point2","point3","point4","str","findAxisLabel","drawXAxisBorder","axisRect","startX","length_2","renderXAxisMultiLevelLabels","borderElement","pointerEvents","enableTrim","drawXAxisTitle","gridModel","gridId","gridIndex","themeColor","removeIndex","isRemoved","findParentNode","document","getElementById","contains","parentNode","zoomElement","replaceChild"],"sources":["C:/Users/mkfun/Desktop/ct assignment/admin/node_modules/@syncfusion/ej2-charts/src/chart/axis/cartesian-panel.js"],"sourcesContent":["import { createElement, isNullOrUndefined, Animation } from '@syncfusion/ej2-base';\nimport { DataUtil } from '@syncfusion/ej2-data';\nimport { subtractThickness, valueToCoefficient, sum, redrawElement, isBreakLabel, ChartLocation, withInBounds, rotateTextSize, removeElement, calculateScrollbarOffset } from '../../common/utils/helper';\nimport { subArray, inside, appendChildElement, stringToNumber } from '../../common/utils/helper';\nimport { Thickness, logBase, createZoomingLabels, getElement } from '../../common/utils/helper';\nimport { Size, Rect, measureText, TextOption, PathOption } from '@syncfusion/ej2-svg-base';\nimport { textElement, textTrim, getRotatedRectangleCoordinates, isRotatedRectIntersect, isZoomSet } from '../../common/utils/helper';\n/**\n * Specifies the Cartesian Axis Layout.\n */\nvar axisPadding = 10;\nvar CartesianAxisLayoutPanel = /** @class */ (function () {\n    /** @private */\n    /**\n     * Constructor for creating the chart.\n     *\n     * @param {Chart} chartModule - Specifies the Chart model.\n     * @private */\n    function CartesianAxisLayoutPanel(chartModule) {\n        this.chart = chartModule;\n        this.padding = 5;\n    }\n    /**\n     * Measure the axis size.\n     *\n     * @returns {void}\n     * @private\n     */\n    CartesianAxisLayoutPanel.prototype.measureAxis = function (rect) {\n        var chart = this.chart;\n        var chartAreaWidth = chart.chartArea.width ? stringToNumber(chart.chartArea.width, chart.availableSize.width) : null;\n        this.crossAt(chart);\n        this.seriesClipRect = new Rect(rect.x, rect.y, rect.width, rect.height);\n        this.initialClipRect = rect;\n        this.leftSize = 0;\n        this.rightSize = 0;\n        this.topSize = 0;\n        this.bottomSize = 0;\n        //Measure Axis size with initial Rect\n        this.measureRowAxis(chart, this.initialClipRect);\n        this.initialClipRect = subtractThickness(this.initialClipRect, new Thickness(this.leftSize, this.rightSize, 0, 0));\n        this.measureColumnAxis(chart, this.initialClipRect);\n        this.initialClipRect = subtractThickness(this.initialClipRect, new Thickness(0, 0, this.topSize, this.bottomSize));\n        if (!this.chart.delayRedraw) {\n            this.calculateAxisSize(this.initialClipRect);\n        }\n        this.leftSize = 0;\n        this.rightSize = 0;\n        this.topSize = 0;\n        this.bottomSize = 0;\n        //Measure Axis size with series Rect\n        this.measureRowAxis(chart, this.initialClipRect);\n        this.seriesClipRect = subtractThickness(this.seriesClipRect, new Thickness(this.leftSize, this.rightSize, 0, 0));\n        this.measureColumnAxis(chart, this.initialClipRect);\n        this.seriesClipRect = subtractThickness(this.seriesClipRect, new Thickness(0, 0, this.topSize, this.bottomSize));\n        if (chartAreaWidth) {\n            this.calculateFixedChartArea(chart, chartAreaWidth);\n        }\n        if (!this.chart.delayRedraw) {\n            chart.refreshAxis();\n            this.calculateAxisSize(this.seriesClipRect);\n        }\n    };\n    CartesianAxisLayoutPanel.prototype.calculateFixedChartArea = function (chart, chartAreaWidth) {\n        this.seriesClipRect.width = chartAreaWidth;\n        this.seriesClipRect.x = chart.availableSize.width - chart.margin.right - chartAreaWidth -\n            (chart.legendSettings.position === 'Right' ? chart.legendModule.legendBounds.width : 0);\n        for (var _i = 0, _a = chart.rows; _i < _a.length; _i++) {\n            var item = _a[_i];\n            this.seriesClipRect.x -= sum(item.farSizes);\n        }\n    };\n    CartesianAxisLayoutPanel.prototype.measureRowAxis = function (chart, rect) {\n        var row;\n        this.calculateRowSize(rect);\n        for (var _i = 0, _a = chart.rows; _i < _a.length; _i++) {\n            var item = _a[_i];\n            row = item;\n            row.nearSizes = [];\n            row.farSizes = [];\n            row.insideNearSizes = [];\n            row.insideFarSizes = [];\n            this.arrangeAxis(row);\n            this.measureDefinition(row, chart, new Size(chart.availableSize.width, row.computedHeight));\n            if (this.leftSize < sum(row.nearSizes)) {\n                this.leftSize = sum(row.nearSizes);\n            }\n            if (this.rightSize < sum(row.farSizes)) {\n                this.rightSize = sum(row.farSizes);\n            }\n        }\n    };\n    CartesianAxisLayoutPanel.prototype.measureColumnAxis = function (chart, rect) {\n        var column;\n        this.calculateColumnSize(rect);\n        for (var _i = 0, _a = chart.columns; _i < _a.length; _i++) {\n            var item = _a[_i];\n            column = item;\n            column.farSizes = [];\n            column.nearSizes = [];\n            column.insideNearSizes = [];\n            column.insideFarSizes = [];\n            this.arrangeAxis(column);\n            this.measureDefinition(column, chart, new Size(column.computedWidth, chart.availableSize.height));\n            if (this.bottomSize < sum(column.nearSizes)) {\n                this.bottomSize = sum(column.nearSizes);\n            }\n            if (this.topSize < sum(column.farSizes)) {\n                this.topSize = sum(column.farSizes);\n            }\n        }\n    };\n    /**\n     * Measure the column and row in chart.\n     *\n     * @returns {void}\n     * @private\n     */\n    CartesianAxisLayoutPanel.prototype.measureDefinition = function (definition, chart, size) {\n        var ele;\n        for (var _i = 0, _a = definition.axes; _i < _a.length; _i++) {\n            var axis = _a[_i];\n            ele = axis.scrollbarSettings.height;\n            axis.scrollBarHeight = chart.scrollBarModule && chart.zoomModule && chart.zoomSettings.enableScrollbar &&\n                axis.enableScrollbarOnZooming && chart.zoomModule.isZoomed && (axis.zoomFactor < 1 || axis.zoomPosition > 0) ? ele : 0;\n            axis.scrollBarHeight = chart.scrollBarModule && (chart.zoomModule && chart.zoomSettings.enableScrollbar &&\n                axis.enableScrollbarOnZooming && chart.zoomModule.isZoomed && (axis.zoomFactor < 1 || axis.zoomPosition > 0)\n                || axis.scrollbarSettings.enable) ? ele : 0;\n            axis.getModule(chart);\n            axis.baseModule.calculateRangeAndInterval(size, axis);\n            definition.computeSize(axis, axis.scrollBarHeight, definition, chart);\n        }\n        if (definition.farSizes.length > 0) {\n            definition.farSizes[definition.farSizes.length - 1] -= axisPadding;\n        }\n        if (definition.nearSizes.length > 0) {\n            definition.nearSizes[definition.nearSizes.length - 1] -= axisPadding;\n        }\n    };\n    /**\n     * Measure the axis.\n     *\n     * @param {Rect} rect - The rect for measuring the axis.\n     * @returns {void}\n     * @private\n     */\n    CartesianAxisLayoutPanel.prototype.calculateAxisSize = function (rect) {\n        var chart = this.chart;\n        var row;\n        var column;\n        var definition;\n        var axis;\n        var nearCount = 0;\n        var farCount = 0;\n        var size = 0;\n        var x;\n        var y;\n        var axisOffset;\n        this.calculateRowSize(rect);\n        for (var i = 0, len = chart.rows.length; i < len; i++) {\n            row = chart.rows[i];\n            nearCount = 0;\n            farCount = 0;\n            for (var j = 0, len_1 = row.axes.length; j < len_1; j++) {\n                axis = row.axes[j];\n                axisOffset = axis.plotOffset;\n                if (axis.rect.height === 0) {\n                    axis.rect.height = row.computedHeight;\n                    size = 0;\n                    for (var k = i + 1, len_2 = i + axis.span; k < len_2; k++) {\n                        definition = chart.rows[k];\n                        size += definition.computedHeight;\n                    }\n                    axis.rect.y = (row.computedTop - size) + (axis.plotOffsetTop ? axis.plotOffsetTop : axisOffset);\n                    axis.rect.height = (axis.rect.height + size) -\n                        (this.getAxisOffsetValue(axis.plotOffsetTop, axis.plotOffsetBottom, axis.plotOffset));\n                    axis.rect.width = 0;\n                }\n                if (axis.isAxisOpposedPosition) {\n                    if (axis.labelPosition === 'Inside' && axis.orientation === 'Vertical') {\n                        if (farCount > 0) {\n                            x = rect.x + rect.width + sum(subArray(row.farSizes, farCount))\n                                + axis.maxLabelSize.width + axis.multiLevelLabelHeight + (axis.tickPosition === 'Inside' ? axis.majorTickLines.height : 0) + axis.labelPadding;\n                        }\n                        else {\n                            x = rect.x + rect.width - sum(subArray(row.insideFarSizes, farCount));\n                        }\n                    }\n                    else {\n                        x = rect.x + rect.width + sum(subArray(row.farSizes, farCount));\n                    }\n                    axis.rect.x = axis.rect.x >= x ? axis.rect.x : x;\n                    farCount++;\n                }\n                else {\n                    if (axis.labelPosition === 'Inside' && axis.orientation === 'Vertical') {\n                        if (nearCount > 0) {\n                            x = rect.x - sum(subArray(row.nearSizes, nearCount)) - axis.maxLabelSize.width -\n                                axis.multiLevelLabelHeight - (axis.tickPosition === 'Inside' ? axis.majorTickLines.height : 0) - axis.labelPadding;\n                        }\n                        else {\n                            x = rect.x + sum(subArray(row.insideNearSizes, nearCount));\n                        }\n                    }\n                    else {\n                        x = rect.x - sum(subArray(row.nearSizes, nearCount));\n                    }\n                    axis.rect.x = axis.rect.x <= x ? axis.rect.x : x;\n                    nearCount++;\n                }\n            }\n        }\n        this.calculateColumnSize(rect);\n        for (var i = 0, len = chart.columns.length; i < len; i++) {\n            column = chart.columns[i];\n            nearCount = 0;\n            farCount = 0;\n            for (var j = 0, len_3 = column.axes.length; j < len_3; j++) {\n                axis = column.axes[j];\n                axisOffset = axis.plotOffset;\n                if (axis.rect.width === 0) {\n                    for (var k = i, len_4 = (i + axis.span); k < len_4; k++) {\n                        definition = chart.columns[k];\n                        axis.rect.width += definition.computedWidth;\n                    }\n                    axis.rect.x = column.computedLeft + (axis.plotOffsetLeft ? axis.plotOffsetLeft : axisOffset);\n                    axis.rect.width -= (this.getAxisOffsetValue(axis.plotOffsetLeft, axis.plotOffsetRight, axis.plotOffset));\n                    axis.rect.height = 0;\n                }\n                if (axis.isAxisOpposedPosition) {\n                    if (axis.labelPosition === 'Inside' && axis.orientation === 'Horizontal') {\n                        if (farCount > 0) {\n                            y = rect.y - sum(subArray(column.farSizes, farCount)) - axis.maxLabelSize.height\n                                - axis.multiLevelLabelHeight - (axis.tickPosition === 'Inside' ? axis.majorTickLines.height : 0) - axis.labelPadding;\n                        }\n                        else {\n                            y = rect.y + sum(subArray(column.insideFarSizes, farCount));\n                        }\n                    }\n                    else {\n                        y = rect.y - sum(subArray(column.farSizes, farCount));\n                    }\n                    axis.rect.y = axis.rect.y <= y ? axis.rect.y : y;\n                    farCount++;\n                }\n                else {\n                    if (axis.labelPosition === 'Inside' && axis.orientation === 'Horizontal') {\n                        if (nearCount > 0) {\n                            y = rect.y + rect.height + sum(subArray(column.nearSizes, nearCount)) + axis.maxLabelSize.height\n                                + axis.multiLevelLabelHeight + (axis.tickPosition === 'Inside' ? axis.majorTickLines.height : 0) + axis.labelPadding;\n                        }\n                        else {\n                            y = rect.y + rect.height - sum(subArray(column.insideNearSizes, nearCount));\n                        }\n                    }\n                    else {\n                        y = rect.y + rect.height + sum(subArray(column.nearSizes, nearCount));\n                    }\n                    axis.rect.y = axis.rect.y >= y ? axis.rect.y : y;\n                    nearCount++;\n                }\n            }\n        }\n    };\n    /**\n     * Measure the axis.\n     *\n     * @returns {void}\n     * @private\n     */\n    CartesianAxisLayoutPanel.prototype.measure = function () {\n        var chart = this.chart;\n        var row;\n        var column;\n        var definition;\n        var actualIndex;\n        var span;\n        for (var _i = 0, _a = chart.axisCollections; _i < _a.length; _i++) {\n            var axis = _a[_i];\n            //definition.Axes = axis;\n            if (axis.orientation === 'Vertical') {\n                chart.verticalAxes.push(axis);\n                actualIndex = this.getActualRow(axis);\n                row = chart.rows[actualIndex];\n                this.pushAxis(row, axis);\n                span = ((actualIndex + axis.span) > chart.rows.length ? chart.rows.length : (actualIndex + axis.span));\n                for (var j = actualIndex + 1; j < span; j++) {\n                    definition = chart.rows[j];\n                    definition.axes[row.axes.length - 1] = axis;\n                    chart.rows[j] = definition;\n                }\n                chart.rows[actualIndex] = row;\n            }\n            else {\n                chart.horizontalAxes.push(axis);\n                actualIndex = this.getActualColumn(axis);\n                column = chart.columns[actualIndex];\n                this.pushAxis(column, axis);\n                span = ((actualIndex + axis.span) > chart.columns.length ? chart.columns.length : (actualIndex + axis.span));\n                for (var j = actualIndex + 1; j < span; j++) {\n                    definition = chart.columns[j];\n                    definition.axes[column.axes.length - 1] = axis;\n                    chart.columns[j] = definition;\n                }\n                chart.columns[actualIndex] = column;\n            }\n            axis.isRTLEnabled = chart.enableRtl;\n            axis.setIsInversedAndOpposedPosition();\n        }\n    };\n    CartesianAxisLayoutPanel.prototype.getAxisOffsetValue = function (position1, position2, plotOffset) {\n        var rangeOffset = position1 ? (position1 + (position2 ? position2 :\n            plotOffset)) : (position2 ? position2 + plotOffset : 2 * plotOffset);\n        return rangeOffset;\n    };\n    CartesianAxisLayoutPanel.prototype.crossAt = function (chart) {\n        for (var _i = 0, _a = chart.axisCollections; _i < _a.length; _i++) {\n            var axis = _a[_i];\n            if (axis.crossesAt === null) {\n                continue;\n            }\n            if (!axis.crossesInAxis) {\n                if (chart.requireInvertedAxis) {\n                    axis.crossInAxis = ((axis.orientation === 'Horizontal')) ? chart.primaryXAxis : chart.primaryYAxis;\n                }\n                else {\n                    axis.crossInAxis = ((axis.orientation === 'Horizontal')) ? chart.primaryYAxis : chart.primaryXAxis;\n                }\n                axis.crossAt = this.updateCrossAt(axis.crossInAxis, axis.crossesAt);\n                continue;\n            }\n            else {\n                for (var i = 2, len = chart.axisCollections.length; i < len; i++) {\n                    if (axis.crossesInAxis === chart.axisCollections[i].name) {\n                        axis.crossInAxis = chart.axisCollections[i];\n                        axis.crossAt = this.updateCrossAt(axis.crossInAxis, axis.crossesAt);\n                        continue;\n                    }\n                }\n            }\n        }\n    };\n    CartesianAxisLayoutPanel.prototype.updateCrossAt = function (axis, crossAt) {\n        switch (axis.valueType) {\n            case 'DateTime': {\n                var option = {\n                    skeleton: 'full',\n                    type: 'dateTime'\n                };\n                var dateParser = this.chart.intl.getDateParser(option);\n                var dateFormatter = this.chart.intl.getDateFormat(option);\n                return Date.parse(dateParser(dateFormatter(new Date(DataUtil.parse.parseJson({ val: crossAt }).val))));\n            }\n            case 'Category':\n                return parseFloat(crossAt) ? parseFloat(crossAt) : axis.labels.indexOf(crossAt);\n            case 'Logarithmic':\n                return logBase(crossAt, axis.logBase);\n            default:\n                return crossAt;\n        }\n    };\n    CartesianAxisLayoutPanel.prototype.pushAxis = function (definition, axis) {\n        for (var i = 0, len = definition.axes.length; i <= len; i++) {\n            if (!definition.axes[i]) {\n                definition.axes[i] = axis;\n                break;\n            }\n        }\n    };\n    CartesianAxisLayoutPanel.prototype.arrangeAxis = function (definition) {\n        var axisCollection = [];\n        for (var i = 0, len = definition.axes.length; i <= len; i++) {\n            if (definition.axes[i]) {\n                axisCollection.push(definition.axes[i]);\n            }\n        }\n        definition.axes = axisCollection;\n    };\n    CartesianAxisLayoutPanel.prototype.getActualColumn = function (axis) {\n        var actualLength = this.chart.columns.length;\n        var pos = axis.columnIndex;\n        var result = pos >= actualLength ? actualLength - 1 : (pos < 0 ? 0 : pos);\n        return result;\n    };\n    CartesianAxisLayoutPanel.prototype.getActualRow = function (axis) {\n        var actualLength = this.chart.rows.length;\n        var pos = axis.rowIndex;\n        var result = pos >= actualLength ? actualLength - 1 : (pos < 0 ? 0 : pos);\n        return result;\n    };\n    /**\n     * Measure the row size.\n     *\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.calculateRowSize = function (rect) {\n        /** Calculate row size */\n        var chart = this.chart;\n        var row;\n        var rowTop = rect.y + rect.height;\n        var height = 0;\n        var remainingHeight = Math.max(0, rect.height);\n        for (var i = 0, len = chart.rows.length; i < len; i++) {\n            row = chart.rows[i];\n            if (row.height.indexOf('%') !== -1) {\n                height = Math.min(remainingHeight, (rect.height * parseInt(row.height, 10) / 100));\n            }\n            else {\n                height = Math.min(remainingHeight, parseInt(row.height, 10));\n            }\n            height = (i !== (len - 1)) ? height : remainingHeight;\n            row.computedHeight = height;\n            rowTop -= height;\n            row.computedTop = rowTop;\n            remainingHeight -= height;\n        }\n    };\n    /**\n     * Measure the row size.\n     *\n     * @param {Rect} rect rect\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.calculateColumnSize = function (rect) {\n        /** Calculate column size */\n        var chart = this.chart;\n        var column;\n        var columnLeft = rect.x;\n        var width = 0;\n        var remainingWidth = Math.max(0, rect.width);\n        for (var i = 0, len = chart.columns.length; i < len; i++) {\n            column = chart.columns[i];\n            if (column.width.indexOf('%') !== -1) {\n                width = Math.min(remainingWidth, (rect.width * parseInt(column.width, 10) / 100));\n            }\n            else {\n                width = Math.min(remainingWidth, parseInt(column.width, 10));\n            }\n            width = (i !== (len - 1)) ? width : remainingWidth;\n            column.computedWidth = width;\n            column.computedLeft = columnLeft;\n            columnLeft += width;\n            remainingWidth -= width;\n        }\n    };\n    /**\n     * To render the axis element.\n     *\n     * @returns {void}\n     * @private\n     */\n    CartesianAxisLayoutPanel.prototype.renderAxes = function () {\n        var chart = this.chart;\n        var axis;\n        var axisElement = chart.renderer.createGroup({ id: chart.element.id + 'AxisInsideCollection' });\n        var axisLineElement = chart.renderer.createGroup({ id: chart.element.id + 'AxisOutsideCollection' });\n        if (axisLineElement) {\n            axisLineElement.setAttribute('aria-hidden', 'true');\n        }\n        var outsideElement;\n        var isInside;\n        if (chart.scrollBarModule) {\n            chart.scrollBarModule.topScrollBarCount = 0;\n            chart.scrollBarModule.bottomScrollBarCount = 0;\n            chart.scrollBarModule.leftScrollBarCount = 0;\n            chart.scrollBarModule.rightScrollBarCount = 0;\n        }\n        for (var i = 0, len = chart.axisCollections.length; i < len; i++) {\n            var axisVisibility = true;\n            axis = chart.axisCollections[i];\n            axis.index = i;\n            this.element = chart.renderer.createGroup({ id: chart.element.id + 'AxisGroup' + i + 'Inside' });\n            if (this.element) {\n                this.element.setAttribute('aria-hidden', 'true');\n            }\n            outsideElement = chart.renderer.createGroup({ id: chart.element.id + 'AxisGroup' + i + 'Outside' });\n            if (outsideElement) {\n                outsideElement.setAttribute('aria-hidden', 'true');\n            }\n            for (var _i = 0, _a = axis.series; _i < _a.length; _i++) {\n                var series = _a[_i];\n                if (axis.name === series.yAxisName || axis.name === series.xAxisName) {\n                    axisVisibility = series.visible;\n                    if (series.category === 'Pareto' && !series.paretoOptions.showAxis && series.type === 'Line') {\n                        axisVisibility = false;\n                    }\n                    if (!axisVisibility) {\n                        continue;\n                    }\n                    else {\n                        break;\n                    }\n                }\n            }\n            if (!axisVisibility) {\n                if (axis.zoomingScrollBar) {\n                    axis.zoomingScrollBar.removeScrollSvg();\n                }\n                continue;\n            }\n            isInside = this.findAxisPosition(axis);\n            this.drawAxis(axis, i, isInside, outsideElement, axisElement, axisLineElement);\n        }\n        this.drawPaneLines(chart, axisElement);\n        appendChildElement(chart.enableCanvas, chart.svgObject, axisElement, chart.redraw);\n        return axisLineElement;\n    };\n    /**\n     * To render the axis scrollbar\n     *\n     * @param {Chart} chart chart\n     * @param {Axis} axis axis\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.renderScrollbar = function (chart, axis) {\n        var isZoomed = isNullOrUndefined(chart.zoomModule) ? false : chart.zoomModule.isZoomed;\n        if (!axis.zoomingScrollBar) {\n            chart.scrollBarModule.injectTo(axis, chart);\n        }\n        if (((isZoomed && (axis.zoomFactor < 1 || axis.zoomPosition > 0)) || (axis.scrollbarSettings.enable &&\n            (axis.zoomFactor <= 1 || axis.zoomPosition >= 0))) &&\n            (!axis.zoomingScrollBar.isScrollUI)) {\n            if (!chart.scrollElement) {\n                chart.scrollElement = redrawElement(chart.redraw, chart.element.id + '_scrollElement') || createElement('div', { id: chart.element.id + '_scrollElement' });\n            }\n            appendChildElement(false, chart.scrollElement, axis.zoomingScrollBar.render(true), true);\n        }\n        else if (axis.zoomFactor === 1 && axis.zoomPosition === 0 && axis.zoomingScrollBar.svgObject && !axis.scrollbarSettings.enable) {\n            axis.zoomingScrollBar.destroy();\n        }\n        else if (axis.zoomingScrollBar.svgObject) {\n            var topOffset = (axis.isAxisOpposedPosition && axis.orientation === 'Horizontal' ? -16 : 0)\n                + axis.rect.y + Math.max(0.5, axis.lineStyle.width / 2);\n            var leftOffset = (axis.isAxisOpposedPosition && axis.orientation !== 'Horizontal' ? 16 : 0)\n                + axis.rect.x - (axis.orientation === 'Vertical' ? axis.scrollbarSettings.height : 0);\n            if (axis.orientation !== 'Horizontal' && (axis.scrollbarSettings.position === 'Left' || axis.scrollbarSettings.position === 'Right')) {\n                leftOffset = calculateScrollbarOffset(axis.zoomingScrollBar, false);\n            }\n            else if (axis.orientation === 'Horizontal' && (axis.scrollbarSettings.position === 'Top' || axis.scrollbarSettings.position === 'Bottom')) {\n                topOffset = calculateScrollbarOffset(axis.zoomingScrollBar, true);\n            }\n            axis.zoomingScrollBar.svgObject.style.top = topOffset + 'px';\n            axis.zoomingScrollBar.svgObject.style.left = leftOffset + 'px';\n        }\n        if (axis.zoomingScrollBar.isScrollUI) {\n            axis.zoomingScrollBar.isScrollUI = false;\n        }\n    };\n    /**\n     * Draws pane lines for the specified chart.\n     *\n     * @param {Chart} chart -The chart for which pane lines are to be drawn.\n     * @param {Element} [axisElement] -Optional. The axis element to which the pane lines are associated.\n     * @returns {void}\n     * @private\n     */\n    CartesianAxisLayoutPanel.prototype.drawPaneLines = function (chart, axisElement) {\n        this.element = chart.renderer.createGroup({ id: chart.element.id + 'DefinitionLine' });\n        for (var j = 0, len = chart.rows.length; j < len; j++) {\n            var row = chart.rows[j];\n            if (row.border.color) {\n                this.drawBottomLine(row, j, true);\n            }\n        }\n        for (var j = 0, len = chart.columns.length; j < len; j++) {\n            var column = chart.columns[j];\n            if (column.border.color) {\n                this.drawBottomLine(column, j, false);\n            }\n        }\n        axisElement = axisElement ? axisElement : getElement(chart.element.id + 'AxisInsideCollection');\n        if (!this.chart.enableCanvas) {\n            axisElement.appendChild(this.element);\n        }\n    };\n    /**\n     * Draws an axis for the specified axis configuration.\n     *\n     * @private\n     * @param {Axis} axis -The axis configuration to be drawn.\n     * @param {number} index -The index of the axis.\n     * @param {boolean} isInside -Indicates whether the axis is inside or outside the plot area.\n     * @param {Element} outsideElement -The element where the axis should be drawn if it's outside the plot area.\n     * @param {Element} axisElement -The element representing the axis.\n     * @param {Element} axisLineElement -The element representing the axis line.\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.drawAxis = function (axis, index, isInside, outsideElement, axisElement, axisLineElement) {\n        axis.updateCrossValue();\n        var axisName = '';\n        if (axis.orientation === 'Horizontal') {\n            if (axis.visible && axis.internalVisibility && axis.lineStyle.width > 0) {\n                this.drawAxisLine(axis, index, axis.plotOffset, 0, 0, 0, axis.plotOffsetLeft, axis.plotOffsetRight, isInside ? outsideElement : this.element, axis.updatedRect);\n            }\n            axisName = 'X';\n        }\n        else {\n            if (axis.visible && axis.internalVisibility && axis.lineStyle.width > 0) {\n                this.drawAxisLine(axis, index, 0, axis.plotOffset, axis.plotOffsetBottom, axis.plotOffsetTop, 0, 0, isInside ? outsideElement : this.element, axis.updatedRect);\n            }\n            axisName = 'Y';\n        }\n        if (axis.majorGridLines.width > 0 || axis.majorTickLines.width > 0 || axis.minorTickLines.width > 0 ||\n            axis.minorGridLines.width > 0) {\n            this['draw' + axisName + 'AxisGridLine'](axis, index, (isInside || axis.tickPosition === 'Inside') ? outsideElement : this.element, axis.updatedRect);\n        }\n        if (axis.visible && axis.internalVisibility) {\n            this['draw' + axisName + 'AxisLabels'](axis, index, (isInside || axis.labelPosition === 'Inside') ? outsideElement : this.element, (axis.placeNextToAxisLine ? axis.updatedRect : axis.rect));\n            this['draw' + axisName + 'AxisBorder'](axis, index, (isInside || axis.labelPosition === 'Inside') ? outsideElement : this.element, (axis.placeNextToAxisLine ? axis.updatedRect : axis.rect));\n            this['draw' + axisName + 'AxisTitle'](axis, index, isInside ? outsideElement : this.element, (axis.placeNextToAxisLine ? axis.updatedRect : axis.rect));\n        }\n        if (!this.chart.enableCanvas) {\n            axisElement.appendChild(this.element);\n            if (outsideElement && outsideElement.childNodes.length > 0) {\n                axisLineElement.appendChild(outsideElement);\n            }\n        }\n        if (this.chart.scrollBarModule && ((this.chart.zoomSettings.enableScrollbar && axis.enableScrollbarOnZooming) ||\n            axis.scrollbarSettings.enable)) {\n            this.renderScrollbar(this.chart, axis);\n        }\n        else {\n            if (axis.zoomingScrollBar) {\n                axis.zoomingScrollBar.destroy();\n            }\n        }\n    };\n    /**\n     * To find the axis position\n     *\n     * @param {Axis} axis axis\n     * @returns {boolean} axis position\n     * @private\n     */\n    CartesianAxisLayoutPanel.prototype.findAxisPosition = function (axis) {\n        return axis.crossAt !== null && axis.isInside(axis.crossInAxis.visibleRange);\n    };\n    /**\n     * To render the bootom line of the columns and rows\n     *\n     * @param {Row | Column} definition definition\n     * @param {number} index index\n     * @param {boolean} isRow isRow\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.drawBottomLine = function (definition, index, isRow) {\n        var chart = this.chart;\n        var optionsLine = {};\n        var x1;\n        var x2;\n        var y1;\n        var y2;\n        var definitionName;\n        if (isRow) {\n            definition = definition;\n            y1 = y2 = definition.computedTop + definition.computedHeight;\n            x1 = this.seriesClipRect.x;\n            x2 = x1 + this.seriesClipRect.width;\n            definitionName = 'Row';\n        }\n        else {\n            definition = definition;\n            x1 = x2 = definition.computedLeft;\n            y1 = this.seriesClipRect.y;\n            y2 = y1 + this.seriesClipRect.height;\n            definitionName = 'Column';\n        }\n        optionsLine = {\n            'id': chart.element.id + '_AxisBottom_' + definitionName + index,\n            x1: x1,\n            y1: y1,\n            x2: x2,\n            y2: y2,\n            'stroke-width': definition.border.width,\n            'stroke': definition.border.color\n        };\n        this.htmlObject = chart.renderer.drawLine(optionsLine);\n        appendChildElement(chart.enableCanvas, this.element, this.htmlObject);\n    };\n    /**\n     * To render the axis line\n     *\n     * @param {Axis} axis axis\n     * @param {number} index index\n     * @param {number} plotX plotX\n     * @param {number} plotY plotY\n     * @param {number} plotBottom plotBottom\n     * @param {number} plotTop plotTop\n     * @param {number} plotLeft plotLeft\n     * @param {number} plotRight plotRight\n     * @param {Element} parent parent\n     * @param {Rect} rect rect\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.drawAxisLine = function (axis, index, plotX, plotY, plotBottom, plotTop, plotLeft, plotRight, parent, rect) {\n        var chart = this.chart;\n        var optionsLine = {};\n        var element = getElement(chart.element.id + 'AxisLine_' + index);\n        var direction = element ? element.getAttribute('d') : '';\n        element = null;\n        optionsLine = {\n            'id': chart.element.id + 'AxisLine_' + index,\n            'd': 'M ' + (rect.x - plotX - plotLeft) + ' ' + (rect.y - plotY - plotTop) +\n                ' L ' + (rect.x + rect.width + plotX + plotRight) + ' ' + (rect.y + rect.height + plotY + plotBottom),\n            'stroke-dasharray': axis.lineStyle.dashArray,\n            'stroke-width': axis.lineStyle.width,\n            'stroke': axis.lineStyle.color || chart.themeStyle.axisLine\n        };\n        this.htmlObject = chart.renderer.drawPath(optionsLine);\n        appendChildElement(chart.enableCanvas, parent, this.htmlObject, chart.redraw, true, 'x', 'y', null, direction, null, null, null, chart.duration);\n    };\n    /**\n     * To render the yAxis grid line\n     *\n     * @param {Axis} axis axis\n     * @param {number} index index\n     * @param {Element} parent parent\n     * @param {Rect} rect rect\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.drawYAxisGridLine = function (axis, index, parent, rect) {\n        var isLogAxis = axis.valueType === 'Logarithmic';\n        var isCategoryAxis = axis.valueType.indexOf('Category') > -1;\n        var tempInterval;\n        var pointY = 0;\n        var majorGrid = '';\n        var majorTick = '';\n        var minorGridDirection;\n        var isOpposed = axis.isAxisOpposedPosition;\n        var tickSize = isOpposed ? axis.majorTickLines.height : -axis.majorTickLines.height;\n        var axisLineSize = (isOpposed) ? axis.lineStyle.width * 0.5 : -axis.lineStyle.width * 0.5;\n        var ticksbwtLabel = (axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks') ?\n            0.5 : 0;\n        var scrollBarHeight = (isNullOrUndefined(axis.crossesAt) && axis.scrollbarSettings.position !== 'Right' && axis.scrollbarSettings.position !== 'Left') ? isOpposed ? axis.scrollBarHeight :\n            -axis.scrollBarHeight : 0;\n        var isTickInside = axis.tickPosition === 'Inside';\n        var ticks = isTickInside ? (rect.x - tickSize - axisLineSize) : (rect.x + tickSize + axisLineSize + scrollBarHeight);\n        var length = axis.visibleLabels.length;\n        var chartThemeStyle = this.chart.themeStyle;\n        var count = 1;\n        if (axis.valueType.indexOf('Category') > -1 && axis.labelPlacement === 'BetweenTicks' && length > 0 && !this.chart.stockChart) {\n            length += 1;\n        }\n        var minorGridLines = axis.minorGridLines;\n        var minorTickLines = axis.minorTickLines;\n        //Gridlines\n        for (var i = 0; i < length; i++) {\n            tempInterval = !axis.visibleLabels[i] ? (axis.visibleLabels[i - 1].value + axis.visibleRange.interval) - ticksbwtLabel\n                : axis.visibleLabels[i].value - ticksbwtLabel;\n            pointY = valueToCoefficient(tempInterval, axis) * rect.height;\n            pointY = (pointY * -1) + (rect.y + rect.height);\n            if (pointY >= rect.y && (rect.y + rect.height) >= pointY) {\n                if (this.chart.redraw && !this.chart.enableCanvas && this.chart.zoomRedraw && axis.visible && axis.majorGridLines.width && i !== 0 && !getElement(this.chart.element.id + '_MajorGridLine_' + index + '_' + i)) {\n                    majorGrid = 'M ' + this.seriesClipRect.x + ' ' + (this.seriesClipRect.y + (axis.isInversed ? this.seriesClipRect.height + ((this.seriesClipRect.height / (i ? i : 1)) * count) : -((this.seriesClipRect.height / (i ? i : 1)) * count))) +\n                        ' L ' + (this.seriesClipRect.x + this.seriesClipRect.width) + ' ' + (this.seriesClipRect.y + (axis.isInversed ? this.seriesClipRect.height + ((this.seriesClipRect.height / (i ? i : 1)) * count) : -((this.seriesClipRect.height / (i ? i : 1)) * count)));\n                    this.updateAxisElement(axis, index, majorGrid, i, '_MajorGridLine_', this.element, false);\n                    getElement(parent.id).appendChild(this.element.childNodes[this.element.childNodes.length - 1]);\n                }\n                if ((inside(tempInterval, axis.visibleRange)) || this.isBorder(axis, i, pointY)) {\n                    majorGrid = 'M ' + this.seriesClipRect.x + ' ' + (pointY) +\n                        ' L ' + (this.seriesClipRect.x + this.seriesClipRect.width) + ' ' + pointY;\n                    this.renderGridLine(axis, index, majorGrid, axis.majorGridLines, '_MajorGridLine_', i, this.element, chartThemeStyle.majorGridLine, axis.majorGridLines.dashArray);\n                }\n                if (this.chart.redraw && this.chart.zoomRedraw && axis.majorTickLines.width && i !== 0 && !getElement(this.chart.element.id + '_MajorTickLine_' + index + '_' + i) && !this.chart.enableCanvas && axis.visible) {\n                    majorTick = 'M ' + this.seriesClipRect.x + ' ' + (this.seriesClipRect.y + (axis.isInversed ? this.seriesClipRect.height + ((this.seriesClipRect.height / (i ? i : 1)) * count) : -((this.seriesClipRect.height / (i ? i : 1)) * count))) +\n                        ' L ' + ticks + ' ' + (this.seriesClipRect.y + (axis.isInversed ? this.seriesClipRect.height + ((this.seriesClipRect.height / (i ? i : 1)) * count) : -((this.seriesClipRect.height / (i ? i : 1)) * count)));\n                    this.updateAxisElement(axis, index, majorTick, i, '_MajorTickLine_', parent, false);\n                    getElement(parent.id).appendChild(this.element.childNodes[this.element.childNodes.length - 1]);\n                    count += 1;\n                }\n                majorTick = 'M ' + (rect.x + axisLineSize + (isTickInside ? scrollBarHeight : 0)) + ' ' + pointY +\n                    ' L ' + (ticks) + ' ' + pointY;\n                this.renderGridLine(axis, index, majorTick, axis.majorTickLines, '_MajorTickLine_', i, parent, chartThemeStyle.majorTickLine);\n                if ((minorGridLines.width > 0 || minorTickLines.width > 0) && axis.minorTicksPerInterval > 0) {\n                    if (i === 0 && isZoomSet(axis) && !isLogAxis && !isCategoryAxis) {\n                        this.renderMinorGridOnZooming(axis, tempInterval, rect, i, index, chartThemeStyle, parent);\n                    }\n                    minorGridDirection = this.drawAxisMinorLine(axis, tempInterval, rect, i);\n                    this.renderGridLine(axis, index, minorGridDirection[0], minorGridLines, '_MinorGridLine_', i, this.element, chartThemeStyle.minorGridLine, minorGridLines.dashArray);\n                    this.renderGridLine(axis, index, minorGridDirection[1], minorTickLines, '_MinorTickLine_', i, parent, chartThemeStyle.minorTickLine);\n                    if (i === length - 1 && isZoomSet(axis) && isLogAxis && !isCategoryAxis) {\n                        this.renderMinorGridOnZooming(axis, (tempInterval + axis.visibleRange.interval), rect, i, index, chartThemeStyle, parent);\n                    }\n                }\n            }\n        }\n        if (length && this.previousYLabel > length && !this.chart.enableCanvas && axis.visible &&\n            this.chart.zoomRedraw && this.chart.redraw) {\n            for (var i = length; i < this.previousYLabel; i++) {\n                var pointYValue = this.seriesClipRect.y + (axis.isInversed ? ((this.seriesClipRect.height / length) *\n                    ((i - length) + 1)) + this.seriesClipRect.height : -((this.seriesClipRect.height / length) * ((i - length) + 1)));\n                if (axis.majorGridLines.width) {\n                    majorGrid = 'M ' + this.seriesClipRect.x + ' ' + +pointYValue +\n                        ' L ' + (this.seriesClipRect.x + this.seriesClipRect.width) + ' ' + pointYValue;\n                    this.updateAxisElement(axis, index, majorGrid, i, '_MajorGridLine_', this.element, true);\n                }\n                if (axis.majorTickLines.width) {\n                    majorTick = 'M ' + this.seriesClipRect.x + ' ' + pointYValue +\n                        ' L ' + ticks + ' ' + pointYValue;\n                    this.updateAxisElement(axis, index, majorTick, i, '_MajorTickLine_', parent, true);\n                }\n            }\n        }\n    };\n    /**\n     * To check the border of the axis\n     *\n     * @param {Axis} axis axis\n     * @param {number} index index\n     * @param {number} value value\n     * @returns {boolean} check the border of the axis\n     */\n    CartesianAxisLayoutPanel.prototype.isBorder = function (axis, index, value) {\n        var border = this.chart.chartArea.border;\n        var rect = this.seriesClipRect;\n        var orientation = axis.orientation;\n        var start = (orientation === 'Horizontal') ? rect.x : rect.y;\n        var size = (orientation === 'Horizontal') ? rect.width : rect.height;\n        var startIndex = (orientation === 'Horizontal') ? 0 : axis.visibleLabels.length - 1;\n        var endIndex = (orientation === 'Horizontal') ? axis.visibleLabels.length - 1 : 0;\n        if (axis.plotOffset > 0) {\n            return true;\n        }\n        else if ((value === start || value === (start + size)) && (border.width <= 0 || border.color === 'transparent')) {\n            return true;\n        }\n        else if ((value !== start && index === startIndex) || (value !== (start + size) && index === endIndex)) {\n            return true;\n        }\n        return false;\n    };\n    /**\n     * To render the yAxis label\n     *\n     * @param {Axis} axis axis\n     * @param {number} index index\n     * @param {Element} parent parent\n     * @param {Rect} rect rect\n     * @returns {void}\n     * @private\n     */\n    CartesianAxisLayoutPanel.prototype.drawYAxisLabels = function (axis, index, parent, rect) {\n        var chart = this.chart;\n        var label;\n        var pointX = 0;\n        var pointY = 0;\n        var elementSize;\n        var labelSpace = axis.labelPadding;\n        var options;\n        var isAxisBreakLabel;\n        var isLabelInside = axis.labelPosition === 'Inside';\n        var isOpposed = axis.isAxisOpposedPosition;\n        var RotatedWidth;\n        var tickSpace = axis.labelPosition === axis.tickPosition ? axis.majorTickLines.height : 0;\n        var padding = tickSpace + labelSpace + axis.lineStyle.width * 0.5;\n        var angle = axis.angle % 360;\n        var isVerticalAngle = (angle === -90 || angle === 90 || angle === 270 || angle === -270);\n        padding += (isVerticalAngle) ? (isLabelInside ? 5 : -5) : 0;\n        padding = (isOpposed) ? padding : -padding;\n        var labelElement = chart.renderer.createGroup({ id: chart.element.id + 'AxisLabels' + index });\n        var scrollBarHeight = (isNullOrUndefined(axis.crossesAt) && axis.scrollbarSettings.position !== 'Left' && axis.scrollbarSettings.position !== 'Right') ? axis.scrollBarHeight * (isOpposed ? 1 : -1) : 0;\n        var textHeight;\n        var textPadding;\n        var maxLineWidth;\n        var pixel = 10;\n        var isInverse = axis.isAxisInverse;\n        var count = 1;\n        var previousEnd = isInverse ? rect.y : (rect.y + rect.height);\n        var labelPadding;\n        var intervalLength;\n        var labelHeight;\n        var yAxisLabelX;\n        var isLabelOnAxisLineLeft = ((!isOpposed && !isLabelInside) || (isOpposed && isLabelInside));\n        if (isLabelInside) {\n            labelPadding = !isLabelOnAxisLineLeft ? -padding : padding;\n        }\n        else {\n            labelPadding = !isLabelOnAxisLineLeft ? -padding + (chart.enableRtl ? -scrollBarHeight : scrollBarHeight) :\n                padding + (chart.enableRtl ? -scrollBarHeight : scrollBarHeight);\n        }\n        var sizeWidth = [];\n        var breakLabelSizeWidth = [];\n        axis.visibleLabels.map(function (item) {\n            sizeWidth.push(item.size['width']);\n            breakLabelSizeWidth.push(item.breakLabelSize['width']);\n        });\n        var LabelMaxWidth = Math.max.apply(Math, sizeWidth);\n        var breakLabelMaxWidth = Math.max.apply(Math, breakLabelSizeWidth);\n        RotatedWidth = LabelMaxWidth;\n        if (angle >= -45 && angle <= 45 && angle !== 0) {\n            RotatedWidth = LabelMaxWidth * Math.cos(angle * Math.PI / 180);\n            if (RotatedWidth < 0) {\n                RotatedWidth = -RotatedWidth;\n            }\n        }\n        for (var i = 0, len = axis.visibleLabels.length; i < len; i++) {\n            label = axis.visibleLabels[i];\n            isAxisBreakLabel = isBreakLabel(axis.visibleLabels[i].originalText);\n            elementSize = isAxisBreakLabel ? axis.visibleLabels[i].breakLabelSize : axis.visibleLabels[i].size;\n            pointY = (valueToCoefficient(axis.visibleLabels[i].value, axis) * rect.height) + (chart.stockChart ? 7 : 0);\n            pointY = Math.floor((pointY * -1) + (rect.y + rect.height));\n            textHeight = ((elementSize.height / 8) * axis.visibleLabels[i].text.length / 2);\n            textPadding = (chart.requireInvertedAxis && axis.labelPosition === 'Inside') ? 0 : ((elementSize.height / 4) * 3) + 3;\n            intervalLength = rect.height / axis.visibleLabels.length;\n            labelHeight = ((axis.labelIntersectAction === 'Trim' || axis.labelIntersectAction === 'Wrap') && angle !== 0 &&\n                elementSize.width > intervalLength) ? intervalLength : elementSize.width;\n            pointY = (isAxisBreakLabel ? (axis.labelPosition === 'Inside' ? (pointY - (elementSize.height / 2) - textHeight + textPadding)\n                : (pointY - textHeight)) : (axis.labelPosition === 'Inside' ? pointY + textPadding : pointY));\n            if (axis.labelPosition === 'Inside' && ((i === 0 && !axis.isInversed) || (i === len - 1 && axis.isInversed))) {\n                if (chart.stockChart) {\n                    pointY -= (textPadding);\n                }\n                else {\n                    pointY -= (textPadding - ((chart.requireInvertedAxis && axis.labelPosition === 'Inside') ? 0 : (axis.opposedPosition ? -padding : padding)));\n                }\n            }\n            if (axis.majorGridLines.width > axis.majorTickLines.width) {\n                maxLineWidth = axis.majorGridLines.width;\n            }\n            else {\n                maxLineWidth = axis.majorTickLines.width;\n            }\n            if (axis.labelStyle.textAlignment === 'Far') {\n                pointY = pointY - maxLineWidth - pixel;\n            }\n            else if (axis.labelStyle.textAlignment === 'Near') {\n                pointY = pointY + maxLineWidth + pixel;\n            }\n            // label X value adjustment (Start)\n            if (isLabelInside) {\n                yAxisLabelX = labelPadding + ((angle === 0 ? elementSize.width :\n                    (isAxisBreakLabel ? breakLabelMaxWidth : LabelMaxWidth)) / 2);\n            }\n            else {\n                yAxisLabelX = labelPadding - ((angle === 0 ? elementSize.width :\n                    (isAxisBreakLabel ? breakLabelMaxWidth : RotatedWidth)) / 2);\n            }\n            if (axis.enableWrap && chart.requireInvertedAxis && angle && ((!axis.opposedPosition && axis.labelPosition === 'Inside') || (axis.opposedPosition && axis.labelPosition === 'Outside'))) {\n                yAxisLabelX = axis.opposedPosition ? yAxisLabelX - LabelMaxWidth / 2 : yAxisLabelX + LabelMaxWidth / 2;\n            }\n            pointX = isOpposed ? (axis.scrollBarHeight !== 0 && axis.scrollbarSettings.position !== 'Right' && axis.scrollbarSettings.position !== 'Left') ? ((rect.x + axis.scrollBarHeight + padding) - yAxisLabelX) :\n                (rect.x - yAxisLabelX) : (rect.x + yAxisLabelX);\n            if (isVerticalAngle) {\n                pointX += (isOpposed) ? 5 : -5;\n            }\n            yAxisLabelX = labelPadding;\n            options = new TextOption(chart.element.id + index + '_AxisLabel_' + i, pointX, pointY, 'middle', label.text, '', 'middle', angle);\n            switch (axis.edgeLabelPlacement) {\n                case 'None':\n                    break;\n                case 'Hide':\n                    if (((i === 0 || (isInverse && i === len - 1)) && options.y > rect.y) ||\n                        (((i === len - 1) || (isInverse && i === 0)) && options.y - elementSize.height * 0.5 < rect.y)) {\n                        options.text = '';\n                    }\n                    break;\n                case 'Shift':\n                    if ((i === 0 || (isInverse && i === len - 1)) && options.y > rect.y + rect.height) {\n                        options.y = pointY = rect.y + rect.height;\n                    }\n                    else if (((i === len - 1) || (isInverse && i === 0)) &&\n                        (options.y <= 0)) {\n                        options.y = pointY = rect.y + elementSize.height * 0.5;\n                    }\n                    break;\n            }\n            // ------- Hide Calculation (Start) -------------\n            var previousYValue = options.y;\n            var currentYValue = options.y - labelHeight;\n            if (isAxisBreakLabel) {\n                previousYValue = (options.y - (labelHeight / 2));\n                currentYValue = options.y + (labelHeight / 2);\n            }\n            if ((angle === 90 || angle === 270) && axis.labelIntersectAction === 'Hide' && i !== 0 &&\n                (!isInverse ? previousYValue >= previousEnd : currentYValue <= previousEnd)) {\n                continue;\n            }\n            previousEnd = isInverse ? previousYValue : currentYValue;\n            // ------- Hide Calculation (End) -------------\n            options.transform = 'rotate(' + angle + ',' + pointX + ',' + pointY + ')';\n            if (this.chart.redraw && this.chart.zoomRedraw && !getElement(options.id) && !this.chart.enableCanvas && axis.visible) {\n                var optionsY = options.y;\n                options.y = this.seriesClipRect.y + (axis.isInversed ? this.seriesClipRect.height + ((this.seriesClipRect.height /\n                    (i ? i : 1)) * count) : -((this.seriesClipRect.height / (i ? i : 1)) * count));\n                this.updateAxisElement(axis, index, '', i, '_AxisLabel_', labelElement, false, options, label);\n                options.y = optionsY;\n                count += 1;\n            }\n            textElement(chart.renderer, options, label.labelStyle, label.labelStyle.color || chart.themeStyle.axisLabelFont.color, labelElement, false, chart.redraw, true, true, chart.duration, null, null, null, chart.enableCanvas, null, chart.themeStyle.axisLabelFont, new ChartLocation(pointX, pointY));\n        }\n        if (this.previousYLabel && axis.visibleLabels.length && this.previousYLabel > axis.visibleLabels.length\n            && !this.chart.enableCanvas && axis.visible && this.chart.zoomRedraw && chart.redraw && options.text) {\n            for (var i = axis.visibleLabels.length; i < this.previousYLabel; i++) {\n                options.y = this.seriesClipRect.y + (axis.isInversed ? this.seriesClipRect.height +\n                    ((this.seriesClipRect.height / axis.visibleLabels.length) * ((i - axis.visibleLabels.length) + 1)) :\n                    -((this.seriesClipRect.height / axis.visibleLabels.length) * ((i - axis.visibleLabels.length) + 1)));\n                options.id = chart.element.id + index + '_AxisLabel_' + i;\n                this.updateAxisElement(axis, index, '', i, '_AxisLabel_', labelElement, true, options, label);\n            }\n        }\n        else {\n            this.previousYLabel = axis.visibleLabels.length;\n        }\n        if (!this.chart.enableCanvas) {\n            if (!chart.delayRedraw) {\n                appendChildElement(chart.enableCanvas, parent, labelElement, chart.redraw);\n            }\n            else if (axis.visible && axis.internalVisibility) {\n                this.createZoomingLabel(this.chart, labelElement, axis, index, rect);\n            }\n        }\n    };\n    /**\n     * Animates the template element.\n     *\n     * @param {Axis} axis axis\n     * @param {Element} element - The element to animate.\n     * @param {number} duration - The duration of the animation.\n     * @param {boolean} label - Label.\n     * @param {Rect} bounds - The bounding rectangle.\n     * @param {boolean} isRemove isRemoved\n     * @param {number} i index of the element\n     * @returns {void}\n     * @private\n     */\n    CartesianAxisLayoutPanel.prototype.rangeAnimate = function (axis, element, duration, label, bounds, isRemove, i) {\n        var _this = this;\n        if (element) {\n            new Animation({}).animate(element, {\n                duration: duration,\n                progress: function () {\n                    var animateElement = getElement(element.id);\n                    animateElement.style.animation = '';\n                    if (label) {\n                        if (withInBounds(parseFloat(animateElement.getAttribute('x')), parseFloat(animateElement.getAttribute('y')), bounds)) {\n                            animateElement.style.visibility = 'visible';\n                        }\n                        else {\n                            animateElement.style.visibility = 'hidden';\n                        }\n                    }\n                    else {\n                        var direction = animateElement.getAttribute('d').split(' ');\n                        if (withInBounds(parseFloat(direction[1]), parseFloat(direction[2]), bounds)) {\n                            animateElement.style.visibility = 'visible';\n                        }\n                        else {\n                            animateElement.style.visibility = 'hidden';\n                        }\n                    }\n                },\n                end: function () {\n                    var animateElement = getElement(element.id);\n                    animateElement.style.visibility = '';\n                    if (isRemove && i >= axis.visibleLabels.length) {\n                        removeElement(animateElement);\n                        if (label) {\n                            if (axis.orientation === 'Vertical') {\n                                _this.previousYLabel = axis.visibleLabels.length;\n                            }\n                            else {\n                                _this.previousXLabel = axis.visibleLabels.length;\n                            }\n                        }\n                    }\n                }\n            });\n        }\n    };\n    /**\n     * To get X value based on lineBreakAlignment for Y axis line break labels only.\n     *\n     * @param {number} x text x position\n     * @param {Axis} axis y axis values\n     * @param {number} textWidth axis label width\n     * @returns {number} returns suitable axis label x position\n     */\n    CartesianAxisLayoutPanel.prototype.getAxisLabelXvalue = function (x, axis, textWidth) {\n        var anchor = axis.lineBreakAlignment;\n        var isLabelInside = axis.labelPosition === 'Inside';\n        var isOpposed = axis.isAxisOpposedPosition;\n        if ((isOpposed && isLabelInside) || (!isOpposed && !isLabelInside)) {\n            return (anchor === 'Right' ? x : (anchor === 'Center' ? (x - textWidth / 2) : (x - textWidth)));\n        }\n        else {\n            return (anchor === 'Left' ? x : (anchor === 'Center' ? (x + textWidth / 2) : (x + textWidth)));\n        }\n    };\n    /**\n     * To render the yAxis label border.\n     *\n     * @param {Axis} axis axis\n     * @param {number} index index\n     * @param {Element} parent parent\n     * @param {Rect} rect rect\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.drawYAxisBorder = function (axis, index, parent, rect) {\n        if (axis.border.width > 0) {\n            var startY = void 0;\n            var pointY = void 0;\n            var scrollBarHeight = (axis.labelPosition === 'Outside' && axis.scrollbarSettings.position !== 'Right' && axis.scrollbarSettings.position !== 'Left') ? axis.scrollBarHeight : 0;\n            var isOpposed = axis.isAxisOpposedPosition;\n            scrollBarHeight = (isOpposed ? 1 : -1) * scrollBarHeight;\n            var gap = (rect.height / axis.visibleRange.delta) * (axis.valueType === 'DateTime' ? axis.dateTimeInterval\n                : axis.visibleRange.interval);\n            var endY = void 0;\n            var length_1 = axis.maxLabelSize.width + 10 + ((axis.tickPosition === axis.labelPosition) ?\n                axis.majorTickLines.height : 0);\n            var labelBorder = '';\n            var ticksbwtLabel = (axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks') ? -0.5 : 0;\n            var endX = ((isOpposed && axis.labelPosition === 'Inside') || (!isOpposed\n                && axis.labelPosition === 'Outside')) ? rect.x - length_1 + scrollBarHeight : rect.x + length_1 + scrollBarHeight;\n            for (var i = 0, len = axis.visibleLabels.length; i < len; i++) {\n                pointY = valueToCoefficient(axis.visibleLabels[i].value + ticksbwtLabel, axis);\n                pointY = (axis.isAxisInverse ? (1 - pointY) : pointY) * rect.height;\n                if (axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks') {\n                    startY = (pointY * -1) + (rect.y + rect.height);\n                    endY = (pointY * -1) - (gap) + (rect.y + rect.height);\n                }\n                else {\n                    startY = (pointY * -1) + gap / 2 + (rect.y + rect.height);\n                    endY = (pointY * -1) - gap / 2 + (rect.y + rect.height);\n                }\n                switch (axis.border.type) {\n                    case 'Rectangle':\n                    case 'WithoutTopBorder':\n                        if (startY > (rect.y + rect.height)) {\n                            labelBorder += ('M' + ' ' + endX + ' ' + (rect.y + rect.height) + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ');\n                        }\n                        else if (Math.floor(rect.y) > (endY)) {\n                            labelBorder += ('M' + ' ' + (rect.x + scrollBarHeight) + ' ' + startY + ' ' + 'L' + ' ' + endX\n                                + ' ' + startY + ' ' + 'L' + ' ' + endX + ' ' + (rect.y) + ' ');\n                        }\n                        else {\n                            labelBorder += ('M' + ' ' + (rect.x + scrollBarHeight) + ' ' + startY + ' ' + 'L' + ' ' + endX +\n                                ' ' + startY + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ');\n                            if (i === axis.visibleLabels.length - 1) {\n                                labelBorder += ('M' + ' ' + (rect.x + scrollBarHeight) + ' ' + endY + ' ' + 'L' + ' ' +\n                                    endX + ' ' + endY + ' ');\n                            }\n                        }\n                        break;\n                    case 'WithoutTopandBottomBorder':\n                        if (!(startY > rect.y + rect.height) && !((endY) < Math.floor(rect.y))) {\n                            labelBorder += ('M' + ' ' + (rect.x + scrollBarHeight) + ' ' + startY + ' ' + 'L' + ' ' + endX +\n                                ' ' + startY + ' ' + 'M' + ' ' + endX + ' ' + endY + ' ' +\n                                'L' + ' ' + (rect.x + scrollBarHeight) + ' ' + endY);\n                        }\n                        break;\n                }\n            }\n            labelBorder += (axis.border.type === 'Rectangle') ? ('M' + ' ' + (rect.x + scrollBarHeight) + ' ' + rect.y + ' ' + 'L' + ' ' +\n                (rect.x + scrollBarHeight) + ' ' + (rect.y + rect.height) + ' ') : '';\n            if (labelBorder !== '') {\n                this.createAxisBorderElement(axis, index, labelBorder, parent);\n            }\n        }\n        for (var i = 0; i < this.chart.visibleSeries.length; i++) {\n            if (axis.multiLevelLabels.length > 0 && this.chart.multiLevelLabelModule && this.chart.visibleSeries[i].visible) {\n                this.chart.multiLevelLabelModule.renderYAxisMultiLevelLabels(axis, index, parent, rect);\n                break;\n            }\n        }\n    };\n    /**\n     * To render the yAxis title\n     *\n     * @param {Axis} axis axis\n     * @param {number} index index\n     * @param {Element} parent parent\n     * @param {Rect} rect rect\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.drawYAxisTitle = function (axis, index, parent, rect) {\n        if (axis.title) {\n            var chart = this.chart;\n            var isRotated = false;\n            var isOpposed = axis.isAxisOpposedPosition;\n            var labelRotation = (axis.titleRotation == null ? (isOpposed ? 90 : -90) : axis.titleRotation) % 360;\n            var padding = (axis.tickPosition === 'Inside' ? 0 : axis.majorTickLines.height + axis.titlePadding) +\n                (axis.labelPosition === 'Inside' ? 0 :\n                    (axis.maxLabelSize.width + axis.multiLevelLabelHeight + this.padding));\n            padding = (axis.tickPosition !== 'Outside' && (axis.tickPosition === 'Inside' || axis.labelPosition === 'Inside'))\n                ? (axis.titlePadding === 5 ? padding : padding + axis.titlePadding)\n                : padding;\n            padding = isOpposed ? padding + (axis.scrollbarSettings.position === 'Right' || axis.scrollbarSettings.position === 'Left' ? 0 : axis.scrollBarHeight) : -padding - (axis.scrollbarSettings.position === 'Right' || axis.scrollbarSettings.position === 'Left' ? 0 : axis.scrollBarHeight);\n            if ((labelRotation !== -90 && !isOpposed) || (labelRotation !== 90 && isOpposed)) {\n                padding += axis.isAxisOpposedPosition ? axis.titleSize.width / 2 + (axis.labelPosition === 'Inside' ? (axis.labelPadding !== 5 ? 0 : axis.labelPadding) : axis.labelPadding) :\n                    -axis.titleSize.width / 2 - (axis.labelPosition === 'Inside' ? (axis.labelPadding !== 5 ? 0 : axis.labelPadding) : axis.labelPadding);\n                isRotated = true;\n            }\n            var x = rect.x + padding;\n            var y = void 0;\n            var anchor = void 0;\n            if (axis.titleStyle.textAlignment === 'Center') {\n                anchor = 'middle';\n                y = rect.y + rect.height * 0.5;\n            }\n            else if (axis.titleStyle.textAlignment === 'Near') {\n                anchor = axis.opposedPosition ? 'end' : 'start';\n                y = rect.height + rect.y;\n            }\n            else {\n                anchor = axis.opposedPosition ? 'start' : 'end';\n                y = rect.y;\n            }\n            var titleSize = (axis.titleSize.height * (axis.titleCollection.length - 1));\n            var options = new TextOption(chart.element.id + '_AxisTitle_' + index, x, y + (isRotated ? -titleSize : -(axis.labelPosition === 'Inside' ? (axis.labelPadding !== 5 ? 0 : axis.labelPadding) : axis.labelPadding) - titleSize), anchor, axis.titleCollection, 'rotate(' + labelRotation + ',' + (x) + ',' + (y) + ')', null, labelRotation);\n            var element = textElement(chart.renderer, options, axis.titleStyle, axis.titleStyle.color || chart.themeStyle.axisTitleFont.color, parent, null, null, null, null, null, null, null, null, chart.enableCanvas, null, chart.themeStyle.axisTitleFont, new ChartLocation(x, y));\n            element.setAttribute('aria-hidden', 'true');\n        }\n    };\n    /**\n     * xAxis grid line calculation performed here\n     *\n     * @param {Axis} axis axis\n     * @param {number} index index\n     * @param {Element} parent parent\n     * @param {Rect} rect rect\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.drawXAxisGridLine = function (axis, index, parent, rect) {\n        var isLogAxis = axis.valueType === 'Logarithmic';\n        var isCategoryAxis = axis.valueType.indexOf('Category') > -1;\n        var tempInterval;\n        var pointX = 0;\n        var majorGrid = '';\n        var majorTick = '';\n        var minorDirection;\n        var count = 1;\n        var isOpposed = axis.isAxisOpposedPosition;\n        var tickSize = (isOpposed) ? -axis.majorTickLines.height : axis.majorTickLines.height;\n        var axisLineSize = (isOpposed) ? -axis.lineStyle.width * 0.5 : axis.lineStyle.width * 0.5;\n        var scrollBarHeight = (isNullOrUndefined(axis.crossesAt) && axis.scrollbarSettings.position !== 'Top' && axis.scrollbarSettings.position !== 'Bottom') ? isOpposed ? -axis.scrollBarHeight :\n            axis.scrollBarHeight : 0;\n        var ticksbwtLabel = (axis.valueType.indexOf('Category') > -1 && axis.labelPlacement === 'BetweenTicks' && !this.chart.stockChart) ?\n            0.5 : 0;\n        var length = axis.visibleLabels.length;\n        var isTickInside = axis.tickPosition === 'Inside';\n        var ticks = isTickInside ? (rect.y - tickSize - axisLineSize) : (rect.y + tickSize + axisLineSize + scrollBarHeight);\n        var chartThemeStyle = this.chart.themeStyle;\n        if (axis.valueType.indexOf('Category') > -1 && length > 0 && axis.labelPlacement === 'BetweenTicks' && !this.chart.stockChart) {\n            length += 1;\n        }\n        var numericIDs = this.calculateGridLineId(parent, length);\n        for (var i = 0; i < length; i++) {\n            if (axis.valueType !== 'DateTimeCategory') {\n                tempInterval = axis.visibleLabels[i] ? axis.visibleLabels[i].value - ticksbwtLabel\n                    : (axis.visibleLabels[i - 1].value + axis.visibleRange.interval) - ticksbwtLabel;\n            }\n            else {\n                tempInterval = axis.visibleLabels[i] ?\n                    axis.visibleLabels[i].value - ticksbwtLabel : axis.visibleRange.max;\n            }\n            pointX = (valueToCoefficient(tempInterval, axis) * rect.width) + rect.x;\n            if (pointX >= rect.x && (rect.x + rect.width) >= pointX) {\n                if (inside(tempInterval, axis.visibleRange) || this.isBorder(axis, i, pointX)) {\n                    if (this.chart.redraw && ((this.chart.pointsAdded && !this.chart.pointsRemoved) || this.chart.zoomRedraw) &&\n                        axis.majorGridLines.width && i !== 0 && axis.visible &&\n                        !getElement(this.chart.element.id + '_MajorGridLine_' + index + '_' + i) && !this.chart.enableCanvas) {\n                        var pointXValue = this.seriesClipRect.x + ((this.chart.enableRtl !== axis.isInversed) ?\n                            -((this.seriesClipRect.width / length) * count) : this.seriesClipRect.width +\n                            ((this.seriesClipRect.width / (i ? i : 1)) * count));\n                        majorGrid = 'M ' + pointXValue + ' ' + (this.seriesClipRect.y + this.seriesClipRect.height) +\n                            ' L ' + pointXValue + ' ' + this.seriesClipRect.y;\n                        this.renderGridLine(axis, index, majorGrid, axis.majorGridLines, '_MajorGridLine_', i, this.element, chartThemeStyle.majorGridLine, axis.majorGridLines.dashArray, (numericIDs['MajorGridLine'] && numericIDs['MajorGridLine'].ids ? numericIDs['MajorGridLine'].ids[i] : null), numericIDs['MajorGridLine'] ? numericIDs['MajorGridLine'].isPointRemoved : false);\n                        this.rangeAnimate(axis, this.element.childNodes[this.element.childNodes.length - 1], this.chart.duration, false, new Rect(this.seriesClipRect.x, axis.rect.y, this.seriesClipRect.x +\n                            this.seriesClipRect.width, this.chart.availableSize.height), false, i);\n                        if (getElement(parent.id)) {\n                            getElement(parent.id).appendChild(this.element.childNodes[this.element.childNodes.length - 1]);\n                        }\n                    }\n                    majorGrid = 'M ' + pointX + ' ' + (this.seriesClipRect.y + this.seriesClipRect.height) +\n                        ' L ' + pointX + ' ' + this.seriesClipRect.y;\n                    this.renderGridLine(axis, index, majorGrid, axis.majorGridLines, '_MajorGridLine_', i, this.element, chartThemeStyle.majorGridLine, axis.majorGridLines.dashArray, (numericIDs['MajorGridLine'] && numericIDs['MajorGridLine'].ids ? numericIDs['MajorGridLine'].ids[i] : null), numericIDs['MajorGridLine'] ? numericIDs['MajorGridLine'].isPointRemoved : false);\n                }\n                if (this.chart.redraw && this.chart.zoomRedraw && axis.majorTickLines.width && !getElement(this.chart.element.id + '_MajorTickLine_' + index + '_' + i) && !this.chart.enableCanvas && axis.visible) {\n                    majorTick = 'M ' + (this.seriesClipRect.x + ((this.chart.enableRtl !== axis.isInversed) ? -((this.seriesClipRect.width / length) * count) : this.seriesClipRect.width + ((this.seriesClipRect.width / (i ? i : 1)) * count))) + ' ' + (rect.y + axisLineSize + (isTickInside ? scrollBarHeight : 0))\n                        + ' L ' + (this.seriesClipRect.x + ((this.chart.enableRtl !== axis.isInversed) ? -((this.seriesClipRect.width / length) * count) : this.seriesClipRect.width + ((this.seriesClipRect.width / (i ? i : 1)) * count))) + ' ' + ticks;\n                    this.updateAxisElement(axis, index, majorTick, i, '_MajorTickLine_', parent, false);\n                    getElement(parent.id).appendChild(this.element.childNodes[this.element.childNodes.length - 1]);\n                    count += 1;\n                }\n                majorTick = 'M ' + (pointX) + ' ' + (rect.y + axisLineSize + (isTickInside ? scrollBarHeight : 0))\n                    + ' L ' + (pointX) + ' ' + ticks;\n                this.renderGridLine(axis, index, majorTick, axis.majorTickLines, '_MajorTickLine_', i, parent, chartThemeStyle.majorTickLine, null, (numericIDs['MajorTickLine'] && numericIDs['MajorTickLine'].ids ? numericIDs['MajorTickLine'].ids[i] : null), numericIDs['MajorTickLine'] ? numericIDs['MajorTickLine'].isPointRemoved : false);\n                if (axis.minorTicksPerInterval > 0 && (axis.minorGridLines.width > 0 || axis.minorTickLines.width > 0)) {\n                    if (i === 0 && isZoomSet(axis) && !isLogAxis && !isCategoryAxis) {\n                        this.renderMinorGridOnZooming(axis, tempInterval, rect, i, index, chartThemeStyle, parent);\n                    }\n                    minorDirection = this.drawAxisMinorLine(axis, tempInterval, rect, i);\n                    this.renderGridLine(axis, index, minorDirection[0], axis.minorGridLines, '_MinorGridLine_', i, this.element, chartThemeStyle.minorGridLine, axis.minorGridLines.dashArray, (numericIDs['MinorGridLine'] && numericIDs['MinorGridLine'].ids ? numericIDs['MinorGridLine'].ids[i] : null), numericIDs['MinorGridLine'] ? numericIDs['MinorGridLine'].isPointRemoved : false);\n                    this.renderGridLine(axis, index, minorDirection[1], axis.minorTickLines, '_MinorTickLine_', i, parent, chartThemeStyle.minorTickLine, null, (numericIDs['MinorTickLine'] && numericIDs['MinorTickLine'].ids ? numericIDs['MinorTickLine'].ids[i] : null), numericIDs['MinorTickLine'] ? numericIDs['MinorTickLine'].isPointRemoved : false);\n                    if (i === length - 1 && isZoomSet(axis) && isLogAxis && !isCategoryAxis) {\n                        this.renderMinorGridOnZooming(axis, (tempInterval + axis.visibleRange.interval), rect, i, index, chartThemeStyle, parent);\n                    }\n                }\n            }\n        }\n        if (length && this.previousXLabel > length && !this.chart.enableCanvas && axis.visible &&\n            this.chart.zoomRedraw && this.chart.redraw) {\n            for (var i = length; i < this.previousXLabel; i++) {\n                var pointXValue = this.seriesClipRect.x + ((this.chart.enableRtl !== axis.isInversed) ?\n                    -((this.seriesClipRect.width / length) * ((i - length) + 1)) :\n                    this.seriesClipRect.width + ((this.seriesClipRect.width / length) * ((i - length) + 1)));\n                if (axis.majorGridLines.width) {\n                    majorGrid = 'M ' + pointXValue + ' ' + (this.seriesClipRect.y + this.seriesClipRect.height) +\n                        ' L ' + pointXValue + ' ' + this.seriesClipRect.y;\n                    this.updateAxisElement(axis, index, majorGrid, i, '_MajorGridLine_', this.element, true);\n                }\n                if (axis.majorTickLines.width) {\n                    majorTick = 'M ' + (pointXValue) + ' ' + (rect.y + axisLineSize + (isTickInside ? scrollBarHeight : 0))\n                        + ' L ' + (pointXValue) + ' ' + ticks;\n                    this.updateAxisElement(axis, index, majorTick, i, '_MajorTickLine_', parent, true);\n                }\n            }\n        }\n    };\n    CartesianAxisLayoutPanel.prototype.calculateGridLineId = function (parent, length) {\n        var _this = this;\n        var numericIDs = {};\n        if (this.chart.pointsRemoved) {\n            var elementTypes = ['MajorGridLine', 'MajorTickLine', 'MinorGridLine', 'MinorTickLine'];\n            elementTypes.forEach(function (type) {\n                var parentElement = getElement(parent.id);\n                var elements = parentElement.querySelectorAll('[id*=\"_' + type + '_\"]');\n                var elementArray = [];\n                for (var i = 0; i < elements.length; i++) {\n                    elementArray.push(elements[i]);\n                }\n                var len = type === 'MajorGridLine' && _this.chart.chartArea.border.width ? length - 2 : length;\n                len = type === 'MinorGridLine' || type === 'MinorTickLine' ? length - 1 : len;\n                if (elementArray.length > 0 && elementArray.length > len) {\n                    var elementsLength = elementArray.length;\n                    for (var k = 0; k < elementsLength - len; k++) {\n                        if (elementArray[k]) {\n                            parentElement.removeChild(elementArray[k]);\n                        }\n                        elementArray.shift();\n                    }\n                    var numericIds = elementArray.map(function (element) {\n                        var parts = element.id.split('_');\n                        return parseInt(parts[parts.length - 1], 10);\n                    });\n                    numericIDs[type] = {\n                        ids: numericIds,\n                        isPointRemoved: true\n                    };\n                }\n            });\n        }\n        return numericIDs;\n    };\n    /**\n     * To render missing minor grid lines while zooming\n     *\n     * @param {Axis} axis axis\n     * @param {number} tempInterval tempInterval\n     * @param {Rect} rect rect\n     * @param {number} i i\n     * @param {number} index index\n     * @param {IThemeStyle} chartThemeStyle chartThemeStyle\n     * @param {Element} parent parent\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.renderMinorGridOnZooming = function (axis, tempInterval, rect, i, index, chartThemeStyle, parent) {\n        var minorDirection = this.drawAxisMinorLine(axis, tempInterval, rect, i, true);\n        this.renderGridLine(axis, index, minorDirection[0], axis.minorGridLines, '_MinorGridLine_', -1, this.element, chartThemeStyle.minorGridLine, axis.minorGridLines.dashArray);\n        this.renderGridLine(axis, index, minorDirection[1], axis.minorTickLines, '_MinorTickLine_', -1, parent, chartThemeStyle.minorTickLine);\n    };\n    /**\n     * To calcualte the axis minor line\n     *\n     * @param {Axis} axis axis\n     * @param {number} tempInterval tempInterval\n     * @param {Rect} rect rect\n     * @param {number} labelIndex labelIndex\n     * @param {boolean} isFirstLabel isFirstLabel\n     * @returns {string[]} axis minor line path\n     */\n    CartesianAxisLayoutPanel.prototype.drawAxisMinorLine = function (axis, tempInterval, rect, labelIndex, isFirstLabel) {\n        var value = tempInterval;\n        var coor = 0;\n        var position = 0;\n        var range = axis.visibleRange;\n        var isTickInside = axis.tickPosition === 'Inside';\n        var direction = [];\n        var tickSize = axis.isAxisOpposedPosition ? -axis.minorTickLines.height : axis.minorTickLines.height;\n        var logStart;\n        var logEnd;\n        var logInterval = 1;\n        var logPosition = 1;\n        var ticksX = isTickInside ? (rect.y - tickSize) : (rect.y + tickSize);\n        var ticksY = isTickInside ? (rect.x + tickSize) : (rect.x - tickSize);\n        var minorGird = '';\n        var minorTick = '';\n        var isInverse = axis.isAxisInverse;\n        if (axis.valueType === 'Logarithmic') {\n            logStart = Math.pow(axis.logBase, value - range.interval);\n            logEnd = Math.pow(axis.logBase, value);\n            logInterval = (logEnd - logStart) / (axis.minorTicksPerInterval + 1);\n            logPosition = logStart + logInterval;\n        }\n        if (axis.orientation === 'Horizontal') {\n            for (var j = 0; j < axis.minorTicksPerInterval; j++) {\n                value = this.findLogNumeric(axis, logPosition, value, labelIndex, isFirstLabel);\n                logPosition += logInterval;\n                if (inside(value, range)) {\n                    position = ((value - range.min) / (range.max - range.min));\n                    position = Math.ceil((isInverse ? (1 - position) : position) * rect.width);\n                    coor = (Math.floor(position + rect.x));\n                    if (this.chart.enableCanvas) {\n                        if (minorGird === '') {\n                            minorGird = 'M ' + coor + ' ' + this.seriesClipRect.y +\n                                ' L ' + coor + ' ' + (this.seriesClipRect.y + this.seriesClipRect.height);\n                        }\n                        else {\n                            minorGird = minorGird + ' M ' + coor + ' ' + this.seriesClipRect.y +\n                                ' L ' + coor + ' ' + (this.seriesClipRect.y + this.seriesClipRect.height);\n                        }\n                        coor = (Math.floor(position + rect.x));\n                        if (minorTick === '') {\n                            minorTick = minorTick.concat('M' + ' ' + coor + ' ' + (rect.y)\n                                + ' L ' + coor + ' ' + (ticksX + axis.scrollBarHeight));\n                        }\n                        else {\n                            minorTick = minorTick.concat(' M' + ' ' + coor + ' ' + (rect.y)\n                                + ' L ' + coor + ' ' + (ticksX + axis.scrollBarHeight));\n                        }\n                    }\n                    else {\n                        minorGird = minorGird.concat('M' + ' ' + coor + ' ' + (this.seriesClipRect.y)\n                            + 'L ' + coor + ' ' + (this.seriesClipRect.y + this.seriesClipRect.height));\n                        coor = (Math.floor(position + rect.x));\n                        minorTick = minorTick.concat('M' + ' ' + coor + ' ' + (rect.y)\n                            + 'L ' + coor + ' ' + (ticksX + axis.scrollBarHeight));\n                    }\n                }\n            }\n        }\n        else {\n            for (var j = 0; j < axis.minorTicksPerInterval; j++) {\n                value = this.findLogNumeric(axis, logPosition, value, labelIndex, isFirstLabel);\n                if (inside(value, range)) {\n                    position = ((value - range.min) / (range.max - range.min));\n                    position = Math.ceil(((isInverse ? (1 - position) : position)) * rect.height) * -1; // For inversed axis\n                    coor = (Math.floor(position + rect.y + rect.height));\n                    if (this.chart.enableCanvas) {\n                        if (minorGird === '') {\n                            minorGird = 'M ' + this.seriesClipRect.x + ' ' + coor +\n                                ' L ' + (this.seriesClipRect.x + this.seriesClipRect.width) + ' ' + coor;\n                        }\n                        else {\n                            minorGird = minorGird + ' M ' + this.seriesClipRect.x + ' ' + coor +\n                                ' L ' + (this.seriesClipRect.x + this.seriesClipRect.width) + ' ' + coor;\n                        }\n                        coor = (Math.floor(position + rect.y + rect.height));\n                        if (minorTick === '') {\n                            minorTick = minorTick.concat('M' + ' ' + rect.x + ' ' + coor + ' L ' + (ticksY - axis.scrollBarHeight) +\n                                ' ' + coor + ' ');\n                        }\n                        else {\n                            minorTick = minorTick.concat(' M' + ' ' + rect.x + ' ' + coor + ' L ' + (ticksY - axis.scrollBarHeight) +\n                                ' ' + coor + ' ');\n                        }\n                    }\n                    else {\n                        minorGird = minorGird.concat('M' + ' ' + (this.seriesClipRect.x) + ' ' + coor\n                            + 'L ' + (this.seriesClipRect.x + this.seriesClipRect.width) + ' ' + coor + ' ');\n                        coor = (Math.floor(position + rect.y + rect.height));\n                        minorTick = minorTick.concat('M' + ' ' + rect.x + ' ' + coor + 'L ' + (ticksY - axis.scrollBarHeight) +\n                            ' ' + coor + ' ');\n                    }\n                }\n                logPosition += logInterval;\n            }\n        }\n        direction.push(minorGird);\n        direction.push(minorTick);\n        return direction;\n    };\n    /**\n     * To find the numeric value of the log\n     *\n     * @param {Axis} axis axis\n     * @param {number} logPosition logPosition\n     * @param {number} value value\n     * @param {number} labelIndex labelIndex\n     * @param {boolean} isFirstLabel isFirstLabel\n     * @returns {number} value\n     */\n    CartesianAxisLayoutPanel.prototype.findLogNumeric = function (axis, logPosition, value, labelIndex, isFirstLabel) {\n        var range = axis.visibleRange;\n        var tempValue;\n        if (axis.valueType === 'Logarithmic') {\n            value = logBase(logPosition, axis.logBase);\n        }\n        else if (axis.valueType === 'DateTime') {\n            tempValue = axis.dateTimeInterval / (axis.minorTicksPerInterval + 1);\n            value = isFirstLabel ? (value - tempValue) : (value + tempValue);\n        }\n        else if (axis.valueType === 'DateTimeCategory') {\n            var padding = axis.labelPlacement === 'BetweenTicks' ? 0.5 : 0;\n            value += ((axis.visibleLabels[labelIndex + 1] ?\n                axis.visibleLabels[labelIndex + 1].value - padding : axis.visibleRange.max) -\n                (axis.visibleLabels[labelIndex] ?\n                    axis.visibleLabels[labelIndex].value - padding : axis.visibleRange.min)) /\n                (axis.minorTicksPerInterval + 1);\n        }\n        else {\n            tempValue = range.interval / (axis.minorTicksPerInterval + 1);\n            value = isFirstLabel ? (value - tempValue) : (value + tempValue);\n        }\n        return value;\n    };\n    /**\n     * To render the xAxis Labels\n     *\n     * @param {Axis} axis axis\n     * @param {number} index index\n     * @param {Element} parent parent\n     * @param {Rect} rect rect\n     * @returns {void}\n     * @private\n     */\n    CartesianAxisLayoutPanel.prototype.drawXAxisLabels = function (axis, index, parent, rect) {\n        var chart = this.chart;\n        var pointX = 0;\n        var pointY = 0;\n        var previousLabel = 0;\n        var labelSpace = axis.labelPadding;\n        var labelHeight;\n        var elementSize;\n        var labelPadding;\n        var anchor;\n        var pixel = 10;\n        var labelElement = chart.renderer.createGroup({ id: chart.element.id + 'AxisLabels' + index });\n        var islabelInside = axis.labelPosition === 'Inside';\n        var isOpposed = axis.isAxisOpposedPosition;\n        var tickSpace = axis.labelPosition === axis.tickPosition ? axis.majorTickLines.height : 0;\n        var padding = tickSpace + labelSpace + axis.lineStyle.width * 0.5;\n        var angle = axis.angle % 360;\n        var isHorizontalAngle = (angle === 0 || angle === -180 || angle === 180);\n        var options;\n        var labelWidth;\n        var isInverse = axis.isAxisInverse;\n        var isLeft;\n        var count = 1;\n        var previousEnd = isInverse ? (rect.x + rect.width) : rect.x;\n        var width = 0;\n        var length = axis.visibleLabels.length;\n        var intervalLength;\n        var label;\n        var isAxisBreakLabel;\n        var scrollBarHeight = axis.scrollbarSettings.enable || (!islabelInside && isNullOrUndefined(axis.crossesAt)\n            && (axis.zoomFactor < 1 || axis.zoomPosition > 0)) ? axis.scrollbarSettings.position === 'Top' || axis.scrollbarSettings.position === 'Bottom' ? 0 : axis.scrollBarHeight : 0;\n        var newPoints = [];\n        var isRotatedLabelIntersect = false;\n        var textPoints = [];\n        var rotatedLabelSize = new Size(0, 0);\n        padding += (angle === 90 || angle === 270 || angle === -90 || angle === -270) ? (islabelInside ? 5 : -5) : 0;\n        var isLabelUnderAxisLine = ((!isOpposed && !islabelInside) || (isOpposed && islabelInside));\n        var axislabelElement = getElement(chart.element.id + 'AxisLabels' + index);\n        var pointsRemoved = this.removeAxisLabelElements(axis, axislabelElement);\n        var legendWidth = (chart.legendModule && chart.legendSettings.position === 'Right' && chart.legendModule.legendBounds.height + chart.legendModule.legendBounds.y >= axis.rect.y) ? chart.legendModule.legendBounds.width : 0;\n        var isEndAnchor = isLabelUnderAxisLine ?\n            ((360 >= angle && angle >= 180) || (-1 >= angle && angle >= -180)) :\n            ((1 <= angle && angle <= 180) || (-181 >= angle && angle >= -360));\n        for (var i = 0, len = length; i < len; i++) {\n            label = axis.visibleLabels[i];\n            isAxisBreakLabel = isBreakLabel(label.originalText) || (axis.labelIntersectAction === 'Wrap' && label.text.length > 1);\n            pointX = (valueToCoefficient(label.value, axis) * rect.width) + rect.x;\n            elementSize = label.size;\n            if (axis.enableWrap) {\n                elementSize.height = measureText(label.text, axis.labelStyle, chart.themeStyle.axisLabelFont).height;\n            }\n            intervalLength = rect.width / length;\n            labelWidth = isAxisBreakLabel ? label.breakLabelSize.width : elementSize.width;\n            width = ((axis.labelIntersectAction === 'Trim' || axis.labelIntersectAction === 'Wrap') && angle === 0 &&\n                labelWidth > intervalLength) ? intervalLength : labelWidth;\n            labelHeight = elementSize.height / 4;\n            pointX -= (isAxisBreakLabel || angle !== 0) ? 0 : (width / 2);\n            // label X value adjustment for label rotation (Start)\n            if (angle !== 0) {\n                if (isAxisBreakLabel) {\n                    pointX -= axis.lineBreakAlignment === 'Left' ? (label.breakLabelSize.width / 2) : axis.lineBreakAlignment === 'Right' ?\n                        -(label.breakLabelSize.width / 2) : 0;\n                }\n                else {\n                    pointX -= (angle === -90 || angle === 270 ? -labelHeight : (angle === 90 || angle === -270) ? labelHeight : 0);\n                }\n            }\n            // label X value adjustment for label rotation (End)\n            if (axis.labelStyle.textAlignment === 'Far') {\n                pointX = pointX + width - pixel;\n            }\n            else if (axis.labelStyle.textAlignment === 'Near') {\n                pointX = pointX - width + pixel;\n            }\n            // For line break label alignment like left, right & center in angle 0\n            if (isAxisBreakLabel && axis.lineBreakAlignment !== 'Center' && angle === 0) {\n                pointX += axis.lineBreakAlignment === 'Left' ? -(width / 2) : (width / 2);\n            }\n            var paddingForBreakLabel = isAxisBreakLabel ?\n                (isHorizontalAngle ? (axis.opposedPosition || islabelInside ? 0 : elementSize.height) :\n                    (label.breakLabelSize.width / 2)) : 0;\n            padding = isAxisBreakLabel ? (tickSpace + labelSpace + axis.lineStyle.width * 0.5) : padding;\n            // label Y value adjustment (Start)\n            if (islabelInside && angle) {\n                if (isAxisBreakLabel) {\n                    pointY = isOpposed ? (rect.y + padding + (paddingForBreakLabel)) : (rect.y - padding - (paddingForBreakLabel));\n                }\n                else {\n                    pointY = isOpposed ? (rect.y + padding + labelHeight) : (rect.y - padding - labelHeight);\n                }\n            }\n            else {\n                if (isAxisBreakLabel) {\n                    labelPadding = !isLabelUnderAxisLine ? -(padding + scrollBarHeight + (paddingForBreakLabel)) :\n                        padding + scrollBarHeight + (angle ? paddingForBreakLabel : (3 * labelHeight));\n                }\n                else {\n                    labelPadding = !isLabelUnderAxisLine ?\n                        -(padding + scrollBarHeight + (angle ? labelHeight : (label.index > 1 ? (2 * labelHeight) : 0))) :\n                        padding + scrollBarHeight + ((angle ? 1 : 3) * labelHeight);\n                }\n                pointY = (rect.y + (labelPadding * label.index));\n            }\n            // label Y value adjustment (End)\n            if (isAxisBreakLabel) {\n                anchor = this.getAnchor(axis); // for break label self alignment\n            }\n            else {\n                anchor = (chart.enableRtl) ? ((isEndAnchor) ? '' : 'end') : (chart.isRtlEnabled || isEndAnchor) ? 'end' : 'start';\n            }\n            options = new TextOption(chart.element.id + index + '_AxisLabel_' + i, pointX, pointY, anchor);\n            options.id = pointsRemoved && axislabelElement &&\n                axislabelElement.children[i] ? axislabelElement.children[i].id : options.id;\n            if (angle !== 0) {\n                rotatedLabelSize = rotateTextSize(label.labelStyle, label.originalText, angle, chart, chart.themeStyle.axisLabelFont);\n                isLeft = ((angle < 0 && angle > -90) || (angle < -180 && angle > -270) ||\n                    (angle > 90 && angle < 180) || (angle > 270 && angle < 360));\n            }\n            if (axis.edgeLabelPlacement) {\n                switch (axis.edgeLabelPlacement) {\n                    case 'None':\n                        break;\n                    case 'Hide':\n                        if (((i === 0 || (isInverse && i === len - 1)) && options.x < rect.x) ||\n                            ((i === len - 1 || (isInverse && i === 0)) &&\n                                (options.x + (angle === 0 ? width : rotatedLabelSize.width) > rect.x + rect.width))) {\n                            continue;\n                        }\n                        break;\n                    case 'Shift':\n                        if (i === len - 2 && axis.labelIntersectAction !== 'MultipleRows') {\n                            if (anchor === 'start' || anchor === '') {\n                                previousLabel = options.x + width; // For start anchor\n                            }\n                            else if (anchor === 'middle') {\n                                previousLabel = options.x + (width / 2); // For middle anchor\n                            }\n                            else {\n                                previousLabel = options.x; // For end anchor\n                            }\n                        }\n                        if ((i === 0 || (isInverse && i === len - 1)) && (options.x < rect.x || (angle !== 0 && isLeft && options.x < rect.x) || (axis.lineBreakAlignment === 'Center' && options.x - (label.size.width / label.text.length) / 2 < rect.x && angle === 0))) {\n                            intervalLength -= (rect.x - options.x);\n                            if (anchor === '' || anchor === 'start') {\n                                if (options.x <= 0) {\n                                    pointX = options.x = 0;\n                                }\n                                else {\n                                    pointX = options.x;\n                                }\n                                intervalLength = rect.width / length;\n                            }\n                            else if (isLeft && angle !== 0) {\n                                intervalLength = rect.width / length;\n                                if (rect.x + intervalLength > options.x + rotatedLabelSize.width) {\n                                    options.x = pointX = rect.x + padding;\n                                }\n                                else {\n                                    options.x = pointX = rect.x + intervalLength - padding;\n                                }\n                            }\n                            else if (isAxisBreakLabel && axis.lineBreakAlignment === 'Center' && axis.labelPlacement === 'OnTicks' && angle === 0) {\n                                var maxWidth = 0;\n                                for (var i_1 = 0; i_1 < label.text.length; i_1++) {\n                                    var breakLabelWidth = measureText(label.text[i_1], axis.labelStyle, chart.themeStyle.axisLabelFont).width;\n                                    if (breakLabelWidth > maxWidth) {\n                                        maxWidth = breakLabelWidth;\n                                    }\n                                }\n                                options.x = pointX = rect.x + maxWidth / 2;\n                            }\n                            else if (!(anchor === 'start' && options.x > 0)) {\n                                options.x = pointX = !isHorizontalAngle ? rect.x + padding : rect.x;\n                            }\n                        }\n                        else if ((i === len - 1 || (isInverse && i === 0)) &&\n                            (((options.x + width) > chart.availableSize.width - chart.border.width - legendWidth && (anchor === 'start' || anchor === '') && angle === 0) ||\n                                ((anchor === '') && angle !== 0 && !isLeft && (options.x + rotatedLabelSize.width) > chart.availableSize.width - chart.border.width - legendWidth) ||\n                                (anchor === 'middle' && angle !== 0 && !isLeft && (options.x + rotatedLabelSize.width / 2) > chart.availableSize.width - chart.border.width - legendWidth) ||\n                                (anchor === 'end' && angle !== 0 && !isLeft && options.x > chart.availableSize.width - chart.border.width - legendWidth) ||\n                                (anchor === 'end' && options.x > chart.availableSize.width - chart.border.width - legendWidth && angle === 0) ||\n                                (anchor === 'middle' && (options.x + width / 2) > chart.availableSize.width - chart.border.width - legendWidth && angle === 0))) {\n                            var axisLabelWidth = angle !== 0 ? rotatedLabelSize.width : width;\n                            var shiftedXValue = void 0;\n                            //Apply a default 5px padding between the edge label and the chart container\n                            var padding_1 = 5;\n                            if (anchor === 'start' || anchor === '') {\n                                shiftedXValue = options.x - ((options.x + axisLabelWidth) -\n                                    chart.availableSize.width + chart.border.width + padding_1 + legendWidth);\n                            }\n                            else if (anchor === 'middle') {\n                                shiftedXValue = options.x - ((options.x + axisLabelWidth / 2) -\n                                    chart.availableSize.width + chart.border.width + padding_1 + legendWidth);\n                            }\n                            else {\n                                shiftedXValue = options.x - (options.x - (chart.availableSize.width + chart.border.width + padding_1\n                                    + legendWidth));\n                            }\n                            // Check for overlap with previous label\n                            if (previousLabel !== 0 && shiftedXValue < previousLabel) {\n                                var maxAvailableWidth = chart.availableSize.width - previousLabel;\n                                label.text = textTrim(maxAvailableWidth, label.originalText, axis.labelStyle, chart.isRtlEnabled, chart.themeStyle.axisLabelFont);\n                            }\n                            else {\n                                options.x = pointX = shiftedXValue;\n                            }\n                        }\n                        break;\n                }\n            }\n            options.text = this.getLabelText(label, axis, intervalLength);\n            options.labelRotation = angle;\n            // ------- Hide Calculation (Start) -------------\n            // Currect label actual start value (Start)\n            var xValue = void 0;\n            var xValue2 = void 0;\n            if (isAxisBreakLabel && angle === 0) {\n                if (axis.lineBreakAlignment === 'Right') {\n                    xValue = (options.x - width);\n                    xValue2 = options.x;\n                }\n                else if (axis.lineBreakAlignment === 'Center') {\n                    xValue = (options.x - (width / 2));\n                    xValue2 = options.x + (width / 2);\n                }\n                else {\n                    xValue = options.x;\n                    xValue2 = options.x + width;\n                }\n            }\n            else {\n                xValue = options.x;\n                xValue2 = options.x + width;\n            }\n            // Currect label actual start value (End)\n            if (angle === 0 && axis.labelIntersectAction === 'Hide' && i !== 0 &&\n                (!isInverse ? xValue <= previousEnd : xValue2 >= previousEnd)) {\n                continue;\n            }\n            // Previous label actual end value (Start)\n            if (isAxisBreakLabel) {\n                if (axis.lineBreakAlignment === 'Right') {\n                    previousEnd = isInverse ? (options.x - width) : options.x;\n                }\n                else if (axis.lineBreakAlignment === 'Center') {\n                    previousEnd = isInverse ? (options.x - (width / 2)) : options.x + (width / 2);\n                }\n                else {\n                    previousEnd = isInverse ? options.x : options.x + width;\n                }\n            }\n            else {\n                previousEnd = isInverse ? options.x : options.x + width;\n            }\n            // Previous label actual end value (End)\n            // ------- Hide Calculation (End) -------------\n            // label Rotataion calculation (Start)\n            if (angle !== 0) {\n                var height = void 0;\n                var rect_1 = void 0;\n                if (isAxisBreakLabel) {\n                    var xAdjustment = 0;\n                    var yAdjustment = 0;\n                    height = (label.breakLabelSize.height);\n                    yAdjustment = (label.breakLabelSize.height) - 4; // 4 for label bound correction\n                    // xAdjustment (Start)\n                    if (axis.lineBreakAlignment === 'Center') {\n                        xAdjustment = -(label.breakLabelSize.width / 2);\n                    }\n                    else if (axis.lineBreakAlignment === 'Right') {\n                        xAdjustment = -label.breakLabelSize.width;\n                    }\n                    // xAdjustment (End)\n                    if (isLabelUnderAxisLine) {\n                        yAdjustment = (label.breakLabelSize.height) / (options.text.length + 1);\n                    }\n                    rect_1 = new Rect(options.x + xAdjustment, options.y - (yAdjustment), label.breakLabelSize.width, height);\n                }\n                else {\n                    height = (pointY) - (options.y - ((label.size.height / 2)));\n                    rect_1 = new Rect(options.x, options.y - ((label.size.height / 2) - 5), label.size.width, height);\n                }\n                var rectCoordinates = this.getRectanglePoints(rect_1);\n                var rectCenterX = isAxisBreakLabel ? rect_1.x + (rect_1.width / 2) : pointX;\n                var rectCenterY = isAxisBreakLabel ? rect_1.y + (rect_1.height / 2) : (pointY - (height / 2));\n                if (isAxisBreakLabel) {\n                    options.transform = 'rotate(' + angle + ',' + rectCenterX + ',' + rectCenterY + ')';\n                }\n                else {\n                    options.transform = 'rotate(' + angle + ',' + pointX + ',' + pointY + ')';\n                }\n                newPoints.push(getRotatedRectangleCoordinates(rectCoordinates, rectCenterX, rectCenterY, angle));\n                isRotatedLabelIntersect = false;\n                if (axis.labelIntersectAction !== 'None') {\n                    for (var index_1 = i; index_1 > 0; index_1--) {\n                        if (newPoints[i] && newPoints[index_1 - 1] &&\n                            isRotatedRectIntersect(newPoints[i], newPoints[index_1 - 1])) {\n                            isRotatedLabelIntersect = true;\n                            newPoints[i] = null;\n                            break;\n                        }\n                    }\n                }\n                var rotateAngle = ((angle > 0 && angle < 90) || (angle > 180 && angle < 270) ||\n                    (angle < -90 && angle > -180) || (angle < -270 && angle > -360));\n                var textRect = new Rect(options.x, options.y - (elementSize.height / 2 + padding / 2), label.size.width, height);\n                var textRectCoordinates = this.getRectanglePoints(textRect);\n                var rectPoints = [];\n                rectPoints.push(new ChartLocation(rotateAngle ? this.chart.availableSize.width : this.padding, axis.rect.y));\n                rectPoints.push(new ChartLocation(rotateAngle ? this.chart.availableSize.width :\n                    this.padding, axis.rect.y + axis.maxLabelSize.height));\n                textPoints.push(getRotatedRectangleCoordinates(textRectCoordinates, rectCenterX, rectCenterY, angle));\n                var newRect = new Rect(0, axis.rect.y, this.chart.availableSize.width, axis.maxLabelSize.height * 2);\n                for (var k = 0; k < textPoints[i].length; k++) {\n                    if (!axis.opposedPosition && !withInBounds(textPoints[i][k].x, textPoints[i][k].y, newRect) && typeof options.text === 'string') {\n                        var interSectPoint = this.calculateIntersection(textPoints[i][0], textPoints[i][1], rectPoints[0], rectPoints[1]);\n                        var rectPoint1 = rotateAngle ? this.chart.availableSize.width - pointX : pointX;\n                        var rectPoint2 = interSectPoint.y - axis.rect.y;\n                        var trimValue = Math.sqrt((rectPoint1 * rectPoint1) + (rectPoint2 * rectPoint2));\n                        options.text = textTrim(trimValue, label.text, label.labelStyle, chart.enableRtl, chart.themeStyle.axisLabelFont);\n                    }\n                }\n            }\n            if (this.chart.redraw && ((chart.pointsAdded && !chart.pointsRemoved) || this.chart.zoomRedraw) &&\n                !getElement(options.id) && i !== 0 && !this.chart.enableCanvas && axis.visible) {\n                var optionsX = options.x;\n                options.x = this.seriesClipRect.x + ((chart.enableRtl !== axis.isInversed) ? -((this.seriesClipRect.width / (i ? i : 1))\n                    * count) : this.seriesClipRect.width + (this.seriesClipRect.width / (i ? i : 1)) * count);\n                var transform = options.transform;\n                options.transform = angle ? 'rotate(' + angle + ',' + options.x + ',' + parseFloat(options.transform.split(',')[2]) + ')' : '';\n                var element_1 = textElement(chart.renderer, options, label.labelStyle, label.labelStyle.color || chart.themeStyle.axisLabelFont.color, labelElement, (axis.isAxisOpposedPosition !== (axis.labelPosition === 'Inside')), chart.redraw, true, null, chart.duration, null, label.size, isRotatedLabelIntersect, chart.enableCanvas, null, chart.themeStyle.axisLabelFont);\n                this.rangeAnimate(axis, element_1, this.chart.duration, true, new Rect(this.seriesClipRect.x, axis.rect.y, this.seriesClipRect.x + this.seriesClipRect.width, this.chart.availableSize.height), false, i);\n                options.x = optionsX;\n                options.transform = transform;\n                count += 1;\n            }\n            // label Rotataion calculation (End)\n            var element = textElement(chart.renderer, options, label.labelStyle, label.labelStyle.color || chart.themeStyle.axisLabelFont.color, labelElement, (axis.isAxisOpposedPosition !== (axis.labelPosition === 'Inside')), chart.redraw, true, null, chart.duration, null, label.size, isRotatedLabelIntersect, chart.enableCanvas, null, chart.themeStyle.axisLabelFont, new ChartLocation(parseFloat(options.transform.split(',')[1]), parseFloat(options.transform.split(',')[2])));\n            if (pointsRemoved) {\n                element.id = chart.element.id + index + '_AxisLabel_' + i;\n            }\n        }\n        if (this.previousXLabel && length && this.previousXLabel > length && !this.chart.enableCanvas &&\n            axis.visible && this.chart.zoomRedraw && this.chart.redraw && options.text) {\n            for (var i = length; i < this.previousXLabel; i++) {\n                options.x = this.seriesClipRect.x + ((chart.enableRtl !== axis.isInversed) ? -((this.seriesClipRect.width / length) *\n                    (i - length + 1)) : this.seriesClipRect.width + ((this.seriesClipRect.width / length) * (i - length + 1)));\n                options.id = chart.element.id + index + '_AxisLabel_' + i;\n                options.transform = angle ? 'rotate(' + angle + ',' + options.x + ',' + parseFloat(options.transform.split(',')[2]) + ')' : '';\n                this.updateAxisElement(axis, index, '', i, '_AxisLabel_', labelElement, true, options, label);\n            }\n        }\n        else {\n            this.previousXLabel = length;\n        }\n        if (!this.chart.enableCanvas) {\n            if (!chart.delayRedraw) {\n                parent.appendChild(labelElement);\n            }\n            else if (axis.visible && axis.internalVisibility) {\n                this.createZoomingLabel(this.chart, labelElement, axis, index, rect);\n            }\n        }\n    };\n    /**\n     * To render the axis grid, tick lines and label\n     *\n     * @param {Axis} axis axis\n     * @param {number} index index\n     * @param {string} gridDirection gridDirection\n     * @param {number} i index of the element\n     * @param {string} elementId elementId\n     * @param {Element} parentElement parent\n     * @param {boolean} isRemove isRemoved\n     * @param {TextOption} option - The options for the text element.\n     * @param {VisibleLabels} label - Label.\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.updateAxisElement = function (axis, index, gridDirection, i, elementId, parentElement, isRemove, option, label) {\n        var element;\n        var isGrid = elementId.indexOf('Grid') > -1;\n        var isLabel = elementId.indexOf('Label') > -1;\n        if (isLabel) {\n            element = textElement(this.chart.renderer, option, label.labelStyle, label.labelStyle.color || this.chart.themeStyle.axisLabelFont.color, parentElement, (axis.isAxisOpposedPosition !== (axis.labelPosition === 'Inside')), this.chart.redraw, true, null, this.chart.duration, null, null, null, this.chart.enableCanvas, null, this.chart.themeStyle.axisLabelFont);\n        }\n        else {\n            this.renderGridLine(axis, index, gridDirection, isGrid ? axis.majorGridLines : axis.majorTickLines, elementId, i, this.element, isGrid ? this.chart.themeStyle.majorGridLine : this.chart.themeStyle.majorTickLine, isGrid ? axis.majorGridLines.dashArray : null);\n            if (this.element && parentElement.childNodes) {\n                element = this.element.childNodes[parentElement.childNodes.length - 1];\n            }\n        }\n        this.rangeAnimate(axis, element, this.chart.duration, isLabel, new Rect((axis.orientation === 'Vertical') ? 0 : this.seriesClipRect.x, (axis.orientation === 'Vertical') ? this.seriesClipRect.y : axis.rect.y, this.seriesClipRect.width, this.seriesClipRect.height), isRemove, i);\n    };\n    CartesianAxisLayoutPanel.prototype.removeAxisLabelElements = function (axis, axislabelElement) {\n        if (this.chart.pointsRemoved && axislabelElement && axislabelElement.childNodes.length) {\n            var pointsRemoved = false;\n            if (axis.valueType.indexOf('Category') > -1) {\n                var visibleLabelTexts_1 = [];\n                axis.visibleLabels.map(function (label) {\n                    if (typeof label.text !== 'string') {\n                        visibleLabelTexts_1.push(label.text.join(''));\n                    }\n                    else {\n                        visibleLabelTexts_1.push(label.text);\n                    }\n                });\n                for (var i = axislabelElement.childNodes.length - 1; i >= 0; i--) {\n                    var childNode = axislabelElement.childNodes[i];\n                    if (visibleLabelTexts_1.indexOf(childNode.textContent.trim()) === -1) {\n                        axislabelElement.removeChild(childNode);\n                        pointsRemoved = true;\n                    }\n                }\n            }\n            else if (axislabelElement.childNodes.length > axis.visibleLabels.length) {\n                for (var j = 0; j < axislabelElement.childNodes.length - axis.visibleLabels.length; j++) {\n                    axislabelElement.removeChild(axislabelElement.childNodes[j]);\n                    pointsRemoved = true;\n                }\n            }\n            return pointsRemoved;\n        }\n        return false;\n    };\n    CartesianAxisLayoutPanel.prototype.calculateIntersection = function (p1, p2, p3, p4) {\n        var c2x = p3.x - p4.x;\n        var c3x = p1.x - p2.x;\n        var c2y = p3.y - p4.y;\n        var c3y = p1.y - p2.y;\n        var d = c3x * c2y - c3y * c2x;\n        var u1 = p1.x * p2.y - p1.y * p2.x;\n        var u4 = p3.x * p4.y - p3.y * p4.x;\n        var px = (u1 * c2x - c3x * u4) / d;\n        var py = (u1 * c2y - c3y * u4) / d;\n        var p = { x: px, y: py };\n        return p;\n    };\n    /**\n     * To get text anchor value for line break labels.\n     *\n     * @param {Axis} axis axis model\n     * @returns {string} returns text anchor\n     */\n    CartesianAxisLayoutPanel.prototype.getAnchor = function (axis) {\n        return (axis.lineBreakAlignment === 'Center' ? 'middle' : (this.chart.enableRtl) ? (axis.lineBreakAlignment === 'Left' ? 'end' : 'start') : (axis.lineBreakAlignment === 'Left' ? 'start' : 'end'));\n    };\n    /**\n     * Get rect coordinates\n     *\n     * @param {Rect} rect rect\n     * @returns {ChartLocation[]} rectangle points\n     */\n    CartesianAxisLayoutPanel.prototype.getRectanglePoints = function (rect) {\n        var point1 = new ChartLocation(rect.x, rect.y);\n        var point2 = new ChartLocation(rect.x + rect.width, rect.y);\n        var point3 = new ChartLocation(rect.x + rect.width, rect.y + rect.height);\n        var point4 = new ChartLocation(rect.x, rect.y + rect.height);\n        return [point1, point2, point3, point4];\n    };\n    /**\n     * To get axis label text\n     *\n     * @param {VisibleLabels} label label\n     * @param {Axis} axis axis\n     * @param {number} intervalLength intervalLength\n     * @returns {string | string[]} label or label collection\n     */\n    CartesianAxisLayoutPanel.prototype.getLabelText = function (label, axis, intervalLength) {\n        if (isBreakLabel(label.originalText)) {\n            var result = [];\n            var str = void 0;\n            for (var index = 0; index < label.text.length; index++) {\n                str = this.findAxisLabel(axis, label.text[index], intervalLength);\n                result.push(str);\n            }\n            return result;\n        }\n        else {\n            return this.findAxisLabel(axis, label.text, intervalLength);\n        }\n    };\n    /**\n     * To render the x-axis label border.\n     *\n     * @param {Axis} axis axis\n     * @param {number} index index\n     * @param {Element} parent parent\n     * @param {Rect} axisRect axisRect\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.drawXAxisBorder = function (axis, index, parent, axisRect) {\n        if (axis.border.width > 0) {\n            var scrollBarHeight = (axis.labelPosition === 'Outside' && axis.scrollbarSettings.position !== 'Top' && axis.scrollbarSettings.position !== 'Bottom') ? axis.scrollBarHeight : 0;\n            var isOpposed = axis.isAxisOpposedPosition;\n            var startX = void 0;\n            var startY = axisRect.y + ((isOpposed ? -1 : 1) * scrollBarHeight);\n            var padding = 10;\n            var pointX = void 0;\n            var gap = (axisRect.width / axis.visibleRange.delta) * (axis.valueType === 'DateTime' ? axis.dateTimeInterval\n                : axis.visibleRange.interval);\n            var endX = void 0;\n            var length_2 = axis.maxLabelSize.height +\n                ((axis.tickPosition === axis.labelPosition) ? axis.majorTickLines.height : 0);\n            var labelBorder = '';\n            var ticksbwtLabel = (axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks') ? -0.5 : 0;\n            var endY = ((isOpposed && axis.labelPosition === 'Inside') ||\n                (!isOpposed && axis.labelPosition === 'Outside')) ?\n                (axisRect.y + length_2 + padding + scrollBarHeight) : (axisRect.y - length_2 - padding - scrollBarHeight);\n            for (var i = 0, len = axis.visibleLabels.length; i < len; i++) {\n                pointX = valueToCoefficient(axis.visibleLabels[i].value + ticksbwtLabel, axis);\n                pointX = (axis.isAxisInverse ? (1 - pointX) : pointX) * axisRect.width;\n                if (axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks') {\n                    startX = pointX + axisRect.x;\n                    endX = pointX + (gap) + axisRect.x;\n                }\n                else {\n                    startX = pointX - gap * 0.5 + axisRect.x;\n                    endX = pointX + gap * 0.5 + axisRect.x;\n                }\n                switch (axis.border.type) {\n                    case 'Rectangle':\n                    case 'WithoutTopBorder':\n                        if (startX < axisRect.x && axis.labelPlacement !== 'OnTicks') {\n                            labelBorder += ('M' + ' ' + axisRect.x + ' ' + endY + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ');\n                        }\n                        else if (Math.floor(endX) > axisRect.width + axisRect.x && !(axis.visibleLabels.length === 1) &&\n                            !(i === axis.visibleLabels.length - 1)) {\n                            labelBorder += ('M' + ' ' + startX + ' ' + startY + ' ' + 'L' + ' ' + startX + ' ' + endY + ' ' +\n                                'L' + ' ' + (axisRect.width + axisRect.x) + ' ' + endY + ' ');\n                        }\n                        else {\n                            startX = (i === 0 && axis.labelPlacement === 'OnTicks') ? axisRect.x : startX;\n                            endX = ((i === axis.visibleLabels.length - 1) && axis.labelPlacement === 'OnTicks') ? endX - gap * 0.5 : endX;\n                            labelBorder += ('M' + ' ' + startX + ' ' + startY + ' ' + 'L' + ' ' + startX + ' ' +\n                                endY + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ');\n                            if (i === 0) {\n                                labelBorder += ('M' + ' ' + startX + ' ' + startY + ' ' + 'L' + ' ' + startX + ' ' + endY + ' ' +\n                                    'M ' + startX + ' ' + endY + ' L ' + (axisRect.x) + ' ' + endY);\n                            }\n                            if (i === axis.visibleLabels.length - 1) {\n                                labelBorder += ('M' + ' ' + endX + ' ' + startY + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ' +\n                                    'M ' + endX + ' ' + endY + ' L ' + (axisRect.width + axisRect.x) + ' ' + endY);\n                            }\n                        }\n                        break;\n                    case 'WithoutTopandBottomBorder':\n                        if (!(startX < axisRect.x) && !(Math.floor(endX) > axisRect.width + axisRect.x)) {\n                            labelBorder += ('M' + ' ' + startX + ' ' + startY + ' ' + 'L' + ' ' + startX + ' ' + endY + ' ' +\n                                'M ' + endX + ' ' + startY + ' L ' + endX + ' ' + endY);\n                        }\n                        break;\n                }\n            }\n            labelBorder += (axis.border.type === 'Rectangle' ? ('M ' + ' ' + axisRect.x + ' ' + startY + 'L' + ' ' +\n                (axisRect.x + axisRect.width) + ' ' + startY) : '');\n            if (labelBorder !== '') {\n                this.createAxisBorderElement(axis, index, labelBorder, parent);\n            }\n        }\n        for (var i = 0; i < this.chart.visibleSeries.length; i++) {\n            if (this.chart.multiLevelLabelModule && axis.multiLevelLabels.length > 0 && this.chart.visibleSeries[i].visible) {\n                this.chart.multiLevelLabelModule.renderXAxisMultiLevelLabels(axis, index, parent, axisRect);\n                break;\n            }\n        }\n    };\n    /**\n     * To create border element of the axis\n     *\n     * @param {Axis} axis axis\n     * @param {number} index index\n     * @param {string} labelBorder labelBorder\n     * @param {Element} parent parent\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.createAxisBorderElement = function (axis, index, labelBorder, parent) {\n        var element = getElement(this.chart.element.id + '_BorderLine_' + index);\n        var direction = element ? element.getAttribute('d') : '';\n        var borderElement = this.chart.renderer.drawPath(new PathOption(this.chart.element.id + '_BorderLine_' + index, 'transparent', axis.border.width, axis.border.color || this.chart.themeStyle.axisLine, 1, '', labelBorder));\n        borderElement.style.pointerEvents = 'none';\n        appendChildElement(this.chart.enableCanvas, parent, borderElement, this.chart.redraw, false, 'x', 'y', null, direction, true, null, null, this.chart.duration);\n    };\n    /**\n     * To find the axis label of the intersect action\n     *\n     * @param {Axis} axis axis\n     * @param {string} label label\n     * @param {number} width width\n     * @returns {string} label\n     */\n    CartesianAxisLayoutPanel.prototype.findAxisLabel = function (axis, label, width) {\n        return (axis.labelIntersectAction === 'Trim' ?\n            ((axis.angle % 360 === 0 && !axis.enableTrim) ? textTrim(width, label, axis.labelStyle, this.chart.enableRtl, this.chart.themeStyle.axisLabelFont) : label) : label);\n    };\n    /**\n     * X-Axis Title function performed\n     *\n     * @param {Axis} axis axis\n     * @param {number} index index\n     * @param {Element} parent parent\n     * @param {Rect} rect rect\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.drawXAxisTitle = function (axis, index, parent, rect) {\n        if (axis.title) {\n            var chart = this.chart;\n            var elementSize = measureText(axis.title, axis.titleStyle, this.chart.themeStyle.axisTitleFont);\n            var scrollBarHeight = (isNullOrUndefined(axis.crossesAt) && axis.scrollbarSettings.position !== 'Top' && axis.scrollbarSettings.position !== 'Bottom') ? axis.scrollBarHeight : 0;\n            var padding = (axis.tickPosition === 'Inside' ? 0 : axis.majorTickLines.height + axis.titlePadding) +\n                (axis.labelPosition === 'Inside' ? 0 :\n                    axis.maxLabelSize.height + axis.multiLevelLabelHeight + axis.labelPadding);\n            padding = (axis.tickPosition !== 'Outside' && (axis.tickPosition === 'Inside' || axis.labelPosition === 'Inside'))\n                ? (axis.titlePadding === 5 ? padding : padding + axis.titlePadding)\n                : padding;\n            var titleSize = (axis.titleSize.height * (axis.titleCollection.length - 1));\n            padding = axis.isAxisOpposedPosition ? -(padding + elementSize.height / 4 + scrollBarHeight + titleSize) : (padding + (3 *\n                elementSize.height / 4) + scrollBarHeight);\n            var labelRotation = axis.titleRotation ? axis.titleRotation : 0;\n            var x = void 0;\n            var y = rect.y + padding;\n            var anchor = void 0;\n            if (axis.titleStyle.textAlignment === 'Center') {\n                anchor = 'middle';\n                x = rect.x + rect.width * 0.5;\n            }\n            else if (axis.titleStyle.textAlignment === 'Near') {\n                anchor = 'start';\n                x = rect.x;\n            }\n            else {\n                anchor = 'end';\n                x = rect.x + rect.width;\n            }\n            if (labelRotation !== 0) {\n                y += axis.opposedPosition ? -(axis.titleSize.height / 2 + elementSize.height / 4) :\n                    axis.titleSize.height / 2 - elementSize.height / 4;\n            }\n            var options = new TextOption(chart.element.id + '_AxisTitle_' + index, x, y, anchor, axis.titleCollection, 'rotate(' + labelRotation + ',' + (x) + ',' + (y) + ')', null, labelRotation);\n            var element = textElement(chart.renderer, options, axis.titleStyle, axis.titleStyle.color || chart.themeStyle.axisTitleFont.color, parent, null, chart.redraw, chart.redraw, null, null, null, null, null, chart.enableCanvas, null, chart.themeStyle.axisTitleFont, new ChartLocation(x, y));\n            element.setAttribute('aria-hidden', 'true');\n        }\n    };\n    /**\n     * To render the axis grid and tick lines(Both Major and Minor)\n     *\n     * @param {Axis} axis axis\n     * @param {number} index index\n     * @param {string} gridDirection gridDirection\n     * @param {MajorTickLinesModel | MinorTickLinesModel | MajorGridLinesModel | MinorGridLinesModel} gridModel gridModel\n     * @param {string} gridId gridId\n     * @param {number} gridIndex gridIndex\n     * @param {Element} parent parent\n     * @param {string} themeColor themeColor\n     * @param {string} dashArray dashArray\n     * @param {number} removeIndex removeIndex\n     * @param {boolean} isRemoved isRemoved\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.renderGridLine = function (axis, index, gridDirection, gridModel, gridId, gridIndex, parent, themeColor, dashArray, removeIndex, isRemoved) {\n        if (dashArray === void 0) { dashArray = null; }\n        if (removeIndex === void 0) { removeIndex = null; }\n        if (isRemoved === void 0) { isRemoved = false; }\n        var chart = this.chart;\n        var direction;\n        var element;\n        if (gridModel.width > 0 && axis.visible && axis.internalVisibility && gridDirection) {\n            element = getElement(chart.element.id + gridId + index + '_' + (isRemoved ? removeIndex : gridIndex));\n            direction = element ? element.getAttribute('d') : null;\n            element = null;\n            this.htmlObject = chart.renderer.drawPath(new PathOption(chart.element.id + gridId + index + '_' + (isRemoved ? removeIndex : gridIndex), 'transparent', gridModel.width, gridModel.color || themeColor, null, dashArray, gridDirection));\n            appendChildElement(chart.enableCanvas, parent, this.htmlObject, chart.redraw, true, 'x', 'y', null, direction, true, null, null, chart.duration);\n            if (isRemoved) {\n                this.htmlObject.id = chart.element.id + gridId + index + '_' + gridIndex;\n            }\n        }\n    };\n    /**\n     * To Find the parent node of the axis\n     *\n     * @param {string} elementId elementId\n     * @param {Element} label label\n     * @param {number} index index\n     * @returns {Element} parent node of the axis\n     */\n    CartesianAxisLayoutPanel.prototype.findParentNode = function (elementId, label, index) {\n        if (document.getElementById(elementId + 'AxisGroup' + index + 'Inside').contains(document.getElementById(label.id))) {\n            return document.getElementById(elementId + 'AxisGroup' + index + 'Inside');\n        }\n        else {\n            return document.getElementById(elementId + 'AxisGroup' + index + 'Outside');\n        }\n    };\n    /**\n     * Create Zooming Labels Function Called here\n     *\n     * @param {Chart} chart chart\n     * @param {Element} labelElement labelElement\n     * @param {Axis} axis axis\n     * @param {number} index index\n     * @param {Rect} rect rect\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.createZoomingLabel = function (chart, labelElement, axis, index, rect) {\n        var parentNode = this.findParentNode(chart.element.id, labelElement, index);\n        labelElement.setAttribute('opacity', '0.3');\n        var zoomElement = chart.renderer.createGroup({\n            id: chart.element.id + 'AxisLabels_Zoom' + index\n        });\n        zoomElement = createZoomingLabels(chart, axis, zoomElement, index, axis.orientation === 'Vertical', rect);\n        parentNode.replaceChild(labelElement, document.getElementById(labelElement.id));\n        if (getElement(chart.element.id + 'AxisLabels_Zoom' + index)) {\n            parentNode.replaceChild(zoomElement, document.getElementById(zoomElement.id));\n        }\n        else {\n            parentNode.appendChild(zoomElement);\n        }\n    };\n    return CartesianAxisLayoutPanel;\n}());\nexport { CartesianAxisLayoutPanel };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}