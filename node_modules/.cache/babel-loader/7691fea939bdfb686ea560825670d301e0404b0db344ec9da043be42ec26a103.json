{"ast":null,"code":"import { ChartLocation, RectOption, isCollide, rotateTextSize } from '../../common/utils/helper';\nimport { markerAnimate, appendChildElement, getVisiblePoints } from '../../common/utils/helper';\nimport { getLabelText, convertHexToColor, calculateRect, textElement, colorNameToHex, animateTextElement } from '../../common/utils/helper';\nimport { measureText, TextOption, Rect } from '@syncfusion/ej2-svg-base';\nimport { textRender } from '../../common/model/constants';\nimport { createTemplate, getFontStyle, getElement, measureElementRect, templateAnimate, withIn, withInBounds } from '../../common/utils/helper';\nimport { createElement, getValue, extend } from '@syncfusion/ej2-base';\nimport { getPoint, isRotatedRectIntersect } from '../../common/utils/helper';\n/**\n * The `DataLabel` module is used to render data labels for data points.\n */\nvar DataLabel = /** @class */function () {\n  /**\n   * Constructor for the data label module.\n   *\n   * @private\n   */\n  function DataLabel(chart) {\n    this.errorHeight = 0;\n    /** @private */\n    this.dataLabelRectCollection = {};\n    this.chart = chart;\n  }\n  DataLabel.prototype.initPrivateVariables = function (series, marker) {\n    var transform = '';\n    var clipPath = '';\n    var render = series.chart.renderer;\n    var index = series.index === undefined ? series.category : series.index;\n    if (series.chart.chartAreaType === 'Cartesian') {\n      transform = 'translate(' + series.clipRect.x + ',' + series.clipRect.y + ')';\n      clipPath = 'url(#' + this.chart.element.id + '_ChartSeriesClipRect_' + index + ')';\n    }\n    if (marker.dataLabel.visible && !this.chart.enableCanvas) {\n      series.shapeElement = render.createGroup({\n        'id': this.chart.element.id + 'ShapeGroup' + index,\n        'transform': transform,\n        'clip-path': 'url(#' + this.chart.element.id + '_ChartSeriesClipRect_' + index + ')'\n      });\n      series.textElement = render.createGroup({\n        'id': this.chart.element.id + 'TextGroup' + index,\n        'transform': transform,\n        'clip-path': clipPath\n      });\n      series.textElement.setAttribute('aria-hidden', 'true');\n    }\n    this.markerHeight = series.type === 'Scatter' || marker.visible ? marker.height / 2 : 0;\n    this.commonId = this.chart.element.id + '_Series_' + index + '_Point_';\n    this.calculateErrorHeight(series, series.marker.dataLabel.position);\n    this.chartBackground = this.chart.chartArea.background === 'transparent' ? this.chart.background || this.chart.themeStyle.background : this.chart.chartArea.background;\n  };\n  DataLabel.prototype.calculateErrorHeight = function (series, position) {\n    if (!series.errorBar.visible) {\n      return null;\n    } else if (series.errorBar.visible && this.chart.chartAreaType !== 'PolarRadar') {\n      var direction = series.errorBar.direction;\n      var positiveHeight = this.chart.errorBarModule.positiveHeight;\n      var negativeHeight = this.chart.errorBarModule.negativeHeight;\n      if (this.isRectSeries(series)) {\n        if (position === 'Top' || position === 'Auto') {\n          if (direction === 'Both' || direction === 'Minus') {\n            this.errorHeight = negativeHeight;\n          } else {\n            this.errorHeight = 0;\n          }\n        }\n        if (position === 'Outer' || position === 'Auto') {\n          if (direction === 'Both' || direction === 'Plus') {\n            this.errorHeight = positiveHeight;\n          } else {\n            this.errorHeight = 0;\n          }\n        }\n      } else {\n        if (position === 'Top' || position === 'Outer' || position === 'Auto') {\n          if ((direction === 'Both' || direction === 'Plus') && !series.chart.isTransposed) {\n            this.errorHeight = positiveHeight;\n          } else {\n            this.errorHeight = 0;\n          }\n        }\n        if (position === 'Bottom' || position === 'Auto') {\n          if (direction === 'Both' || direction === 'Minus') {\n            this.errorHeight = negativeHeight;\n          } else {\n            this.errorHeight = 0;\n          }\n        }\n      }\n    } else {\n      this.errorHeight = 0;\n    }\n  };\n  DataLabel.prototype.isRectSeries = function (series) {\n    return series.isRectSeries || series.type === 'RangeArea' || series.type === 'SplineRangeArea' || series.type === 'RangeStepArea';\n  };\n  /**\n   * Render the data label for series.\n   *\n   * @param {Series} series - The series to render.\n   * @param {Chart} chart - The parent chart.\n   * @param {DataLabelSettingsModel} dataLabel - The settings for data labels.\n   * @returns {void}\n   * @private\n   */\n  DataLabel.prototype.render = function (series, chart, dataLabel) {\n    // initialize the private variable\n    this.initPrivateVariables(series, series.marker);\n    this.inverted = chart.requireInvertedAxis;\n    this.yAxisInversed = series.yAxis.isAxisInverse;\n    var templateId = chart.element.id + '_Series_' + (series.index === undefined ? series.category : series.index) + '_DataLabelCollections';\n    var element = createElement('div', {\n      id: templateId\n    });\n    var visiblePoints = getVisiblePoints(series);\n    // Data label point iteration started\n    if (series.visible) {\n      for (var i = 0; i < visiblePoints.length; i++) {\n        this.renderDataLabel(series, visiblePoints[i], element, dataLabel);\n      }\n    }\n    if (element.childElementCount) {\n      if (!chart.enableCanvas) {\n        appendChildElement(chart.enableCanvas, getElement(chart.element.id + '_Secondary_Element'), element, chart.redraw, false, 'x', 'y', null, '', false, false, null, chart.duration);\n      } else {\n        getElement(chart.element.id + '_Secondary_Element').appendChild(element);\n      }\n    }\n  };\n  DataLabel.prototype.renderDataLabel = function (series, point, element, dataLabel) {\n    if (!dataLabel.showZero && (point.y === 0 || point.y === 0 && series.emptyPointSettings.mode === 'Zero')) {\n      return null;\n    }\n    this.margin = dataLabel.margin;\n    var labelText = [];\n    var labelLength;\n    var xPos;\n    var yPos;\n    var xValue;\n    var yValue;\n    var degree;\n    var rectCenterX;\n    var rectCenterY;\n    var labelLocation = {\n      x: 0,\n      y: 0\n    };\n    var textSize;\n    var clip = series.clipRect;\n    var shapeRect;\n    var isDataLabelOverlap = false;\n    var dataLabelElement = [];\n    var startLocation;\n    dataLabel.angle = dataLabel.labelIntersectAction === 'Rotate90' ? 90 : dataLabel.angle;\n    dataLabel.enableRotation = dataLabel.labelIntersectAction === 'Rotate90' ? true : dataLabel.enableRotation;\n    var angle = degree = dataLabel.angle;\n    var border = {\n      width: dataLabel.border.width,\n      color: dataLabel.border.color\n    };\n    var argsFont = extend({}, getValue('properties', dataLabel.font), null, true);\n    if (point.symbolLocations.length && point.symbolLocations[0] || series.type === 'BoxAndWhisker' && point.regions.length) {\n      labelText = point.text !== null ? getLabelText(point, series, this.chart) : [];\n      labelLength = labelText.length;\n      for (var i = 0; i < labelLength; i++) {\n        var argsData = {\n          cancel: false,\n          name: textRender,\n          series: series,\n          point: point,\n          text: labelText[i],\n          border: border,\n          color: dataLabel.fill,\n          template: dataLabel.template,\n          font: argsFont,\n          location: labelLocation,\n          textSize: measureText(labelText[i], dataLabel.font, this.chart.themeStyle.datalabelFont)\n        };\n        this.chart.trigger(textRender, argsData);\n        if (!argsData.cancel) {\n          this.fontBackground = argsData.color;\n          this.isDataLabelShape(argsData);\n          this.markerHeight = series.type === 'Bubble' ? point.regions[0].height / 2 : this.markerHeight;\n          if (argsData.template !== null) {\n            this.createDataLabelTemplate(element, series, dataLabel, point, argsData, i, this.chart.redraw);\n          } else {\n            if (dataLabel.enableRotation) {\n              textSize = rotateTextSize(dataLabel.font, argsData.text, dataLabel.angle, this.chart, this.chart.themeStyle.datalabelFont);\n            } else {\n              textSize = measureText(argsData.text, dataLabel.font, this.chart.themeStyle.datalabelFont);\n            }\n            var rect = this.calculateTextPosition(point, series, textSize, dataLabel, i);\n            var actualRect = new Rect(rect.x + clip.x, rect.y + clip.y, rect.width, rect.height);\n            //let notOverlapping: boolean;\n            if (dataLabel.enableRotation) {\n              var rectCoordinates = this.getRectanglePoints(actualRect);\n              rectCenterX = rect.x + rect.width / 2;\n              rectCenterY = rect.y + rect.height / 2;\n              isDataLabelOverlap = dataLabel.labelIntersectAction === 'Rotate90' || angle === -90 ? false : this.isDataLabelOverlapWithChartBound(rectCoordinates, this.chart, {\n                x: 0,\n                y: 0,\n                width: 0,\n                height: 0\n              });\n              if (!isDataLabelOverlap) {\n                this.chart.rotatedDataLabelCollections.push(rectCoordinates);\n                var currentPointIndex = this.chart.rotatedDataLabelCollections.length - 1;\n                for (var index = currentPointIndex; index >= 0; index--) {\n                  if (this.chart.rotatedDataLabelCollections[currentPointIndex] && this.chart.rotatedDataLabelCollections[index - 1] && isRotatedRectIntersect(this.chart.rotatedDataLabelCollections[currentPointIndex], this.chart.rotatedDataLabelCollections[index - 1])) {\n                    isDataLabelOverlap = true;\n                    this.chart.rotatedDataLabelCollections[currentPointIndex] = null;\n                    break;\n                  }\n                }\n              }\n            } else {\n              isDataLabelOverlap = isCollide(rect, this.chart.dataLabelCollections, clip);\n            }\n            if (!isDataLabelOverlap || dataLabel.labelIntersectAction === 'None') {\n              var dataLabelShapeElement = getElement(this.commonId + point.index + '_TextShape_' + i);\n              if (dataLabelShapeElement) {\n                startLocation = {\n                  x: +dataLabelShapeElement.getAttribute('x'),\n                  y: +dataLabelShapeElement.getAttribute('y')\n                };\n              }\n              this.chart.dataLabelCollections.push(actualRect);\n              if (this.isShape) {\n                shapeRect = this.chart.renderer.drawRectangle(new RectOption(this.commonId + point.index + '_TextShape_' + i, argsData.color, argsData.border, dataLabel.opacity, rect, dataLabel.rx, dataLabel.ry, '', dataLabel.border.dashArray), new Int32Array([clip.x, clip.y]));\n                if (series.shapeElement) {\n                  appendChildElement(this.chart.enableCanvas, series.shapeElement, shapeRect, this.chart.redraw, true, 'x', 'y', startLocation);\n                }\n              }\n              // Checking the font color\n              var backgroundColor = this.fontBackground === 'transparent' ? this.chart.theme.indexOf('Dark') > -1 || this.chart.theme.indexOf('HighContrast') > -1 ? 'black' : 'white' : this.fontBackground;\n              var rgbValue = convertHexToColor(colorNameToHex(backgroundColor));\n              var contrast = Math.round((rgbValue.r * 299 + rgbValue.g * 587 + rgbValue.b * 114) / 1000);\n              xPos = rect.x + this.margin.left + textSize.width / 2 + labelLocation.x;\n              yPos = dataLabel.enableRotation && this.chart.chartAreaType !== 'PolarRadar' ? rect.y + this.margin.top + textSize.height / 2 + textSize.width / 4 + (dataLabel.position === 'Auto' ? point.regions[0].width / 10 : 0) + labelLocation.y : rect.y + this.margin.top + textSize.height * 3 / 4 + labelLocation.y;\n              labelLocation = {\n                x: 0,\n                y: 0\n              };\n              if (angle !== 0 && dataLabel.enableRotation) {\n                // xValue = xPos - (dataLabel.margin.left) / 2 + (dataLabel.margin.right / 2);\n                xValue = rectCenterX;\n                //yValue = yPos - (dataLabel.margin.top) / 2 - (textSize.height / dataLabel.margin.top) +\n                // (dataLabel.margin.bottom) / 2;\n                yValue = rectCenterY;\n                degree = angle > 360 ? angle - 360 : angle < -360 ? angle + 360 : angle;\n              } else {\n                degree = 0;\n                xValue = rect.x;\n                yValue = rect.y;\n                xPos -= this.chart.chartAreaType === 'Cartesian' && xPos + textSize.width / 2 > clip.width ? !this.chart.requireInvertedAxis && xPos > clip.width ? 0 : xPos + textSize.width / 2 - clip.width : 0;\n                yPos -= yPos + textSize.height > clip.y + clip.height && !(series.type.indexOf('Bar') > -1) ? yPos + textSize.height - (clip.y + clip.height) : 0;\n              }\n              var textAnchor = dataLabel.labelIntersectAction === 'Rotate90' ? dataLabel.position === 'Top' ? 'start' : dataLabel.position === 'Middle' ? 'middle' : 'end' : angle === -90 && dataLabel.enableRotation ? dataLabel.position === 'Top' ? 'end' : dataLabel.position === 'Middle' ? 'middle' : 'start' : 'middle';\n              var oldText = void 0;\n              if (this.chart.redraw && document.getElementById(this.commonId + point.index + '_Text_' + i)) {\n                oldText = document.getElementById(this.commonId + point.index + '_Text_' + i).textContent;\n              }\n              dataLabelElement.push(textElement(this.chart.renderer, new TextOption(this.commonId + (series.removedPointIndex !== null && series.removedPointIndex <= point.index ? point.index + 1 : point.index) + '_Text_' + i, xPos, yPos, textAnchor, argsData.text, 'rotate(' + degree + ',' + xValue + ',' + yValue + ')', 'auto', degree), argsData.font, argsData.font.color || (this.chart.theme === 'Bootstrap5' ? '#212529' : this.chart.theme === 'Bootstrap5Dark' ? '#DEE2E6' : contrast >= 128 || series.type === 'Hilo' || series.type === 'HiloOpenClose' ? this.chart.theme.indexOf('Tailwind3') > -1 ? '#111827' : 'black' : this.chart.theme.indexOf('Tailwind3') > -1 ? '#FFFFFF' : 'white'), series.textElement, false, this.chart.redraw, true, false, series.chart.duration, series.clipRect, null, null, this.chart.enableCanvas, null, this.chart.themeStyle.datalabelFont, new ChartLocation(xValue, yValue)));\n              if (this.isShape && dataLabel.enableRotation) {\n                shapeRect.setAttribute('transform', 'rotate(' + dataLabel.angle + ', ' + xValue + ', ' + yValue + ')');\n              }\n              if (this.chart.stackLabels.visible && series.type.indexOf('Stacking') > -1) {\n                this.dataLabelRectCollection = !this.dataLabelRectCollection ? {} : this.dataLabelRectCollection;\n                this.dataLabelRectCollection[this.commonId + (series.removedPointIndex !== null && series.removedPointIndex <= point.index ? point.index + 1 : point.index) + '_Text_' + i] = actualRect;\n                this.dataLabelRectCollection[this.commonId + point.index + '_TextShape_' + i] = actualRect;\n              }\n              if (series.removedPointIndex !== null && series.removedPointIndex <= point.index) {\n                series.textElement.lastChild.id = this.commonId + point.index + '_Text_' + i;\n              }\n              if (this.chart.redraw && oldText !== argsData.text) {\n                animateTextElement(series.textElement.querySelector('#' + this.commonId + point.index + '_Text_' + i), this.chart.duration, parseFloat(oldText), parseFloat(argsData.text), series.marker.dataLabel.format || series.yAxis.labelFormat);\n              }\n            } else if (getElement(this.commonId + point.index + '_Text_0') && series.chart.redraw && series.currentData) {\n              getElement(this.commonId + point.index + '_Text_0').remove();\n            }\n          }\n        }\n      }\n    }\n    return dataLabelElement;\n  };\n  /**\n   * Renders the stack labels for the chart.\n   *\n   * This method is responsible for displaying cumulative total values on stacked chart segments.\n   *\n   * @returns {void}\n   */\n  DataLabel.prototype.renderStackLabels = function () {\n    var stackLabelGroup = this.chart.renderer.createGroup({\n      id: this.chart.element.id + \"_StackLabelGroup\"\n    });\n    this.chart.seriesElements.appendChild(stackLabelGroup);\n    var positivePoints = {};\n    var negativePoints = {};\n    var groupingValues = [];\n    var keys = [];\n    var stackLabelIndex = 0;\n    if (this.chart.visibleSeries && this.chart.visibleSeries.length > 0) {\n      for (var i = 0; i < this.chart.visibleSeries.length; i++) {\n        keys = Object.keys(groupingValues);\n        var series = this.chart.visibleSeries[i];\n        if (!groupingValues[series.stackingGroup]) {\n          groupingValues[series.stackingGroup] = [];\n          groupingValues[series.stackingGroup].push(series);\n        } else if (groupingValues[series.stackingGroup] !== undefined) {\n          groupingValues[series.stackingGroup].push(series);\n        }\n      }\n      if (keys[0] !== '') {\n        for (var groupIndex = 0; groupIndex < keys.length; groupIndex++) {\n          positivePoints = {};\n          negativePoints = {};\n          var count = groupingValues[keys[groupIndex]][groupingValues[keys[groupIndex]].length - 1].index;\n          for (var seriesIndex = count; seriesIndex >= 0; seriesIndex--) {\n            var series = this.chart.visibleSeries[seriesIndex];\n            if (series.animation.enable && this.chart.animateSeries) {\n              stackLabelGroup.setAttribute('visibility', 'hidden');\n            }\n            if (series.visible && series.points && series.points.length > 0) {\n              for (var pointIndex = 0; pointIndex < series.points.length; pointIndex++) {\n                var point = series.points[pointIndex];\n                var pointXValueAsKey = String(point.x);\n                if (!positivePoints[pointXValueAsKey] && series.stackedValues.endValues[pointIndex] > 0 && point.visible) {\n                  positivePoints[pointXValueAsKey] = point;\n                }\n                if (!negativePoints[pointXValueAsKey] && series.stackedValues.endValues[pointIndex] < 0 && point.visible) {\n                  negativePoints[pointXValueAsKey] = point;\n                }\n              }\n            }\n          }\n          stackLabelIndex = this.calculateStackLabel(positivePoints, negativePoints, stackLabelGroup, stackLabelIndex);\n        }\n      } else {\n        for (var seriesIndex = this.chart.visibleSeries.length - 1; seriesIndex >= 0; seriesIndex--) {\n          var series = this.chart.visibleSeries[seriesIndex];\n          if (series.animation.enable && this.chart.animateSeries) {\n            stackLabelGroup.setAttribute('visibility', 'hidden');\n          }\n          if (series.visible && series.points && series.points.length > 0) {\n            for (var pointIndex = 0; pointIndex < series.points.length; pointIndex++) {\n              var point = series.points[pointIndex];\n              var pointXValueAsKey = String(point.x);\n              if (!positivePoints[pointXValueAsKey] && series.stackedValues.endValues[pointIndex] > 0 && point.visible) {\n                positivePoints[pointXValueAsKey] = point;\n              }\n              if (!negativePoints[pointXValueAsKey] && series.stackedValues.endValues[pointIndex] < 0 && point.visible) {\n                negativePoints[pointXValueAsKey] = point;\n              }\n            }\n          }\n        }\n        this.calculateStackLabel(positivePoints, negativePoints, stackLabelGroup, stackLabelIndex);\n      }\n    }\n  };\n  /**\n   * This method is responsible for positioning the cumulative sum of stacking column series.\n   *\n   * @param {Object} positivePoints - The positive points of the stacking series.\n   * @param {Object} negativePoints - The negative points of the stacking series.\n   * @param {Element} stackLabelGroup - The stack label group element.\n   * @param {number} stackLabelIndex - The index of the stack label.\n   * @returns {number} - The number of stack labels.\n   */\n  DataLabel.prototype.calculateStackLabel = function (positivePoints, negativePoints, stackLabelGroup, stackLabelIndex) {\n    var _this = this;\n    [positivePoints, negativePoints].forEach(function (points, index) {\n      if (points) {\n        var totalValue_1 = 0;\n        var currentPoint_1;\n        Object.keys(points).forEach(function (pointXValueAsKey) {\n          var positiveValue = points[pointXValueAsKey].series.stackedValues.endValues[points[pointXValueAsKey].index];\n          var negativeValue = negativePoints[pointXValueAsKey] ? negativePoints[pointXValueAsKey].series.stackedValues.endValues[negativePoints[pointXValueAsKey].index] : 0;\n          if (index === 0) {\n            // Handle positive points\n            totalValue_1 = positiveValue + negativeValue;\n            currentPoint_1 = points[pointXValueAsKey];\n          } else if (!positivePoints[pointXValueAsKey]) {\n            // Handle negative points only if no corresponding positive point\n            totalValue_1 = positiveValue;\n            currentPoint_1 = points[pointXValueAsKey];\n          }\n          if (currentPoint_1 && currentPoint_1.symbolLocations[0]) {\n            var series = currentPoint_1.series;\n            var symbolLocation = currentPoint_1.symbolLocations[0];\n            var labelFormat = _this.chart.stackLabels.format;\n            var stackLabeltext = totalValue_1 % 1 === 0 ? totalValue_1.toFixed(0) : totalValue_1.toFixed(2).slice(-1) === '0' ? totalValue_1.toFixed(1) : totalValue_1.toFixed(2);\n            if (labelFormat) {\n              var customLabelFormat = labelFormat.match('{value}') !== null;\n              stackLabeltext = customLabelFormat ? labelFormat.replace('{value}', stackLabeltext.toString()) : _this.chart.intl.getNumberFormat({\n                format: labelFormat,\n                useGrouping: _this.chart.useGroupingSeparator\n              })(totalValue_1);\n            }\n            var textSize = measureText(stackLabeltext, _this.chart.stackLabels.font, _this.chart.themeStyle.datalabelFont);\n            // Define padding to maintain a consistent gap from the symbol location values\n            var padding = 10;\n            if (_this.chartBackground === undefined) {\n              _this.chartBackground = _this.chart.chartArea.background === 'transparent' ? _this.chart.background || _this.chart.themeStyle.background : _this.chart.chartArea.background;\n            }\n            var backgroundColor = _this.chart.stackLabels.fill === 'transparent' && _this.chartBackground === 'transparent' ? _this.chart.theme.indexOf('Dark') > -1 || _this.chart.theme.indexOf('HighContrast') > -1 ? 'black' : 'white' : _this.chart.stackLabels.fill !== 'transparent' ? _this.chart.stackLabels.fill : _this.chartBackground;\n            var rgbValue = convertHexToColor(colorNameToHex(backgroundColor));\n            var contrast = Math.round((rgbValue.r * 299 + rgbValue.g * 587 + rgbValue.b * 114) / 1000);\n            var alignmentValue = textSize.width + _this.chart.stackLabels.border.width + _this.chart.stackLabels.margin.left + _this.chart.stackLabels.margin.right - padding / 2;\n            var yOffset = _this.chart.requireInvertedAxis ? padding / 2 : _this.chart.primaryYAxis.isInversed ? index === 0 ? textSize.height + padding / 2 : -padding : index === 0 ? -padding : textSize.height + padding / 2;\n            var xOffset = _this.chart.requireInvertedAxis ? _this.chart.primaryYAxis.isInversed ? index === 0 ? -(padding + textSize.width / 2) : padding + textSize.width / 2 : index === 0 ? padding + textSize.width / 2 : -(padding + textSize.width / 2) : 0;\n            xOffset += _this.chart.stackLabels.font.textAlignment === 'Far' ? alignmentValue : _this.chart.stackLabels.font.textAlignment === 'Near' ? -alignmentValue : 0;\n            var xPosition = Math.max(series.clipRect.x + textSize.width, Math.min(xOffset + series.clipRect.x + symbolLocation.x, series.clipRect.x + series.clipRect.width - textSize.width));\n            var yPosition = Math.max(series.clipRect.y + textSize.height, Math.min(yOffset + series.clipRect.y + symbolLocation.y - (_this.chart.stackLabels.angle > 0 && !_this.chart.requireInvertedAxis ? textSize.width / 2 : 0), series.clipRect.y + series.clipRect.height - textSize.height));\n            var rect = new Rect(xPosition - textSize.width / 2 - _this.chart.stackLabels.margin.left, yPosition - textSize.height - _this.chart.stackLabels.margin.top, textSize.width + (_this.chart.stackLabels.margin.left + _this.chart.stackLabels.margin.right), textSize.height + padding / 2 + (_this.chart.stackLabels.margin.top + _this.chart.stackLabels.margin.bottom));\n            var shapeRect = _this.chart.renderer.drawRectangle(new RectOption(_this.chart.element.id + \"StackLabel_TextShape_\" + stackLabelIndex, _this.chart.stackLabels.fill, _this.chart.stackLabels.border, null, rect, _this.chart.stackLabels.rx, _this.chart.stackLabels.ry, '', null), new Int32Array([symbolLocation.x, symbolLocation.y]));\n            shapeRect.setAttribute('transform', \"rotate(\" + _this.chart.stackLabels.angle + \", \" + xPosition + \", \" + yPosition + \")\");\n            stackLabelGroup.appendChild(shapeRect);\n            textElement(_this.chart.renderer, new TextOption(_this.chart.element.id + \"_StackLabel_\" + stackLabelIndex, xPosition, yPosition, 'middle', stackLabeltext, \"rotate(\" + _this.chart.stackLabels.angle + \", \" + xPosition + \", \" + yPosition + \")\", 'auto', _this.chart.stackLabels.angle), _this.chart.stackLabels.font, _this.chart.stackLabels.font.color || (_this.chart.theme === 'Bootstrap5' ? '#212529' : _this.chart.theme === 'Bootstrap5Dark' ? '#DEE2E6' : contrast >= 128 ? _this.chart.theme.indexOf('Tailwind3') > -1 ? '#111827' : 'black' : _this.chart.theme.indexOf('Tailwind3') > -1 ? '#FFFFFF' : 'white'), stackLabelGroup, null, _this.chart.redraw, true, null, _this.chart.duration, series.clipRect, null, null, _this.chart.enableCanvas, null, _this.chart.themeStyle.datalabelFont, null);\n            if (series.type === 'StackingLine' || series.type === 'StackingArea') {\n              document.querySelectorAll(\"[id^=\\\"\" + _this.chart.element.id + \"_Series_\" + series.index + \"_Point_\" + currentPoint_1.index + \"_Text_\\\"], \\n                                [id^=\\\"\" + _this.chart.element.id + \"_Series_\" + series.index + \"_Point_\" + currentPoint_1.index + \"_TextShape_\\\"]\").forEach(function (element) {\n                if (element.id) {\n                  element.style.visibility = 'hidden';\n                  element.setAttribute('data-collide', 'true');\n                }\n              });\n            }\n            for (var dataLabelID in _this.dataLabelRectCollection) {\n              if (Object.prototype.hasOwnProperty.call(_this.dataLabelRectCollection, dataLabelID)) {\n                var dataLabelRect = _this.dataLabelRectCollection[dataLabelID];\n                if (dataLabelRect) {\n                  var isCollided = isCollide(rect, [dataLabelRect], {\n                    x: 0,\n                    y: 0,\n                    height: 0,\n                    width: 0\n                  });\n                  if (isCollided) {\n                    var dataLabelElement = document.getElementById(dataLabelID);\n                    if (dataLabelElement) {\n                      dataLabelElement.style.visibility = 'hidden';\n                      dataLabelElement.setAttribute('data-collide', 'true');\n                    }\n                  }\n                }\n              }\n            }\n          }\n          stackLabelIndex++;\n        });\n      }\n    });\n    return stackLabelIndex;\n  };\n  /**\n   * Retrieves the points of a rectangle.\n   *\n   * @param {Rect} rect - The rectangle whose points are to be retrieved.\n   * @returns {ChartLocation[]} - The points of the rectangle.\n   */\n  DataLabel.prototype.getRectanglePoints = function (rect) {\n    var loc1 = new ChartLocation(rect.x, rect.y);\n    var loc2 = new ChartLocation(rect.x + rect.width, rect.y);\n    var loc3 = new ChartLocation(rect.x + rect.width, rect.y + rect.height);\n    var loc4 = new ChartLocation(rect.x, rect.y + rect.height);\n    return [loc1, loc2, loc3, loc4];\n  };\n  DataLabel.prototype.isDataLabelOverlapWithChartBound = function (rectCoordinates, chart, clip) {\n    for (var index = 0; index < rectCoordinates.length; index++) {\n      if (!withInBounds(rectCoordinates[index].x + clip.x, rectCoordinates[index].y + clip.y, chart.initialClipRect)) {\n        return true;\n      }\n    }\n    return false;\n  };\n  /**\n   * Creates a template for data labels.\n   *\n   * @param {HTMLElement} parentElement - The parent element to which the template will be appended.\n   * @param {Series} series - The series associated with the data label.\n   * @param {DataLabelSettingsModel} dataLabel - The settings for the data label.\n   * @param {Points} point - The data point to which the data label is associated.\n   * @param {ITextRenderEventArgs} data - The event data associated with rendering the data label.\n   * @param {number} labelIndex - The index of the data label.\n   * @param {boolean} redraw - Specifies whether to redraw the template.\n   * @returns {void}\n   */\n  DataLabel.prototype.createDataLabelTemplate = function (parentElement, series, dataLabel, point, data, labelIndex, redraw) {\n    this.margin = {\n      left: 0,\n      right: 0,\n      bottom: 0,\n      top: 0\n    };\n    var clip = series.clipRect;\n    var childElement = createTemplate(createElement('div', {\n      id: this.chart.element.id + '_Series_' + (series.index === undefined ? series.category : series.index) + '_DataLabel_' + point.index + (labelIndex ? '_' + labelIndex : ''),\n      styles: 'position: absolute;background-color:' + data.color + ';' + getFontStyle(dataLabel.font, this.chart.themeStyle.datalabelFont) + ';border:' + data.border.width + 'px solid ' + data.border.color + ';'\n    }), point.index, this.chart.enableHtmlSanitizer ? this.chart.sanitize(data.template) : data.template, this.chart, point, series, this.chart.element.id + '_DataLabel', labelIndex);\n    this.calculateTemplateLabelSize(parentElement, childElement, point, series, dataLabel, labelIndex, clip, redraw);\n  };\n  DataLabel.prototype.calculateTemplateLabelSize = function (parentElement, childElement, point, series, dataLabel, labelIndex, clip, redraw, isReactCallback) {\n    var elementRect = measureElementRect(childElement, redraw, isReactCallback);\n    var rect = this.calculateTextPosition(point, series, {\n      width: elementRect.width,\n      height: elementRect.height\n    }, dataLabel, labelIndex);\n    var clipWidth = 0;\n    var clipHeight = 0;\n    var isOverlap = false;\n    if (isReactCallback) {\n      isOverlap = elementRect.width === 0 || elementRect.height === 0; // To check the data label already overlap before react callback call\n      // clipWidth = ((series.clipRect.x + rect.x) + elementRect.width) > parentElement.clientWidth ?\n      //     (parentElement.clientWidth - (series.clipRect.x + rect.x)) : 0;\n      // clipHeight = (series.points.length - 1 === point.index) ? elementRect.height / 2 : 0;\n    }\n    childElement.style.left = (this.chart.chartAreaType === 'PolarRadar' ? 0 : series.clipRect.x) + rect.x - clipWidth + 'px';\n    childElement.style.top = (this.chart.chartAreaType === 'PolarRadar' ? 0 : series.clipRect.y) + rect.y + clipHeight + 'px';\n    var vAxis = series.chart.requireInvertedAxis ? series.xAxis : series.yAxis;\n    var hAxis = series.chart.requireInvertedAxis ? series.yAxis : series.xAxis;\n    if (childElement.childElementCount && !isOverlap && (!isCollide(rect, this.chart.dataLabelCollections, clip) || dataLabel.labelIntersectAction === 'None') && (series.seriesType !== 'XY' || point.yValue === undefined || withIn(point.yValue, series.yAxis.visibleRange) || series.type.indexOf('Stacking') > -1 || series.type.indexOf('100') > -1 && withIn(series.stackedValues.endValues[point.index], series.yAxis.visibleRange)) && withIn(point.xValue, series.xAxis.visibleRange) && parseFloat(childElement.style.top) >= vAxis.rect.y && parseFloat(childElement.style.left) >= hAxis.rect.x && parseFloat(childElement.style.top) <= vAxis.rect.y + vAxis.rect.height && parseFloat(childElement.style.left) <= hAxis.rect.x + hAxis.rect.width) {\n      this.chart.dataLabelCollections.push(new Rect(rect.x + clip.x, rect.y + clip.y, rect.width, rect.height));\n      appendChildElement(this.chart.enableCanvas, parentElement, childElement, redraw, true, 'left', 'top');\n      if (series.animation.enable && this.chart.animateSeries && !this.chart.enableCanvas) {\n        this.doDataLabelAnimation(series, childElement);\n      } else if (this.chart.enableCanvas) {\n        parentElement.appendChild(childElement);\n      }\n    }\n  };\n  DataLabel.prototype.calculateTextPosition = function (point, series, textSize, dataLabel, labelIndex) {\n    var labelRegion = labelIndex > 1 ? series.type === 'Candle' ? point.regions[1] : point.regions[0] : point.regions[0];\n    if (labelIndex > 1 && series.type === 'HiloOpenClose') {\n      labelRegion = labelIndex === 2 ? point.regions[1] : point.regions[2];\n    }\n    var location;\n    location = this.getLabelLocation(point, series, textSize, labelIndex);\n    var padding = 5;\n    var clipRect = series.clipRect;\n    // calculating alignment\n    if (!this.chart.requireInvertedAxis || !this.isRectSeries(series) || series.type === 'BoxAndWhisker') {\n      this.locationX = location.x;\n      var alignmentValue = textSize.height + this.borderWidth * 2 + this.markerHeight + this.margin.bottom + this.margin.top + padding;\n      location.x = dataLabel.position === 'Auto' ? location.x : this.calculateAlignment(alignmentValue, location.x, dataLabel.alignment, this.isRectSeries(series) ? point.yValue < 0 : false);\n      // calculating position\n      location.y = !this.isRectSeries(series) || series.type === 'BoxAndWhisker' ? this.calculatePathPosition(location.y, dataLabel.position, series, point, textSize, labelIndex) : this.calculateRectPosition(location.y, labelRegion, point.yValue < 0 !== this.yAxisInversed, dataLabel.position, series, textSize, labelIndex, point);\n      if (this.isRectSeries(series) && this.chart.chartAreaType === 'PolarRadar') {\n        location = this.calculatePolarRectPosition(location, dataLabel.position, series, point, textSize, labelIndex, dataLabel.alignment, alignmentValue);\n      }\n    } else {\n      this.locationY = location.y;\n      var alignmentValue = textSize.width + this.borderWidth + this.margin.left + this.margin.right - padding;\n      location.x = dataLabel.position === 'Auto' ? location.x : this.calculateAlignment(alignmentValue, location.x, dataLabel.alignment, point.yValue < 0);\n      location.x = this.calculateRectPosition(location.x, labelRegion, point.yValue < 0 !== this.yAxisInversed, dataLabel.position, series, textSize, labelIndex, point);\n    }\n    var rect = calculateRect(location, textSize, this.margin);\n    // Checking the condition whether data Label has been exist the clip rect\n    if (!(dataLabel.enableRotation === true && dataLabel.angle !== 0) && !(rect.y > clipRect.y + clipRect.height || rect.x > clipRect.x + clipRect.width || rect.x + rect.width < 0 || rect.y + rect.height < 0)) {\n      rect.x = rect.x < 0 ? series.type === 'StackingColumn' && !this.inverted ? 0 : padding : rect.x;\n      rect.y = rect.y < 0 && !this.chart.requireInvertedAxis && !(dataLabel.labelIntersectAction === 'None') ? padding : rect.y;\n      rect.x -= rect.x + rect.width > clipRect.x + clipRect.width ? rect.x + rect.width - (clipRect.x + clipRect.width) + padding : 0;\n      rect.y -= rect.y + rect.height > clipRect.y + clipRect.height ? rect.y + rect.height - (clipRect.y + clipRect.height) + padding : 0;\n      this.fontBackground = this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground;\n    }\n    var dataLabelOutRegion;\n    if (this.inverted && series.isRectSeries && rect.x + rect.width > labelRegion.x + labelRegion.width) {\n      dataLabelOutRegion = true;\n    }\n    this.fontBackground = dataLabelOutRegion ? this.chartBackground : this.fontBackground;\n    return rect;\n  };\n  // Calculation label location for polar column draw types\n  DataLabel.prototype.calculatePolarRectPosition = function (location, position, series, point, size, labelIndex, alignment, alignmentValue) {\n    var padding = 5;\n    var columnRadius;\n    var chartWidth = this.chart.availableSize.width;\n    var alignmentSign = alignment === 'Center' ? 0 : alignment === 'Far' ? 1 : -1;\n    var angle = point.regionData.startAngle - 0.5 * Math.PI + (point.regionData.endAngle - point.regionData.startAngle) / 2;\n    if (labelIndex === 0) {\n      columnRadius = point.regionData.radius < point.regionData.innerRadius ? point.regionData.innerRadius : point.regionData.radius;\n    } else {\n      columnRadius = point.regionData.radius > point.regionData.innerRadius ? point.regionData.innerRadius : point.regionData.radius;\n    }\n    this.fontBackground = this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground;\n    if (series.drawType.indexOf('Stacking') > -1) {\n      position = position === 'Outer' ? 'Top' : position;\n    } else if (series.drawType.indexOf('Range') > -1) {\n      position = position === 'Outer' || position === 'Top' ? position : 'Auto';\n    }\n    if (position === 'Outer') {\n      columnRadius = labelIndex === 0 ? columnRadius + 2 * padding + this.markerHeight : columnRadius - 2 * padding - this.markerHeight;\n    } else if (position === 'Middle') {\n      columnRadius = columnRadius / 2 + padding;\n      if (series.drawType === 'StackingColumn') {\n        columnRadius = point.regionData.innerRadius + (point.regionData.radius - point.regionData.innerRadius) / 2 + padding - size.height / 2;\n      }\n    } else if (position === 'Top') {\n      columnRadius = labelIndex === 0 ? columnRadius - 2 * padding - this.markerHeight : columnRadius + 2 * padding + this.markerHeight;\n    } else if (position === 'Bottom') {\n      columnRadius = 2 * padding;\n      columnRadius += series.drawType === 'StackingColumn' ? point.regionData.innerRadius + this.markerHeight : 0;\n    } else {\n      if (labelIndex === 0) {\n        columnRadius = columnRadius >= series.chart.radius ? columnRadius - padding : series.drawType === 'StackingColumn' ? columnRadius - 2 * padding : columnRadius + 2 * padding;\n      } else {\n        columnRadius = columnRadius >= series.chart.radius ? columnRadius + padding : columnRadius - 2 * padding;\n      }\n    }\n    columnRadius += alignmentValue * alignmentSign;\n    location.x = series.clipRect.width / 2 + series.clipRect.x + columnRadius * Math.cos(angle);\n    // To change x location based on text anchor for column and stackingcolumn chart\n    if (series.drawType === 'StackingColumn') {\n      location.x = location.x < chartWidth / 2 ? location.x + size.width / 2 : location.x > chartWidth / 2 ? location.x - size.width / 2 : location.x;\n    } else if (series.drawType === 'Column') {\n      location.x = location.x < chartWidth / 2 ? location.x - size.width / 2 : location.x > chartWidth / 2 ? location.x + size.width / 2 : location.x;\n    }\n    location.y = series.clipRect.height / 2 + series.clipRect.y + columnRadius * Math.sin(angle);\n    return location;\n  };\n  /**\n   * Gets the location for the data label.\n   *\n   * @param {Points} point - The data point associated with the label.\n   * @param {Series} series - The series associated with the data label.\n   * @param {Size} textSize - The size of the text to be displayed in the data label.\n   * @param {number} labelIndex - The index of the data label.\n   * @returns {ChartLocation} - The location for the data label.\n   */\n  DataLabel.prototype.getLabelLocation = function (point, series, textSize, labelIndex) {\n    var location = new ChartLocation(0, 0);\n    var labelRegion = series.type === 'Candle' && labelIndex > 1 ? point.regions[1] : point.regions[0];\n    if (series.type === 'HiloOpenClose') {\n      labelRegion = labelIndex === 2 ? point.regions[1] : point.regions[2];\n    }\n    var xAxis = series.xAxis;\n    var yAxis = series.yAxis;\n    var isInverted = series.chart.requireInvertedAxis;\n    if (series.type === 'BoxAndWhisker') {\n      this.markerHeight = 0;\n      switch (labelIndex) {\n        case 0:\n          location = getPoint(point.xValue, point.median, xAxis, yAxis, isInverted);\n          break;\n        case 1:\n          location = getPoint(point.xValue, point.maximum, xAxis, yAxis, isInverted);\n          break;\n        case 2:\n          location = getPoint(point.xValue, point.minimum, xAxis, yAxis, isInverted);\n          break;\n        case 3:\n          location = getPoint(point.xValue, point.upperQuartile, xAxis, yAxis, isInverted);\n          break;\n        case 4:\n          location = getPoint(point.xValue, point.lowerQuartile, xAxis, yAxis, isInverted);\n          break;\n        default:\n          {\n            location = getPoint(point.xValue, point.outliers[labelIndex - 5], xAxis, yAxis, isInverted);\n            this.markerHeight = series.marker.height / 2;\n            break;\n          }\n      }\n      if (isInverted) {\n        location.y = point.regions[0].y + point.regions[0].height / 2;\n      } else {\n        location.x = point.regions[0].x + point.regions[0].width / 2;\n      }\n    } else if (isInverted && series.type.indexOf('Stacking') > -1 && point.yValue === 0) {\n      location = {\n        x: labelRegion.x + labelRegion.width,\n        y: labelRegion.y + labelRegion.height / 2\n      };\n    } else if (labelIndex === 0 || labelIndex === 1) {\n      location = new ChartLocation(point.symbolLocations[0].x, point.symbolLocations[0].y);\n    } else if ((labelIndex === 2 || labelIndex === 3) && series.type === 'Candle') {\n      location = new ChartLocation(point.symbolLocations[1].x, point.symbolLocations[1].y);\n    } else if (isInverted) {\n      location = {\n        x: labelRegion.x + labelRegion.width / 2,\n        y: labelRegion.y\n      };\n    } else {\n      location = {\n        x: labelRegion.x + labelRegion.width,\n        y: labelRegion.y + labelRegion.height / 2\n      };\n    }\n    //Aligning the label at the beginning of the tick, when tick size is less than text size\n    if (labelIndex > 1 && series.type === 'HiloOpenClose') {\n      if (series.chart.requireInvertedAxis) {\n        var height = labelRegion.height;\n        location.y = labelRegion.y + height / 2 + 2 * (labelIndex === 2 ? 1 : -1);\n      } else {\n        var width = labelRegion.width;\n        location.x = labelRegion.x + width / 2 + 2 * (labelIndex === 2 ? 1 : -1);\n      }\n    }\n    return location;\n  };\n  DataLabel.prototype.calculateRectPosition = function (labelLocation, rect, isMinus, position, series, textSize, labelIndex, point) {\n    if (series.chart.chartAreaType === 'PolarRadar') {\n      return null;\n    }\n    var padding = 5;\n    var margin = this.margin;\n    var textLength = series.marker.dataLabel.enableRotation ? textSize.width : !this.inverted ? textSize.height : textSize.width;\n    if (position === 'Bottom' && series.type === 'StackingColumn' && !this.inverted && rect.height < textSize.height) {\n      this.extraSpace = this.borderWidth + (Math.abs(rect.height - textSize.height / 2) < padding ? 0 : padding);\n    } else {\n      this.extraSpace = this.borderWidth + textLength / 2 + (position !== 'Outer' && series.type.indexOf('Column') > -1 && Math.abs(rect.height - textSize.height) < padding ? 0 : padding);\n    }\n    if (series.type === 'StackingColumn100' || series.type === 'StackingBar100') {\n      position = position === 'Outer' ? 'Top' : position;\n    } else if (series.type.indexOf('Range') > -1) {\n      position = position === 'Outer' || position === 'Top' ? position : 'Auto';\n    } else if (series.type === 'Waterfall') {\n      position = position === 'Auto' ? 'Middle' : position;\n    }\n    switch (position) {\n      case 'Bottom':\n        labelLocation = !this.inverted ? isMinus ? labelLocation + (series.type === 'Waterfall' ? -this.extraSpace - margin.top - this.markerHeight : -rect.height + this.extraSpace + margin.top) : labelLocation + rect.height - this.extraSpace - margin.bottom : isMinus ? labelLocation + (series.type === 'Waterfall' ? +this.extraSpace + margin.left + this.markerHeight : +rect.width - this.extraSpace - margin.left) : labelLocation - rect.width + this.extraSpace + margin.right;\n        break;\n      case 'Middle':\n        labelLocation = labelLocation = !this.inverted ? isMinus ? labelLocation - rect.height / 2 : labelLocation + rect.height / 2 : isMinus ? labelLocation + rect.width / 2 : labelLocation - rect.width / 2;\n        break;\n      case 'Auto':\n        labelLocation = this.calculateRectActualPosition(labelLocation, rect, isMinus, series, textSize, labelIndex, point);\n        break;\n      default:\n        this.extraSpace += this.errorHeight;\n        labelLocation = this.calculateTopAndOuterPosition(labelLocation, rect, position, series, labelIndex, this.extraSpace, isMinus, point);\n        break;\n    }\n    var check = !this.inverted ? labelLocation < rect.y || labelLocation > rect.y + rect.height : labelLocation < rect.x || labelLocation > rect.x + rect.width;\n    this.fontBackground = check ? this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground : this.fontBackground === 'transparent' ? point.color || series.interior : this.fontBackground;\n    var seriesLength = series.chart.series.length;\n    if (position === 'Outer' && series.type.indexOf('Stacking') > -1 && seriesLength - 1 > series.index) {\n      var nextSeries = void 0;\n      var nextSeriesPoint = void 0;\n      for (var i = series.index + 1; i < seriesLength; i++) {\n        nextSeries = series.chart.series[i];\n        nextSeriesPoint = nextSeries.points[point.index];\n        if (nextSeries.type.indexOf('Stacking') > -1 && nextSeries.type.indexOf('100') === -1) {\n          this.fontBackground = nextSeriesPoint && (nextSeriesPoint.yValue < 0 && point.yValue < 0 || nextSeriesPoint.yValue > 0 && point.yValue > 0) ? nextSeriesPoint ? nextSeriesPoint.color : nextSeries.interior : this.fontBackground;\n          break;\n        }\n      }\n    }\n    return labelLocation;\n  };\n  DataLabel.prototype.calculatePathPosition = function (labelLocation, position, series, point, size, labelIndex) {\n    var padding = 5;\n    if (series.type.indexOf('Area') > -1 && series.type !== 'RangeArea' && series.type !== 'SplineRangeArea' && series.type !== 'RangeStepArea' && this.yAxisInversed && series.marker.dataLabel.position !== 'Auto') {\n      position = position === 'Top' ? 'Bottom' : position === 'Bottom' ? 'Top' : position;\n    }\n    this.fontBackground = this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground;\n    switch (position) {\n      case 'Top':\n      case 'Outer':\n        labelLocation = labelLocation - this.markerHeight - this.borderWidth - size.height / 2 - this.margin.bottom - padding - this.errorHeight;\n        break;\n      case 'Bottom':\n        labelLocation = labelLocation + this.markerHeight + this.borderWidth + size.height / 2 + this.margin.top + padding + this.errorHeight;\n        break;\n      case 'Auto':\n        labelLocation = this.calculatePathActualPosition(labelLocation, this.markerHeight, series, point, size, labelIndex);\n        break;\n    }\n    return labelLocation;\n  };\n  DataLabel.prototype.isDataLabelShape = function (style) {\n    this.isShape = style.color !== 'transparent' || style.border.width > 0;\n    this.borderWidth = style.border.width;\n    if (!this.isShape) {\n      this.margin = {\n        left: 0,\n        right: 0,\n        bottom: 0,\n        top: 0\n      };\n    }\n  };\n  DataLabel.prototype.calculateRectActualPosition = function (labelLocation, rect, isMinus, series, size, labelIndex, point) {\n    var location;\n    var labelRect;\n    var isOverLap = true;\n    var position = 0;\n    var collection = this.chart.dataLabelCollections;\n    var finalPosition = series.type.indexOf('Range') !== -1 || series.type === 'Hilo' ? 2 : 4;\n    while (isOverLap && position < finalPosition) {\n      var actualPosition = this.getPosition(position);\n      this.fontBackground = series.marker.dataLabel.fill;\n      if (series.type.indexOf('Stacking') > -1 && actualPosition === 'Outer') {\n        actualPosition = 'Top';\n        position++;\n      }\n      location = this.calculateRectPosition(labelLocation, rect, isMinus, actualPosition, series, size, labelIndex, point);\n      if (!this.inverted) {\n        if (series.marker.dataLabel.enableRotation) {\n          size.width = size.width - point.regions[0].width / 10;\n        }\n        labelRect = calculateRect(new ChartLocation(this.locationX, location), size, this.margin);\n        isOverLap = labelRect.y < 0 || isCollide(labelRect, collection, series.clipRect) || labelRect.y > series.clipRect.height;\n        if (series.marker.dataLabel.template === null && isOverLap !== true) {\n          isOverLap = labelRect.y / 2 + size.height + (actualPosition === 'Outer' ? point.regions[0].height + this.extraSpace : point.regions[0].height - 2 * this.extraSpace) > series.clipRect.height;\n        }\n      } else {\n        labelRect = calculateRect(new ChartLocation(location, this.locationY), size, this.margin);\n        isOverLap = labelRect.x < 0 || isCollide(labelRect, collection, series.clipRect) || labelRect.x + labelRect.width > series.clipRect.width;\n      }\n      position++;\n    }\n    return location;\n  };\n  // alignment calculation assigned here\n  DataLabel.prototype.calculateAlignment = function (value, labelLocation, alignment, isMinus) {\n    switch (alignment) {\n      case 'Far':\n        labelLocation = !this.inverted ? isMinus ? labelLocation + value : labelLocation - value : isMinus ? labelLocation - value : labelLocation + value;\n        break;\n      case 'Near':\n        labelLocation = !this.inverted ? isMinus ? labelLocation - value : labelLocation + value : isMinus ? labelLocation + value : labelLocation - value;\n        break;\n    }\n    return labelLocation;\n  };\n  //calculation for top and outer position of datalabel for rect series\n  DataLabel.prototype.calculateTopAndOuterPosition = function (location, rect, position, series, index, extraSpace, isMinus, point) {\n    var margin = this.margin;\n    var top;\n    switch (series.type) {\n      case 'RangeColumn':\n      case 'RangeArea':\n      case 'RangeStepArea':\n      case 'SplineRangeArea':\n      case 'Hilo':\n        top = index === 0 && !this.yAxisInversed || index === 1 && this.yAxisInversed;\n        location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top);\n        break;\n      case 'Candle':\n        top = (index === 0 || index === 2) && !this.yAxisInversed || (index === 1 || index === 3) && this.yAxisInversed;\n        location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top, index > 1);\n        break;\n      case 'HiloOpenClose':\n        if (index <= 1) {\n          top = index === 0 && !this.yAxisInversed || index === 1 && this.yAxisInversed;\n          location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top);\n        } else {\n          if (this.yAxisInversed) {\n            location = !this.inverted ? location + extraSpace + margin.top : location - extraSpace - margin.right;\n          } else {\n            location = !this.inverted ? location - extraSpace - margin.bottom : location + extraSpace + margin.left;\n          }\n        }\n        break;\n      default:\n        if (isMinus && position === 'Top' || !isMinus && position === 'Outer' || position === 'Top' && series.visiblePoints[point.index].yValue === 0) {\n          location = !this.inverted ? location + (isMinus && series.type === 'Waterfall' ? -rect.height + extraSpace + margin.bottom : -extraSpace - margin.bottom - this.markerHeight) : location + (isMinus && series.type === 'Waterfall' ? +rect.width - extraSpace - margin.left : +extraSpace + margin.left + this.markerHeight);\n        } else {\n          location = !this.inverted ? location + (isMinus && series.type === 'Waterfall' ? -rect.height - extraSpace - margin.top : +extraSpace + margin.top + this.markerHeight) : location + (isMinus && series.type === 'Waterfall' ? +rect.width + extraSpace + margin.top : -extraSpace - margin.right - this.markerHeight);\n        }\n        break;\n    }\n    return location;\n  };\n  /**\n   * Updates the location of the data label.\n   *\n   * @param {LabelPosition} position - The position of the data label.\n   * @param {number} location - The initial location of the data label.\n   * @param {number} extraSpace - Extra space to adjust the label position.\n   * @param {MarginModel} margin - The margin for the chart.\n   * @param {Rect} rect - The rectangle associated with the data label.\n   * @param {boolean} top - Indicates whether the label is positioned at the top.\n   * @param {boolean} inside - Indicates whether the label is inside the chart area.\n   * @returns {number} The updated location of the data label.\n   */\n  DataLabel.prototype.updateLabelLocation = function (position, location, extraSpace, margin, rect, top, inside) {\n    if (inside === void 0) {\n      inside = false;\n    }\n    if (!this.inverted) {\n      if (top) {\n        location = position === 'Outer' && !inside ? location - extraSpace - margin.bottom - this.markerHeight : location + extraSpace + margin.top + this.markerHeight;\n      } else {\n        location = position === 'Outer' && !inside ? location + rect.height + extraSpace + margin.top + this.markerHeight : location + rect.height - extraSpace - margin.bottom - this.markerHeight;\n      }\n    } else {\n      if (top) {\n        location = position === 'Outer' && !inside ? location + extraSpace + margin.left + this.markerHeight : location - extraSpace - margin.right - this.markerHeight;\n      } else {\n        location = position === 'Outer' && !inside ? location - rect.width - extraSpace - margin.right - this.markerHeight : location - rect.width + extraSpace + margin.left + this.markerHeight;\n      }\n    }\n    return location;\n  };\n  DataLabel.prototype.calculatePathActualPosition = function (y, markerSize, series, point, size, labelIndex) {\n    var points = series.points;\n    var index = point.index;\n    var yValue = points[index].yValue;\n    var position;\n    var nextPoint = points.length - 1 > index ? points[index + 1] : null;\n    var previousPoint = index > 0 ? points[index - 1] : null;\n    var yLocation;\n    var isOverLap = true;\n    var labelRect;\n    var isBottom;\n    var positionIndex;\n    var collection = this.chart.dataLabelCollections;\n    if (series.type === 'Bubble') {\n      position = 'Top';\n    } else if (series.type.indexOf('Step') > -1) {\n      position = 'Top';\n      if (index) {\n        position = !previousPoint || !previousPoint.visible || yValue > previousPoint.yValue !== this.yAxisInversed || yValue === previousPoint.yValue ? 'Top' : 'Bottom';\n      }\n    } else if (series.type === 'BoxAndWhisker') {\n      if (labelIndex === 1 || labelIndex === 3 || labelIndex > 4) {\n        position = series.yAxis.isAxisInverse ? 'Bottom' : 'Top';\n      } else if (labelIndex === 2 || labelIndex === 4) {\n        position = series.yAxis.isAxisInverse ? 'Top' : 'Bottom';\n      } else {\n        isOverLap = false;\n        position = 'Middle';\n        yLocation = this.calculatePathPosition(y, position, series, point, size, labelIndex);\n      }\n    } else {\n      if (index === 0) {\n        position = !nextPoint || !nextPoint.visible || yValue > nextPoint.yValue || yValue < nextPoint.yValue && this.yAxisInversed ? 'Top' : 'Bottom';\n      } else if (index === points.length - 1) {\n        position = !previousPoint || !previousPoint.visible || yValue > previousPoint.yValue || yValue < previousPoint.yValue && this.yAxisInversed ? 'Top' : 'Bottom';\n      } else {\n        if (!nextPoint.visible && !(previousPoint && previousPoint.visible)) {\n          position = 'Top';\n        } else if (!nextPoint.visible || !previousPoint) {\n          position = nextPoint.yValue > yValue || previousPoint && previousPoint.yValue > yValue ? 'Bottom' : 'Top';\n        } else {\n          var slope = (nextPoint.yValue - previousPoint.yValue) / 2;\n          var intersectY = slope * index + (nextPoint.yValue - slope * (index + 1));\n          position = !this.yAxisInversed ? intersectY < yValue ? 'Top' : 'Bottom' : intersectY < yValue ? 'Bottom' : 'Top';\n        }\n      }\n    }\n    isBottom = position === 'Bottom';\n    positionIndex = ['Outer', 'Top', 'Bottom', 'Middle', 'Auto'].indexOf(position);\n    while (isOverLap && positionIndex < 4) {\n      yLocation = this.calculatePathPosition(y, this.getPosition(positionIndex), series, point, size, labelIndex);\n      labelRect = calculateRect(new ChartLocation(this.locationX, yLocation), size, this.margin);\n      isOverLap = labelRect.y < 0 || isCollide(labelRect, collection, series.clipRect) || labelRect.y + labelRect.height > series.clipRect.height;\n      positionIndex = isBottom ? positionIndex - 1 : positionIndex + 1;\n      isBottom = false;\n    }\n    return yLocation;\n  };\n  /**\n   * Initiates the animation for data labels.\n   *\n   * @param {Series} series - The series associated with the data labels.\n   * @param {Element} [element] - The element to animate.\n   * @returns {void}\n   * @private\n   */\n  DataLabel.prototype.doDataLabelAnimation = function (series, element) {\n    var shapeElements = series.shapeElement.childNodes;\n    var textNode = series.textElement.childNodes;\n    var delay = series.animation.delay + series.animation.duration;\n    var duration = series.chart.animated ? series.chart.duration : 200;\n    var location;\n    var length = element ? 1 : textNode.length;\n    var tempElement;\n    for (var i = 0; i < length; i++) {\n      tempElement = textNode[i];\n      if (element) {\n        element.style.visibility = 'hidden';\n        templateAnimate(element, delay, duration, 'ZoomIn');\n      } else {\n        location = new ChartLocation(+tempElement.getAttribute('x') + +tempElement.getAttribute('width') / 2, +tempElement.getAttribute('y') + +tempElement.getAttribute('height') / 2);\n        markerAnimate(tempElement, delay, series.animation.duration, series, null, location, true);\n        if (shapeElements[i]) {\n          tempElement = shapeElements[i];\n          location = new ChartLocation(+tempElement.getAttribute('x') + +tempElement.getAttribute('width') / 2, +tempElement.getAttribute('y') + +tempElement.getAttribute('height') / 2);\n          markerAnimate(tempElement, delay, series.animation.duration, series, null, location, true);\n        }\n      }\n    }\n  };\n  DataLabel.prototype.getPosition = function (index) {\n    return ['Outer', 'Top', 'Bottom', 'Middle', 'Auto'][index];\n  };\n  /**\n   * Get module name.\n   *\n   * @returns {string} - Returns the module name.\n   */\n  DataLabel.prototype.getModuleName = function () {\n    // Returns the module name\n    return 'DataLabel';\n  };\n  /**\n   * To destroy the dataLabel for series.\n   *\n   * @returns {void}\n   * @private\n   */\n  DataLabel.prototype.destroy = function () {\n    // Destroy method performed here\n  };\n  return DataLabel;\n}();\nexport { DataLabel };","map":{"version":3,"names":["ChartLocation","RectOption","isCollide","rotateTextSize","markerAnimate","appendChildElement","getVisiblePoints","getLabelText","convertHexToColor","calculateRect","textElement","colorNameToHex","animateTextElement","measureText","TextOption","Rect","textRender","createTemplate","getFontStyle","getElement","measureElementRect","templateAnimate","withIn","withInBounds","createElement","getValue","extend","getPoint","isRotatedRectIntersect","DataLabel","chart","errorHeight","dataLabelRectCollection","prototype","initPrivateVariables","series","marker","transform","clipPath","render","renderer","index","undefined","category","chartAreaType","clipRect","x","y","element","id","dataLabel","visible","enableCanvas","shapeElement","createGroup","setAttribute","markerHeight","type","height","commonId","calculateErrorHeight","position","chartBackground","chartArea","background","themeStyle","errorBar","direction","positiveHeight","errorBarModule","negativeHeight","isRectSeries","isTransposed","inverted","requireInvertedAxis","yAxisInversed","yAxis","isAxisInverse","templateId","visiblePoints","i","length","renderDataLabel","childElementCount","redraw","duration","appendChild","point","showZero","emptyPointSettings","mode","margin","labelText","labelLength","xPos","yPos","xValue","yValue","degree","rectCenterX","rectCenterY","labelLocation","textSize","clip","shapeRect","isDataLabelOverlap","dataLabelElement","startLocation","angle","labelIntersectAction","enableRotation","border","width","color","argsFont","font","symbolLocations","regions","text","argsData","cancel","name","fill","template","location","datalabelFont","trigger","fontBackground","isDataLabelShape","createDataLabelTemplate","rect","calculateTextPosition","actualRect","rectCoordinates","getRectanglePoints","isDataLabelOverlapWithChartBound","rotatedDataLabelCollections","push","currentPointIndex","dataLabelCollections","dataLabelShapeElement","getAttribute","isShape","drawRectangle","opacity","rx","ry","dashArray","Int32Array","backgroundColor","theme","indexOf","rgbValue","contrast","Math","round","r","g","b","left","top","textAnchor","oldText","document","getElementById","textContent","removedPointIndex","stackLabels","lastChild","querySelector","parseFloat","format","labelFormat","currentData","remove","renderStackLabels","stackLabelGroup","seriesElements","positivePoints","negativePoints","groupingValues","keys","stackLabelIndex","visibleSeries","Object","stackingGroup","groupIndex","count","seriesIndex","animation","enable","animateSeries","points","pointIndex","pointXValueAsKey","String","stackedValues","endValues","calculateStackLabel","_this","forEach","totalValue_1","currentPoint_1","positiveValue","negativeValue","symbolLocation","stackLabeltext","toFixed","slice","customLabelFormat","match","replace","toString","intl","getNumberFormat","useGrouping","useGroupingSeparator","padding","alignmentValue","right","yOffset","primaryYAxis","isInversed","xOffset","textAlignment","xPosition","max","min","yPosition","bottom","querySelectorAll","style","visibility","dataLabelID","hasOwnProperty","call","dataLabelRect","isCollided","loc1","loc2","loc3","loc4","initialClipRect","parentElement","data","labelIndex","childElement","styles","enableHtmlSanitizer","sanitize","calculateTemplateLabelSize","isReactCallback","elementRect","clipWidth","clipHeight","isOverlap","vAxis","xAxis","hAxis","seriesType","visibleRange","doDataLabelAnimation","labelRegion","getLabelLocation","locationX","borderWidth","calculateAlignment","alignment","calculatePathPosition","calculateRectPosition","calculatePolarRectPosition","locationY","dataLabelOutRegion","size","columnRadius","chartWidth","availableSize","alignmentSign","regionData","startAngle","PI","endAngle","radius","innerRadius","drawType","cos","sin","isInverted","median","maximum","minimum","upperQuartile","lowerQuartile","outliers","isMinus","textLength","extraSpace","abs","calculateRectActualPosition","calculateTopAndOuterPosition","check","interior","seriesLength","nextSeries","nextSeriesPoint","calculatePathActualPosition","labelRect","isOverLap","collection","finalPosition","actualPosition","getPosition","value","updateLabelLocation","inside","markerSize","nextPoint","previousPoint","yLocation","isBottom","positionIndex","slope","intersectY","shapeElements","childNodes","textNode","delay","animated","tempElement","getModuleName","destroy"],"sources":["C:/Users/mkfun/Desktop/ct assignment/admin/node_modules/@syncfusion/ej2-charts/src/chart/series/data-label.js"],"sourcesContent":["import { ChartLocation, RectOption, isCollide, rotateTextSize } from '../../common/utils/helper';\nimport { markerAnimate, appendChildElement, getVisiblePoints } from '../../common/utils/helper';\nimport { getLabelText, convertHexToColor, calculateRect, textElement, colorNameToHex, animateTextElement } from '../../common/utils/helper';\nimport { measureText, TextOption, Rect } from '@syncfusion/ej2-svg-base';\nimport { textRender } from '../../common/model/constants';\nimport { createTemplate, getFontStyle, getElement, measureElementRect, templateAnimate, withIn, withInBounds } from '../../common/utils/helper';\nimport { createElement, getValue, extend } from '@syncfusion/ej2-base';\nimport { getPoint, isRotatedRectIntersect } from '../../common/utils/helper';\n/**\n * The `DataLabel` module is used to render data labels for data points.\n */\nvar DataLabel = /** @class */ (function () {\n    /**\n     * Constructor for the data label module.\n     *\n     * @private\n     */\n    function DataLabel(chart) {\n        this.errorHeight = 0;\n        /** @private */\n        this.dataLabelRectCollection = {};\n        this.chart = chart;\n    }\n    DataLabel.prototype.initPrivateVariables = function (series, marker) {\n        var transform = '';\n        var clipPath = '';\n        var render = series.chart.renderer;\n        var index = (series.index === undefined) ? series.category : series.index;\n        if (series.chart.chartAreaType === 'Cartesian') {\n            transform = 'translate(' + series.clipRect.x + ',' + (series.clipRect.y) + ')';\n            clipPath = 'url(#' + this.chart.element.id + '_ChartSeriesClipRect_' + index + ')';\n        }\n        if (marker.dataLabel.visible && !this.chart.enableCanvas) {\n            series.shapeElement = render.createGroup({\n                'id': this.chart.element.id + 'ShapeGroup' + index,\n                'transform': transform,\n                'clip-path': 'url(#' + this.chart.element.id + '_ChartSeriesClipRect_' + index + ')'\n            });\n            series.textElement = render.createGroup({\n                'id': this.chart.element.id + 'TextGroup' + index,\n                'transform': transform,\n                'clip-path': clipPath\n            });\n            series.textElement.setAttribute('aria-hidden', 'true');\n        }\n        this.markerHeight = ((series.type === 'Scatter' || marker.visible)) ? (marker.height / 2) : 0;\n        this.commonId = this.chart.element.id + '_Series_' + index + '_Point_';\n        this.calculateErrorHeight(series, series.marker.dataLabel.position);\n        this.chartBackground = this.chart.chartArea.background === 'transparent' ?\n            this.chart.background || this.chart.themeStyle.background : this.chart.chartArea.background;\n    };\n    DataLabel.prototype.calculateErrorHeight = function (series, position) {\n        if (!series.errorBar.visible) {\n            return null;\n        }\n        else if (series.errorBar.visible && this.chart.chartAreaType !== 'PolarRadar') {\n            var direction = series.errorBar.direction;\n            var positiveHeight = this.chart.errorBarModule.positiveHeight;\n            var negativeHeight = this.chart.errorBarModule.negativeHeight;\n            if (this.isRectSeries(series)) {\n                if (position === 'Top' || position === 'Auto') {\n                    if (direction === 'Both' || direction === 'Minus') {\n                        this.errorHeight = negativeHeight;\n                    }\n                    else {\n                        this.errorHeight = 0;\n                    }\n                }\n                if (position === 'Outer' || position === 'Auto') {\n                    if (direction === 'Both' || direction === 'Plus') {\n                        this.errorHeight = positiveHeight;\n                    }\n                    else {\n                        this.errorHeight = 0;\n                    }\n                }\n            }\n            else {\n                if (position === 'Top' || position === 'Outer' || position === 'Auto') {\n                    if ((direction === 'Both' || direction === 'Plus') && (!series.chart.isTransposed)) {\n                        this.errorHeight = positiveHeight;\n                    }\n                    else {\n                        this.errorHeight = 0;\n                    }\n                }\n                if (position === 'Bottom' || position === 'Auto') {\n                    if (direction === 'Both' || direction === 'Minus') {\n                        this.errorHeight = negativeHeight;\n                    }\n                    else {\n                        this.errorHeight = 0;\n                    }\n                }\n            }\n        }\n        else {\n            this.errorHeight = 0;\n        }\n    };\n    DataLabel.prototype.isRectSeries = function (series) {\n        return series.isRectSeries || series.type === 'RangeArea' || series.type === 'SplineRangeArea' || series.type === 'RangeStepArea';\n    };\n    /**\n     * Render the data label for series.\n     *\n     * @param {Series} series - The series to render.\n     * @param {Chart} chart - The parent chart.\n     * @param {DataLabelSettingsModel} dataLabel - The settings for data labels.\n     * @returns {void}\n     * @private\n     */\n    DataLabel.prototype.render = function (series, chart, dataLabel) {\n        // initialize the private variable\n        this.initPrivateVariables(series, series.marker);\n        this.inverted = chart.requireInvertedAxis;\n        this.yAxisInversed = series.yAxis.isAxisInverse;\n        var templateId = chart.element.id + '_Series_' +\n            (series.index === undefined ? series.category : series.index) + '_DataLabelCollections';\n        var element = createElement('div', {\n            id: templateId\n        });\n        var visiblePoints = getVisiblePoints(series);\n        // Data label point iteration started\n        if (series.visible) {\n            for (var i = 0; i < visiblePoints.length; i++) {\n                this.renderDataLabel(series, visiblePoints[i], element, dataLabel);\n            }\n        }\n        if (element.childElementCount) {\n            if (!chart.enableCanvas) {\n                appendChildElement(chart.enableCanvas, getElement(chart.element.id + '_Secondary_Element'), element, chart.redraw, false, 'x', 'y', null, '', false, false, null, chart.duration);\n            }\n            else {\n                getElement(chart.element.id + '_Secondary_Element').appendChild(element);\n            }\n        }\n    };\n    DataLabel.prototype.renderDataLabel = function (series, point, element, dataLabel) {\n        if (!dataLabel.showZero && ((point.y === 0) || (point.y === 0 && series.emptyPointSettings.mode === 'Zero'))) {\n            return null;\n        }\n        this.margin = dataLabel.margin;\n        var labelText = [];\n        var labelLength;\n        var xPos;\n        var yPos;\n        var xValue;\n        var yValue;\n        var degree;\n        var rectCenterX;\n        var rectCenterY;\n        var labelLocation = { x: 0, y: 0 };\n        var textSize;\n        var clip = series.clipRect;\n        var shapeRect;\n        var isDataLabelOverlap = false;\n        var dataLabelElement = [];\n        var startLocation;\n        dataLabel.angle = dataLabel.labelIntersectAction === 'Rotate90' ? 90 : dataLabel.angle;\n        dataLabel.enableRotation = dataLabel.labelIntersectAction === 'Rotate90' ? true : dataLabel.enableRotation;\n        var angle = degree = dataLabel.angle;\n        var border = { width: dataLabel.border.width, color: dataLabel.border.color };\n        var argsFont = (extend({}, getValue('properties', dataLabel.font), null, true));\n        if ((point.symbolLocations.length && point.symbolLocations[0]) ||\n            (series.type === 'BoxAndWhisker' && point.regions.length)) {\n            labelText = point.text !== null ? getLabelText(point, series, this.chart) : [];\n            labelLength = labelText.length;\n            for (var i = 0; i < labelLength; i++) {\n                var argsData = {\n                    cancel: false, name: textRender, series: series,\n                    point: point, text: labelText[i], border: border,\n                    color: dataLabel.fill, template: dataLabel.template, font: argsFont, location: labelLocation,\n                    textSize: measureText(labelText[i], dataLabel.font, this.chart.themeStyle.datalabelFont)\n                };\n                this.chart.trigger(textRender, argsData);\n                if (!argsData.cancel) {\n                    this.fontBackground = argsData.color;\n                    this.isDataLabelShape(argsData);\n                    this.markerHeight = series.type === 'Bubble' ? (point.regions[0].height / 2) : this.markerHeight;\n                    if (argsData.template !== null) {\n                        this.createDataLabelTemplate(element, series, dataLabel, point, argsData, i, this.chart.redraw);\n                    }\n                    else {\n                        if (dataLabel.enableRotation) {\n                            textSize = rotateTextSize(dataLabel.font, argsData.text, dataLabel.angle, this.chart, this.chart.themeStyle.datalabelFont);\n                        }\n                        else {\n                            textSize = measureText(argsData.text, dataLabel.font, this.chart.themeStyle.datalabelFont);\n                        }\n                        var rect = this.calculateTextPosition(point, series, textSize, dataLabel, i);\n                        var actualRect = new Rect(rect.x + clip.x, rect.y + clip.y, rect.width, rect.height);\n                        //let notOverlapping: boolean;\n                        if (dataLabel.enableRotation) {\n                            var rectCoordinates = this.getRectanglePoints(actualRect);\n                            rectCenterX = rect.x + (rect.width / 2);\n                            rectCenterY = (rect.y + (rect.height / 2));\n                            isDataLabelOverlap = (dataLabel.labelIntersectAction === 'Rotate90' || angle === -90) ? false : this.isDataLabelOverlapWithChartBound(rectCoordinates, this.chart, { x: 0, y: 0, width: 0, height: 0 });\n                            if (!isDataLabelOverlap) {\n                                this.chart.rotatedDataLabelCollections.push(rectCoordinates);\n                                var currentPointIndex = this.chart.rotatedDataLabelCollections.length - 1;\n                                for (var index = currentPointIndex; index >= 0; index--) {\n                                    if (this.chart.rotatedDataLabelCollections[currentPointIndex] &&\n                                        this.chart.rotatedDataLabelCollections[index - 1] &&\n                                        isRotatedRectIntersect(this.chart.rotatedDataLabelCollections[currentPointIndex], this.chart.rotatedDataLabelCollections[index - 1])) {\n                                        isDataLabelOverlap = true;\n                                        this.chart.rotatedDataLabelCollections[currentPointIndex] = null;\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                        else {\n                            isDataLabelOverlap = isCollide(rect, this.chart.dataLabelCollections, clip);\n                        }\n                        if ((!isDataLabelOverlap || dataLabel.labelIntersectAction === 'None')) {\n                            var dataLabelShapeElement = getElement(this.commonId + point.index + '_TextShape_' + i);\n                            if (dataLabelShapeElement) {\n                                startLocation = { x: +dataLabelShapeElement.getAttribute('x'), y: +dataLabelShapeElement.getAttribute('y') };\n                            }\n                            this.chart.dataLabelCollections.push(actualRect);\n                            if (this.isShape) {\n                                shapeRect = this.chart.renderer.drawRectangle(new RectOption(this.commonId + point.index + '_TextShape_' + i, argsData.color, argsData.border, dataLabel.opacity, rect, dataLabel.rx, dataLabel.ry, '', dataLabel.border.dashArray), new Int32Array([clip.x, clip.y]));\n                                if (series.shapeElement) {\n                                    appendChildElement(this.chart.enableCanvas, series.shapeElement, shapeRect, this.chart.redraw, true, 'x', 'y', startLocation);\n                                }\n                            }\n                            // Checking the font color\n                            var backgroundColor = this.fontBackground === 'transparent' ? ((this.chart.theme.indexOf('Dark') > -1 || this.chart.theme.indexOf('HighContrast') > -1) ? 'black' : 'white') : this.fontBackground;\n                            var rgbValue = convertHexToColor(colorNameToHex(backgroundColor));\n                            var contrast = Math.round((rgbValue.r * 299 + rgbValue.g * 587 + rgbValue.b * 114) / 1000);\n                            xPos = (rect.x + this.margin.left + textSize.width / 2) + labelLocation.x;\n                            yPos = dataLabel.enableRotation && this.chart.chartAreaType !== 'PolarRadar' ? (rect.y + this.margin.top + textSize.height / 2 + textSize.width / 4 + (dataLabel.position === 'Auto' ? point.regions[0].width / 10 : 0)) + labelLocation.y : (rect.y + this.margin.top + textSize.height * 3 / 4) + labelLocation.y;\n                            labelLocation = { x: 0, y: 0 };\n                            if (angle !== 0 && dataLabel.enableRotation) {\n                                // xValue = xPos - (dataLabel.margin.left) / 2 + (dataLabel.margin.right / 2);\n                                xValue = rectCenterX;\n                                //yValue = yPos - (dataLabel.margin.top) / 2 - (textSize.height / dataLabel.margin.top) +\n                                // (dataLabel.margin.bottom) / 2;\n                                yValue = rectCenterY;\n                                degree = (angle > 360) ? angle - 360 : (angle < -360) ? angle + 360 : angle;\n                            }\n                            else {\n                                degree = 0;\n                                xValue = rect.x;\n                                yValue = rect.y;\n                                xPos -= this.chart.chartAreaType === 'Cartesian' && xPos + (textSize.width / 2) > clip.width ? (!this.chart.requireInvertedAxis && xPos > clip.width) ? 0 : (xPos + textSize.width / 2) - clip.width : 0;\n                                yPos -= (yPos + textSize.height > clip.y + clip.height && !(series.type.indexOf('Bar') > -1)) ? (yPos + textSize.height) - (clip.y + clip.height) : 0;\n                            }\n                            var textAnchor = dataLabel.labelIntersectAction === 'Rotate90' ? (dataLabel.position === 'Top' ? 'start' : (dataLabel.position === 'Middle' ? 'middle' : 'end')) :\n                                ((angle === -90 && dataLabel.enableRotation) ? (dataLabel.position === 'Top' ? 'end' : (dataLabel.position === 'Middle' ? 'middle' : 'start')) : 'middle');\n                            var oldText = void 0;\n                            if (this.chart.redraw && document.getElementById(this.commonId + point.index + '_Text_' + i)) {\n                                oldText = document.getElementById(this.commonId + point.index + '_Text_' + i).textContent;\n                            }\n                            dataLabelElement.push(textElement(this.chart.renderer, new TextOption(this.commonId + ((series.removedPointIndex !== null && series.removedPointIndex <= point.index) ? (point.index + 1) : point.index) + '_Text_' + i, xPos, yPos, textAnchor, argsData.text, 'rotate(' + degree + ',' + (xValue) + ',' + (yValue) + ')', 'auto', degree), argsData.font, argsData.font.color || (this.chart.theme === 'Bootstrap5' ? '#212529' : this.chart.theme === 'Bootstrap5Dark' ? '#DEE2E6' : ((contrast >= 128 || series.type === 'Hilo' || series.type === 'HiloOpenClose') ?\n                                this.chart.theme.indexOf('Tailwind3') > -1 ? '#111827' : 'black' : this.chart.theme.indexOf('Tailwind3') > -1 ? '#FFFFFF' : 'white')), series.textElement, false, this.chart.redraw, true, false, series.chart.duration, series.clipRect, null, null, this.chart.enableCanvas, null, this.chart.themeStyle.datalabelFont, new ChartLocation(xValue, yValue)));\n                            if (this.isShape && dataLabel.enableRotation) {\n                                shapeRect.setAttribute('transform', 'rotate(' + dataLabel.angle + ', ' + xValue + ', ' + yValue + ')');\n                            }\n                            if (this.chart.stackLabels.visible && series.type.indexOf('Stacking') > -1) {\n                                this.dataLabelRectCollection = !this.dataLabelRectCollection ? {}\n                                    : this.dataLabelRectCollection;\n                                this.dataLabelRectCollection[this.commonId + ((series.removedPointIndex !== null && series.removedPointIndex <= point.index) ? (point.index + 1) : point.index) + '_Text_' + i] = actualRect;\n                                this.dataLabelRectCollection[this.commonId + point.index + '_TextShape_' + i] = actualRect;\n                            }\n                            if (series.removedPointIndex !== null && series.removedPointIndex <= point.index) {\n                                series.textElement.lastChild.id = this.commonId + point.index + '_Text_' + i;\n                            }\n                            if (this.chart.redraw && oldText !== argsData.text) {\n                                animateTextElement(series.textElement.querySelector('#' + this.commonId + point.index + '_Text_' + i), this.chart.duration, parseFloat(oldText), parseFloat(argsData.text), series.marker.dataLabel.format || series.yAxis.labelFormat);\n                            }\n                        }\n                        else if (getElement(this.commonId + point.index + '_Text_0') && series.chart.redraw && series.currentData) {\n                            getElement(this.commonId + point.index + '_Text_0').remove();\n                        }\n                    }\n                }\n            }\n        }\n        return dataLabelElement;\n    };\n    /**\n     * Renders the stack labels for the chart.\n     *\n     * This method is responsible for displaying cumulative total values on stacked chart segments.\n     *\n     * @returns {void}\n     */\n    DataLabel.prototype.renderStackLabels = function () {\n        var stackLabelGroup = this.chart.renderer.createGroup({ id: this.chart.element.id + \"_StackLabelGroup\" });\n        this.chart.seriesElements.appendChild(stackLabelGroup);\n        var positivePoints = {};\n        var negativePoints = {};\n        var groupingValues = [];\n        var keys = [];\n        var stackLabelIndex = 0;\n        if (this.chart.visibleSeries && this.chart.visibleSeries.length > 0) {\n            for (var i = 0; i < this.chart.visibleSeries.length; i++) {\n                keys = Object.keys(groupingValues);\n                var series = this.chart.visibleSeries[i];\n                if (!groupingValues[series.stackingGroup]) {\n                    groupingValues[series.stackingGroup] = [];\n                    groupingValues[series.stackingGroup].push(series);\n                }\n                else if (groupingValues[series.stackingGroup] !== undefined) {\n                    groupingValues[series.stackingGroup].push(series);\n                }\n            }\n            if (keys[0] !== '') {\n                for (var groupIndex = 0; groupIndex < keys.length; groupIndex++) {\n                    positivePoints = {};\n                    negativePoints = {};\n                    var count = groupingValues[keys[groupIndex]][groupingValues[keys[groupIndex]].length - 1]\n                        .index;\n                    for (var seriesIndex = count; seriesIndex >= 0; seriesIndex--) {\n                        var series = this.chart.visibleSeries[seriesIndex];\n                        if (series.animation.enable && this.chart.animateSeries) {\n                            stackLabelGroup.setAttribute('visibility', 'hidden');\n                        }\n                        if (series.visible && series.points && series.points.length > 0) {\n                            for (var pointIndex = 0; pointIndex < series.points.length; pointIndex++) {\n                                var point = series.points[pointIndex];\n                                var pointXValueAsKey = String(point.x);\n                                if (!positivePoints[pointXValueAsKey] && series.stackedValues.endValues[pointIndex] > 0\n                                    && point.visible) {\n                                    positivePoints[pointXValueAsKey] = point;\n                                }\n                                if (!negativePoints[pointXValueAsKey] && series.stackedValues.endValues[pointIndex] < 0\n                                    && point.visible) {\n                                    negativePoints[pointXValueAsKey] = point;\n                                }\n                            }\n                        }\n                    }\n                    stackLabelIndex = this.calculateStackLabel(positivePoints, negativePoints, stackLabelGroup, stackLabelIndex);\n                }\n            }\n            else {\n                for (var seriesIndex = this.chart.visibleSeries.length - 1; seriesIndex >= 0; seriesIndex--) {\n                    var series = this.chart.visibleSeries[seriesIndex];\n                    if (series.animation.enable && this.chart.animateSeries) {\n                        stackLabelGroup.setAttribute('visibility', 'hidden');\n                    }\n                    if (series.visible && series.points && series.points.length > 0) {\n                        for (var pointIndex = 0; pointIndex < series.points.length; pointIndex++) {\n                            var point = series.points[pointIndex];\n                            var pointXValueAsKey = String(point.x);\n                            if (!positivePoints[pointXValueAsKey] && series.stackedValues.endValues[pointIndex] > 0\n                                && point.visible) {\n                                positivePoints[pointXValueAsKey] = point;\n                            }\n                            if (!negativePoints[pointXValueAsKey] && series.stackedValues.endValues[pointIndex] < 0\n                                && point.visible) {\n                                negativePoints[pointXValueAsKey] = point;\n                            }\n                        }\n                    }\n                }\n                this.calculateStackLabel(positivePoints, negativePoints, stackLabelGroup, stackLabelIndex);\n            }\n        }\n    };\n    /**\n     * This method is responsible for positioning the cumulative sum of stacking column series.\n     *\n     * @param {Object} positivePoints - The positive points of the stacking series.\n     * @param {Object} negativePoints - The negative points of the stacking series.\n     * @param {Element} stackLabelGroup - The stack label group element.\n     * @param {number} stackLabelIndex - The index of the stack label.\n     * @returns {number} - The number of stack labels.\n     */\n    DataLabel.prototype.calculateStackLabel = function (positivePoints, negativePoints, stackLabelGroup, stackLabelIndex) {\n        var _this = this;\n        [positivePoints, negativePoints].forEach(function (points, index) {\n            if (points) {\n                var totalValue_1 = 0;\n                var currentPoint_1;\n                Object.keys(points).forEach(function (pointXValueAsKey) {\n                    var positiveValue = points[pointXValueAsKey].series\n                        .stackedValues.endValues[points[pointXValueAsKey].index];\n                    var negativeValue = negativePoints[pointXValueAsKey] ?\n                        negativePoints[pointXValueAsKey].series.stackedValues.\n                            endValues[negativePoints[pointXValueAsKey].index] : 0;\n                    if (index === 0) {\n                        // Handle positive points\n                        totalValue_1 = positiveValue + negativeValue;\n                        currentPoint_1 = points[pointXValueAsKey];\n                    }\n                    else if (!positivePoints[pointXValueAsKey]) {\n                        // Handle negative points only if no corresponding positive point\n                        totalValue_1 = positiveValue;\n                        currentPoint_1 = points[pointXValueAsKey];\n                    }\n                    if (currentPoint_1 && currentPoint_1.symbolLocations[0]) {\n                        var series = currentPoint_1.series;\n                        var symbolLocation = currentPoint_1.symbolLocations[0];\n                        var labelFormat = _this.chart.stackLabels.format;\n                        var stackLabeltext = (totalValue_1 % 1 === 0)\n                            ? totalValue_1.toFixed(0)\n                            : (totalValue_1.toFixed(2).slice(-1) === '0' ? totalValue_1.toFixed(1) : totalValue_1.toFixed(2));\n                        if (labelFormat) {\n                            var customLabelFormat = labelFormat.match('{value}') !== null;\n                            stackLabeltext = customLabelFormat\n                                ? labelFormat.replace('{value}', stackLabeltext.toString())\n                                : _this.chart.intl.getNumberFormat({\n                                    format: labelFormat,\n                                    useGrouping: _this.chart.useGroupingSeparator\n                                })(totalValue_1);\n                        }\n                        var textSize = measureText(stackLabeltext, _this.chart.stackLabels.font, _this.chart.themeStyle.datalabelFont);\n                        // Define padding to maintain a consistent gap from the symbol location values\n                        var padding = 10;\n                        if (_this.chartBackground === undefined) {\n                            _this.chartBackground = _this.chart.chartArea.background === 'transparent' ?\n                                _this.chart.background || _this.chart.themeStyle.background : _this.chart.chartArea.background;\n                        }\n                        var backgroundColor = _this.chart.stackLabels.fill === 'transparent' && _this.chartBackground === 'transparent' ? ((_this.chart.theme.indexOf('Dark') > -1 || _this.chart.theme.indexOf('HighContrast') > -1) ? 'black' : 'white') : _this.chart.stackLabels.fill !== 'transparent' ? _this.chart.stackLabels.fill : _this.chartBackground;\n                        var rgbValue = convertHexToColor(colorNameToHex(backgroundColor));\n                        var contrast = Math.round((rgbValue.r * 299 + rgbValue.g * 587 + rgbValue.b * 114) / 1000);\n                        var alignmentValue = textSize.width + _this.chart.stackLabels.border.width\n                            + _this.chart.stackLabels.margin.left + _this.chart.stackLabels.margin.right - padding / 2;\n                        var yOffset = _this.chart.requireInvertedAxis ? padding / 2 :\n                            (_this.chart.primaryYAxis.isInversed ? (index === 0 ? (textSize.height + padding / 2) : -padding)\n                                : (index === 0 ? -padding : (textSize.height + padding / 2)));\n                        var xOffset = _this.chart.requireInvertedAxis ?\n                            ((_this.chart.primaryYAxis.isInversed ? (index === 0 ? -(padding + textSize.width / 2) :\n                                (padding + textSize.width / 2)) : (index === 0 ? (padding + textSize.width / 2) :\n                                -(padding + textSize.width / 2)))) : 0;\n                        xOffset += _this.chart.stackLabels.font.textAlignment === 'Far' ? alignmentValue :\n                            (_this.chart.stackLabels.font.textAlignment === 'Near' ? -alignmentValue : 0);\n                        var xPosition = Math.max(series.clipRect.x + textSize.width, Math.min(xOffset + series.clipRect.x + symbolLocation.x, series.clipRect.x\n                            + series.clipRect.width - textSize.width));\n                        var yPosition = Math.max(series.clipRect.y + textSize.height, Math.min(yOffset + series.clipRect.y + symbolLocation.y -\n                            ((_this.chart.stackLabels.angle > 0 && !_this.chart.requireInvertedAxis) ? textSize.width / 2 : 0), series.clipRect.y + series.clipRect.height - textSize.height));\n                        var rect = new Rect(xPosition - textSize.width / 2 - _this.chart.stackLabels.margin.left, yPosition - textSize.height - _this.chart.stackLabels.margin.top, textSize.width + (_this.chart.stackLabels.margin.left + _this.chart.stackLabels.margin.right), textSize.height + padding / 2 + (_this.chart.stackLabels.margin.top + _this.chart.stackLabels.margin.bottom));\n                        var shapeRect = _this.chart.renderer.drawRectangle(new RectOption(_this.chart.element.id + \"StackLabel_TextShape_\" + stackLabelIndex, _this.chart.stackLabels.fill, _this.chart.stackLabels.border, null, rect, _this.chart.stackLabels.rx, _this.chart.stackLabels.ry, '', null), new Int32Array([symbolLocation.x, symbolLocation.y]));\n                        shapeRect.setAttribute('transform', \"rotate(\" + _this.chart.stackLabels.angle + \", \" + xPosition + \", \" + yPosition + \")\");\n                        stackLabelGroup.appendChild(shapeRect);\n                        textElement(_this.chart.renderer, new TextOption(_this.chart.element.id + \"_StackLabel_\" + stackLabelIndex, xPosition, yPosition, 'middle', stackLabeltext, \"rotate(\" + _this.chart.stackLabels.angle + \", \" + xPosition + \", \" + yPosition + \")\", 'auto', _this.chart.stackLabels.angle), _this.chart.stackLabels.font, (_this.chart.stackLabels.font.color || (_this.chart.theme === 'Bootstrap5' ? '#212529' : _this.chart.theme === 'Bootstrap5Dark' ? '#DEE2E6' : ((contrast >= 128) ?\n                            _this.chart.theme.indexOf('Tailwind3') > -1 ? '#111827' : 'black' : _this.chart.theme.indexOf('Tailwind3') > -1 ? '#FFFFFF' : 'white'))), stackLabelGroup, null, _this.chart.redraw, true, null, _this.chart.duration, series.clipRect, null, null, _this.chart.enableCanvas, null, _this.chart.themeStyle.datalabelFont, null);\n                        if (series.type === 'StackingLine' || series.type === 'StackingArea') {\n                            document.querySelectorAll(\"[id^=\\\"\" + _this.chart.element.id + \"_Series_\" + series.index + \"_Point_\" + currentPoint_1.index + \"_Text_\\\"], \\n                                [id^=\\\"\" + _this.chart.element.id + \"_Series_\" + series.index + \"_Point_\" + currentPoint_1.index + \"_TextShape_\\\"]\").forEach(function (element) {\n                                if (element.id) {\n                                    element.style.visibility = 'hidden';\n                                    element.setAttribute('data-collide', 'true');\n                                }\n                            });\n                        }\n                        for (var dataLabelID in _this.dataLabelRectCollection) {\n                            if (Object.prototype.hasOwnProperty.call(_this.dataLabelRectCollection, dataLabelID)) {\n                                var dataLabelRect = _this.dataLabelRectCollection[dataLabelID];\n                                if (dataLabelRect) {\n                                    var isCollided = isCollide(rect, [dataLabelRect], { x: 0, y: 0, height: 0, width: 0 });\n                                    if (isCollided) {\n                                        var dataLabelElement = document.getElementById(dataLabelID);\n                                        if (dataLabelElement) {\n                                            dataLabelElement.style.visibility = 'hidden';\n                                            dataLabelElement.setAttribute('data-collide', 'true');\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    stackLabelIndex++;\n                });\n            }\n        });\n        return stackLabelIndex;\n    };\n    /**\n     * Retrieves the points of a rectangle.\n     *\n     * @param {Rect} rect - The rectangle whose points are to be retrieved.\n     * @returns {ChartLocation[]} - The points of the rectangle.\n     */\n    DataLabel.prototype.getRectanglePoints = function (rect) {\n        var loc1 = new ChartLocation(rect.x, rect.y);\n        var loc2 = new ChartLocation(rect.x + rect.width, rect.y);\n        var loc3 = new ChartLocation(rect.x + rect.width, rect.y + rect.height);\n        var loc4 = new ChartLocation(rect.x, rect.y + rect.height);\n        return [loc1, loc2, loc3, loc4];\n    };\n    DataLabel.prototype.isDataLabelOverlapWithChartBound = function (rectCoordinates, chart, clip) {\n        for (var index = 0; index < rectCoordinates.length; index++) {\n            if (!withInBounds(rectCoordinates[index].x + clip.x, rectCoordinates[index].y + clip.y, chart.initialClipRect)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * Creates a template for data labels.\n     *\n     * @param {HTMLElement} parentElement - The parent element to which the template will be appended.\n     * @param {Series} series - The series associated with the data label.\n     * @param {DataLabelSettingsModel} dataLabel - The settings for the data label.\n     * @param {Points} point - The data point to which the data label is associated.\n     * @param {ITextRenderEventArgs} data - The event data associated with rendering the data label.\n     * @param {number} labelIndex - The index of the data label.\n     * @param {boolean} redraw - Specifies whether to redraw the template.\n     * @returns {void}\n     */\n    DataLabel.prototype.createDataLabelTemplate = function (parentElement, series, dataLabel, point, data, labelIndex, redraw) {\n        this.margin = { left: 0, right: 0, bottom: 0, top: 0 };\n        var clip = series.clipRect;\n        var childElement = createTemplate(createElement('div', {\n            id: this.chart.element.id + '_Series_' + (series.index === undefined ? series.category : series.index) + '_DataLabel_'\n                + point.index + (labelIndex ? ('_' + labelIndex) : ''),\n            styles: 'position: absolute;background-color:' + data.color + ';' +\n                getFontStyle(dataLabel.font, this.chart.themeStyle.datalabelFont) + ';border:' + data.border.width + 'px solid ' + data.border.color + ';'\n        }), point.index, (this.chart.enableHtmlSanitizer ? this.chart.sanitize(data.template) : data.template), this.chart, point, series, this.chart.element.id + '_DataLabel', labelIndex);\n        this.calculateTemplateLabelSize(parentElement, childElement, point, series, dataLabel, labelIndex, clip, redraw);\n    };\n    DataLabel.prototype.calculateTemplateLabelSize = function (parentElement, childElement, point, series, dataLabel, labelIndex, clip, redraw, isReactCallback) {\n        var elementRect = measureElementRect(childElement, redraw, isReactCallback);\n        var rect = this.calculateTextPosition(point, series, { width: elementRect.width, height: elementRect.height }, dataLabel, labelIndex);\n        var clipWidth = 0;\n        var clipHeight = 0;\n        var isOverlap = false;\n        if (isReactCallback) {\n            isOverlap = (elementRect.width === 0 || elementRect.height === 0); // To check the data label already overlap before react callback call\n            // clipWidth = ((series.clipRect.x + rect.x) + elementRect.width) > parentElement.clientWidth ?\n            //     (parentElement.clientWidth - (series.clipRect.x + rect.x)) : 0;\n            // clipHeight = (series.points.length - 1 === point.index) ? elementRect.height / 2 : 0;\n        }\n        childElement.style.left = ((this.chart.chartAreaType === 'PolarRadar' ? 0 : series.clipRect.x) + rect.x - clipWidth) + 'px';\n        childElement.style.top = ((this.chart.chartAreaType === 'PolarRadar' ? 0 : series.clipRect.y) + rect.y + clipHeight) + 'px';\n        var vAxis = series.chart.requireInvertedAxis ? series.xAxis : series.yAxis;\n        var hAxis = series.chart.requireInvertedAxis ? series.yAxis : series.xAxis;\n        if (childElement.childElementCount && !isOverlap && (!isCollide(rect, this.chart.dataLabelCollections, clip) ||\n            dataLabel.labelIntersectAction === 'None') && (series.seriesType !== 'XY' || point.yValue === undefined ||\n            withIn(point.yValue, series.yAxis.visibleRange) || (series.type.indexOf('Stacking') > -1) ||\n            (series.type.indexOf('100') > -1 && withIn(series.stackedValues.endValues[point.index], series.yAxis.visibleRange))) &&\n            withIn(point.xValue, series.xAxis.visibleRange) && parseFloat(childElement.style.top) >= vAxis.rect.y &&\n            parseFloat(childElement.style.left) >= hAxis.rect.x &&\n            parseFloat(childElement.style.top) <= vAxis.rect.y + vAxis.rect.height &&\n            parseFloat(childElement.style.left) <= hAxis.rect.x + hAxis.rect.width) {\n            this.chart.dataLabelCollections.push(new Rect(rect.x + clip.x, rect.y + clip.y, rect.width, rect.height));\n            appendChildElement(this.chart.enableCanvas, parentElement, childElement, redraw, true, 'left', 'top');\n            if (series.animation.enable && this.chart.animateSeries && !this.chart.enableCanvas) {\n                this.doDataLabelAnimation(series, childElement);\n            }\n            else if (this.chart.enableCanvas) {\n                parentElement.appendChild(childElement);\n            }\n        }\n    };\n    DataLabel.prototype.calculateTextPosition = function (point, series, textSize, dataLabel, labelIndex) {\n        var labelRegion = labelIndex > 1 ? (series.type === 'Candle') ? point.regions[1] : point.regions[0] : point.regions[0];\n        if (labelIndex > 1 && series.type === 'HiloOpenClose') {\n            labelRegion = (labelIndex === 2) ? point.regions[1] : point.regions[2];\n        }\n        var location;\n        location = this.getLabelLocation(point, series, textSize, labelIndex);\n        var padding = 5;\n        var clipRect = series.clipRect;\n        // calculating alignment\n        if (!this.chart.requireInvertedAxis || !this.isRectSeries(series) || series.type === 'BoxAndWhisker') {\n            this.locationX = location.x;\n            var alignmentValue = textSize.height + (this.borderWidth * 2) + this.markerHeight +\n                this.margin.bottom + this.margin.top + padding;\n            location.x = (dataLabel.position === 'Auto') ? location.x :\n                this.calculateAlignment(alignmentValue, location.x, dataLabel.alignment, this.isRectSeries(series) ? point.yValue < 0 : false);\n            // calculating position\n            location.y = (!this.isRectSeries(series) || series.type === 'BoxAndWhisker') ?\n                this.calculatePathPosition(location.y, dataLabel.position, series, point, textSize, labelIndex) :\n                this.calculateRectPosition(location.y, labelRegion, point.yValue < 0 !== this.yAxisInversed, dataLabel.position, series, textSize, labelIndex, point);\n            if (this.isRectSeries(series) && this.chart.chartAreaType === 'PolarRadar') {\n                location = this.calculatePolarRectPosition(location, dataLabel.position, series, point, textSize, labelIndex, dataLabel.alignment, alignmentValue);\n            }\n        }\n        else {\n            this.locationY = location.y;\n            var alignmentValue = textSize.width + this.borderWidth + this.margin.left + this.margin.right - padding;\n            location.x = dataLabel.position === 'Auto' ? location.x :\n                this.calculateAlignment(alignmentValue, location.x, dataLabel.alignment, point.yValue < 0);\n            location.x = this.calculateRectPosition(location.x, labelRegion, point.yValue < 0 !== this.yAxisInversed, dataLabel.position, series, textSize, labelIndex, point);\n        }\n        var rect = calculateRect(location, textSize, this.margin);\n        // Checking the condition whether data Label has been exist the clip rect\n        if (!(dataLabel.enableRotation === true && dataLabel.angle !== 0) &&\n            !((rect.y > (clipRect.y + clipRect.height)) || (rect.x > (clipRect.x + clipRect.width)) ||\n                (rect.x + rect.width < 0) || (rect.y + rect.height < 0))) {\n            rect.x = rect.x < 0 ? (series.type === 'StackingColumn' && !this.inverted ? 0 : padding) : rect.x;\n            rect.y = (rect.y < 0 && !this.chart.requireInvertedAxis) && !(dataLabel.labelIntersectAction === 'None') ? padding : rect.y;\n            rect.x -= (rect.x + rect.width) > (clipRect.x + clipRect.width) ? (rect.x + rect.width)\n                - (clipRect.x + clipRect.width) + padding : 0;\n            rect.y -= (rect.y + rect.height) > (clipRect.y + clipRect.height) ? (rect.y + rect.height)\n                - (clipRect.y + clipRect.height) + padding : 0;\n            this.fontBackground = this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground;\n        }\n        var dataLabelOutRegion;\n        if (this.inverted && series.isRectSeries && (rect.x + rect.width > labelRegion.x + labelRegion.width)) {\n            dataLabelOutRegion = true;\n        }\n        this.fontBackground = dataLabelOutRegion ? this.chartBackground : this.fontBackground;\n        return rect;\n    };\n    // Calculation label location for polar column draw types\n    DataLabel.prototype.calculatePolarRectPosition = function (location, position, series, point, size, labelIndex, alignment, alignmentValue) {\n        var padding = 5;\n        var columnRadius;\n        var chartWidth = this.chart.availableSize.width;\n        var alignmentSign = (alignment === 'Center') ? 0 : (alignment === 'Far' ? 1 : -1);\n        var angle = (point.regionData.startAngle - 0.5 * Math.PI) + (point.regionData.endAngle - point.regionData.startAngle) / 2;\n        if (labelIndex === 0) {\n            columnRadius = point.regionData.radius < point.regionData.innerRadius ? point.regionData.innerRadius\n                : point.regionData.radius;\n        }\n        else {\n            columnRadius = point.regionData.radius > point.regionData.innerRadius ? point.regionData.innerRadius\n                : point.regionData.radius;\n        }\n        this.fontBackground = this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground;\n        if (series.drawType.indexOf('Stacking') > -1) {\n            position = position === 'Outer' ? 'Top' : position;\n        }\n        else if (series.drawType.indexOf('Range') > -1) {\n            position = (position === 'Outer' || position === 'Top') ? position : 'Auto';\n        }\n        if (position === 'Outer') {\n            columnRadius = labelIndex === 0 ? columnRadius + 2 * padding + this.markerHeight :\n                columnRadius - 2 * padding - this.markerHeight;\n        }\n        else if (position === 'Middle') {\n            columnRadius = columnRadius / 2 + padding;\n            if (series.drawType === 'StackingColumn') {\n                columnRadius = point.regionData.innerRadius + ((point.regionData.radius - point.regionData.innerRadius) / 2)\n                    + padding - (size.height / 2);\n            }\n        }\n        else if (position === 'Top') {\n            columnRadius = labelIndex === 0 ? columnRadius - 2 * padding - this.markerHeight :\n                columnRadius + 2 * padding + this.markerHeight;\n        }\n        else if (position === 'Bottom') {\n            columnRadius = 2 * padding;\n            columnRadius += (series.drawType === 'StackingColumn') ? (point.regionData.innerRadius + this.markerHeight) : 0;\n        }\n        else {\n            if (labelIndex === 0) {\n                columnRadius = columnRadius >= series.chart.radius ? columnRadius - padding :\n                    series.drawType === 'StackingColumn' ? columnRadius - 2 * padding : columnRadius + 2 * padding;\n            }\n            else {\n                columnRadius = columnRadius >= series.chart.radius ? columnRadius + padding : columnRadius - 2 * padding;\n            }\n        }\n        columnRadius += (alignmentValue * alignmentSign);\n        location.x = series.clipRect.width / 2 + series.clipRect.x + columnRadius * Math.cos(angle);\n        // To change x location based on text anchor for column and stackingcolumn chart\n        if (series.drawType === 'StackingColumn') {\n            location.x = location.x < chartWidth / 2 ? location.x + size.width / 2 :\n                (location.x > chartWidth / 2 ? location.x - size.width / 2 : location.x);\n        }\n        else if (series.drawType === 'Column') {\n            location.x = location.x < chartWidth / 2 ? location.x - size.width / 2 :\n                (location.x > chartWidth / 2 ? location.x + size.width / 2 : location.x);\n        }\n        location.y = series.clipRect.height / 2 + series.clipRect.y + columnRadius * Math.sin(angle);\n        return location;\n    };\n    /**\n     * Gets the location for the data label.\n     *\n     * @param {Points} point - The data point associated with the label.\n     * @param {Series} series - The series associated with the data label.\n     * @param {Size} textSize - The size of the text to be displayed in the data label.\n     * @param {number} labelIndex - The index of the data label.\n     * @returns {ChartLocation} - The location for the data label.\n     */\n    DataLabel.prototype.getLabelLocation = function (point, series, textSize, labelIndex) {\n        var location = new ChartLocation(0, 0);\n        var labelRegion = (series.type === 'Candle' && labelIndex > 1) ? point.regions[1] : point.regions[0];\n        if (series.type === 'HiloOpenClose') {\n            labelRegion = (labelIndex === 2) ? point.regions[1] : point.regions[2];\n        }\n        var xAxis = series.xAxis;\n        var yAxis = series.yAxis;\n        var isInverted = series.chart.requireInvertedAxis;\n        if (series.type === 'BoxAndWhisker') {\n            this.markerHeight = 0;\n            switch (labelIndex) {\n                case 0:\n                    location = getPoint(point.xValue, point.median, xAxis, yAxis, isInverted);\n                    break;\n                case 1:\n                    location = getPoint(point.xValue, point.maximum, xAxis, yAxis, isInverted);\n                    break;\n                case 2:\n                    location = getPoint(point.xValue, point.minimum, xAxis, yAxis, isInverted);\n                    break;\n                case 3:\n                    location = getPoint(point.xValue, point.upperQuartile, xAxis, yAxis, isInverted);\n                    break;\n                case 4:\n                    location = getPoint(point.xValue, point.lowerQuartile, xAxis, yAxis, isInverted);\n                    break;\n                default: {\n                    location = getPoint(point.xValue, point.outliers[labelIndex - 5], xAxis, yAxis, isInverted);\n                    this.markerHeight = series.marker.height / 2;\n                    break;\n                }\n            }\n            if (isInverted) {\n                location.y = point.regions[0].y + (point.regions[0].height / 2);\n            }\n            else {\n                location.x = point.regions[0].x + (point.regions[0].width / 2);\n            }\n        }\n        else if (isInverted && series.type.indexOf('Stacking') > -1 && point.yValue === 0) {\n            location = { x: labelRegion.x + labelRegion.width, y: labelRegion.y + (labelRegion.height) / 2 };\n        }\n        else if (labelIndex === 0 || labelIndex === 1) {\n            location = new ChartLocation(point.symbolLocations[0].x, point.symbolLocations[0].y);\n        }\n        else if ((labelIndex === 2 || labelIndex === 3) && series.type === 'Candle') {\n            location = new ChartLocation(point.symbolLocations[1].x, point.symbolLocations[1].y);\n        }\n        else if (isInverted) {\n            location = { x: labelRegion.x + (labelRegion.width) / 2, y: labelRegion.y };\n        }\n        else {\n            location = { x: labelRegion.x + labelRegion.width, y: labelRegion.y + (labelRegion.height) / 2 };\n        }\n        //Aligning the label at the beginning of the tick, when tick size is less than text size\n        if (labelIndex > 1 && series.type === 'HiloOpenClose') {\n            if (series.chart.requireInvertedAxis) {\n                var height = labelRegion.height;\n                location.y = labelRegion.y + height / 2 + 2 * (labelIndex === 2 ? 1 : -1);\n            }\n            else {\n                var width = labelRegion.width;\n                location.x = labelRegion.x + width / 2 + 2 * (labelIndex === 2 ? 1 : -1);\n            }\n        }\n        return location;\n    };\n    DataLabel.prototype.calculateRectPosition = function (labelLocation, rect, isMinus, position, series, textSize, labelIndex, point) {\n        if (series.chart.chartAreaType === 'PolarRadar') {\n            return null;\n        }\n        var padding = 5;\n        var margin = this.margin;\n        var textLength = (series.marker.dataLabel.enableRotation ? textSize.width :\n            (!this.inverted ? textSize.height : textSize.width));\n        if (position === 'Bottom' && series.type === 'StackingColumn' && !this.inverted && rect.height < textSize.height) {\n            this.extraSpace = this.borderWidth + ((Math.abs(rect.height - textSize.height / 2) < padding) ? 0 : padding);\n        }\n        else {\n            this.extraSpace = this.borderWidth + textLength / 2 + (position !== 'Outer' && series.type.indexOf('Column') > -1 &&\n                (Math.abs(rect.height - textSize.height) < padding) ? 0 : padding);\n        }\n        if (series.type === 'StackingColumn100' || series.type === 'StackingBar100') {\n            position = (position === 'Outer') ? 'Top' : position;\n        }\n        else if (series.type.indexOf('Range') > -1) {\n            position = (position === 'Outer' || position === 'Top') ? position : 'Auto';\n        }\n        else if (series.type === 'Waterfall') {\n            position = position === 'Auto' ? 'Middle' : position;\n        }\n        switch (position) {\n            case 'Bottom':\n                labelLocation = !this.inverted ?\n                    isMinus ? (labelLocation + (series.type === 'Waterfall' ? (-this.extraSpace - margin.top - this.markerHeight) : (-rect.height + this.extraSpace + margin.top))) :\n                        (labelLocation + rect.height - this.extraSpace - margin.bottom) :\n                    isMinus ? (labelLocation + (series.type === 'Waterfall' ? (+this.extraSpace + margin.left + this.markerHeight) : (+rect.width - this.extraSpace - margin.left))) :\n                        (labelLocation - rect.width + this.extraSpace + margin.right);\n                break;\n            case 'Middle':\n                labelLocation = labelLocation = !this.inverted ?\n                    (isMinus ? labelLocation - (rect.height / 2) : labelLocation + (rect.height / 2)) :\n                    (isMinus ? labelLocation + (rect.width / 2) : labelLocation - (rect.width / 2));\n                break;\n            case 'Auto':\n                labelLocation = this.calculateRectActualPosition(labelLocation, rect, isMinus, series, textSize, labelIndex, point);\n                break;\n            default:\n                this.extraSpace += this.errorHeight;\n                labelLocation = this.calculateTopAndOuterPosition(labelLocation, rect, position, series, labelIndex, this.extraSpace, isMinus, point);\n                break;\n        }\n        var check = !this.inverted ? (labelLocation < rect.y || labelLocation > rect.y + rect.height) :\n            (labelLocation < rect.x || labelLocation > rect.x + rect.width);\n        this.fontBackground = check ?\n            (this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground)\n            : this.fontBackground === 'transparent' ? (point.color || series.interior) : this.fontBackground;\n        var seriesLength = series.chart.series.length;\n        if (position === 'Outer' && (series.type.indexOf('Stacking') > -1) && ((seriesLength - 1) > series.index)) {\n            var nextSeries = void 0;\n            var nextSeriesPoint = void 0;\n            for (var i = series.index + 1; i < seriesLength; i++) {\n                nextSeries = series.chart.series[i];\n                nextSeriesPoint = nextSeries.points[point.index];\n                if ((nextSeries.type.indexOf('Stacking') > -1) && (nextSeries.type.indexOf('100') === -1)) {\n                    this.fontBackground = (nextSeriesPoint && ((nextSeriesPoint.yValue < 0 && point.yValue < 0) ||\n                        (nextSeriesPoint.yValue > 0 && point.yValue > 0))) ? (nextSeriesPoint ? nextSeriesPoint.color :\n                        nextSeries.interior) : this.fontBackground;\n                    break;\n                }\n            }\n        }\n        return labelLocation;\n    };\n    DataLabel.prototype.calculatePathPosition = function (labelLocation, position, series, point, size, labelIndex) {\n        var padding = 5;\n        if ((series.type.indexOf('Area') > -1 && series.type !== 'RangeArea' && series.type !== 'SplineRangeArea' && series.type !== 'RangeStepArea')\n            && this.yAxisInversed && series.marker.dataLabel.position !== 'Auto') {\n            position = position === 'Top' ? 'Bottom' : position === 'Bottom' ? 'Top' : position;\n        }\n        this.fontBackground = this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground;\n        switch (position) {\n            case 'Top':\n            case 'Outer':\n                labelLocation = labelLocation - this.markerHeight - this.borderWidth - size.height / 2 - this.margin.bottom - padding -\n                    this.errorHeight;\n                break;\n            case 'Bottom':\n                labelLocation = labelLocation + this.markerHeight + this.borderWidth + size.height / 2 + this.margin.top + padding +\n                    this.errorHeight;\n                break;\n            case 'Auto':\n                labelLocation = this.calculatePathActualPosition(labelLocation, this.markerHeight, series, point, size, labelIndex);\n                break;\n        }\n        return labelLocation;\n    };\n    DataLabel.prototype.isDataLabelShape = function (style) {\n        this.isShape = (style.color !== 'transparent' || style.border.width > 0);\n        this.borderWidth = style.border.width;\n        if (!this.isShape) {\n            this.margin = { left: 0, right: 0, bottom: 0, top: 0 };\n        }\n    };\n    DataLabel.prototype.calculateRectActualPosition = function (labelLocation, rect, isMinus, series, size, labelIndex, point) {\n        var location;\n        var labelRect;\n        var isOverLap = true;\n        var position = 0;\n        var collection = this.chart.dataLabelCollections;\n        var finalPosition = series.type.indexOf('Range') !== -1 || series.type === 'Hilo' ? 2 : 4;\n        while (isOverLap && position < finalPosition) {\n            var actualPosition = this.getPosition(position);\n            this.fontBackground = series.marker.dataLabel.fill;\n            if (series.type.indexOf('Stacking') > -1 && actualPosition === 'Outer') {\n                actualPosition = 'Top';\n                position++;\n            }\n            location = this.calculateRectPosition(labelLocation, rect, isMinus, actualPosition, series, size, labelIndex, point);\n            if (!this.inverted) {\n                if (series.marker.dataLabel.enableRotation) {\n                    size.width = size.width - point.regions[0].width / 10;\n                }\n                labelRect = calculateRect(new ChartLocation(this.locationX, location), size, this.margin);\n                isOverLap = labelRect.y < 0 || isCollide(labelRect, collection, series.clipRect) || labelRect.y > series.clipRect.height;\n                if (series.marker.dataLabel.template === null && isOverLap !== true) {\n                    isOverLap = labelRect.y / 2 + size.height + (actualPosition === 'Outer' ? point.regions[0].height + this.extraSpace : point.regions[0].height - 2 * this.extraSpace) > series.clipRect.height;\n                }\n            }\n            else {\n                labelRect = calculateRect(new ChartLocation(location, this.locationY), size, this.margin);\n                isOverLap = labelRect.x < 0 || isCollide(labelRect, collection, series.clipRect) ||\n                    labelRect.x + labelRect.width > series.clipRect.width;\n            }\n            position++;\n        }\n        return location;\n    };\n    // alignment calculation assigned here\n    DataLabel.prototype.calculateAlignment = function (value, labelLocation, alignment, isMinus) {\n        switch (alignment) {\n            case 'Far':\n                labelLocation = !this.inverted ? (isMinus ? labelLocation + value : labelLocation - value) :\n                    (isMinus ? labelLocation - value : labelLocation + value);\n                break;\n            case 'Near':\n                labelLocation = !this.inverted ? (isMinus ? labelLocation - value : labelLocation + value) :\n                    (isMinus ? labelLocation + value : labelLocation - value);\n                break;\n        }\n        return labelLocation;\n    };\n    //calculation for top and outer position of datalabel for rect series\n    DataLabel.prototype.calculateTopAndOuterPosition = function (location, rect, position, series, index, extraSpace, isMinus, point) {\n        var margin = this.margin;\n        var top;\n        switch (series.type) {\n            case 'RangeColumn':\n            case 'RangeArea':\n            case 'RangeStepArea':\n            case 'SplineRangeArea':\n            case 'Hilo':\n                top = (index === 0 && !this.yAxisInversed) || (index === 1 && this.yAxisInversed);\n                location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top);\n                break;\n            case 'Candle':\n                top = (index === 0 || index === 2) && !this.yAxisInversed\n                    || (index === 1 || index === 3) && this.yAxisInversed;\n                location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top, index > 1);\n                break;\n            case 'HiloOpenClose':\n                if (index <= 1) {\n                    top = (index === 0 && !this.yAxisInversed) || (index === 1 && this.yAxisInversed);\n                    location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top);\n                }\n                else {\n                    if (this.yAxisInversed) {\n                        location = !this.inverted ? location + extraSpace + margin.top : location - extraSpace - margin.right;\n                    }\n                    else {\n                        location = !this.inverted ? location - extraSpace - margin.bottom : location + extraSpace + margin.left;\n                    }\n                }\n                break;\n            default:\n                if (((isMinus && position === 'Top') || (!isMinus && position === 'Outer')) || (position === 'Top' && series.visiblePoints[point.index].yValue === 0)) {\n                    location = !this.inverted ? location + (isMinus && series.type === 'Waterfall' ? (-rect.height + extraSpace + margin.bottom) : (-extraSpace - margin.bottom - this.markerHeight)) :\n                        location + (isMinus && series.type === 'Waterfall' ? (+rect.width - extraSpace - margin.left) : (+extraSpace + margin.left + this.markerHeight));\n                }\n                else {\n                    location = !this.inverted ? location + (isMinus && series.type === 'Waterfall' ? (-rect.height - extraSpace - margin.top) : (+extraSpace + margin.top + this.markerHeight)) :\n                        location + (isMinus && series.type === 'Waterfall' ? (+rect.width + extraSpace + margin.top) : (-extraSpace - margin.right - this.markerHeight));\n                }\n                break;\n        }\n        return location;\n    };\n    /**\n     * Updates the location of the data label.\n     *\n     * @param {LabelPosition} position - The position of the data label.\n     * @param {number} location - The initial location of the data label.\n     * @param {number} extraSpace - Extra space to adjust the label position.\n     * @param {MarginModel} margin - The margin for the chart.\n     * @param {Rect} rect - The rectangle associated with the data label.\n     * @param {boolean} top - Indicates whether the label is positioned at the top.\n     * @param {boolean} inside - Indicates whether the label is inside the chart area.\n     * @returns {number} The updated location of the data label.\n     */\n    DataLabel.prototype.updateLabelLocation = function (position, location, extraSpace, margin, rect, top, inside) {\n        if (inside === void 0) { inside = false; }\n        if (!this.inverted) {\n            if (top) {\n                location = (position === 'Outer' && !inside) ? location - extraSpace - margin.bottom - this.markerHeight :\n                    location + extraSpace + margin.top + this.markerHeight;\n            }\n            else {\n                location = (position === 'Outer' && !inside) ? location + rect.height + extraSpace + margin.top + this.markerHeight :\n                    location + rect.height - extraSpace - margin.bottom - this.markerHeight;\n            }\n        }\n        else {\n            if (top) {\n                location = (position === 'Outer' && !inside) ? location + extraSpace + margin.left + this.markerHeight :\n                    location - extraSpace - margin.right - this.markerHeight;\n            }\n            else {\n                location = (position === 'Outer' && !inside) ? location - rect.width - extraSpace - margin.right - this.markerHeight :\n                    location - rect.width + extraSpace + margin.left + this.markerHeight;\n            }\n        }\n        return location;\n    };\n    DataLabel.prototype.calculatePathActualPosition = function (y, markerSize, series, point, size, labelIndex) {\n        var points = series.points;\n        var index = point.index;\n        var yValue = points[index].yValue;\n        var position;\n        var nextPoint = points.length - 1 > index ? points[index + 1] : null;\n        var previousPoint = index > 0 ? points[index - 1] : null;\n        var yLocation;\n        var isOverLap = true;\n        var labelRect;\n        var isBottom;\n        var positionIndex;\n        var collection = this.chart.dataLabelCollections;\n        if (series.type === 'Bubble') {\n            position = 'Top';\n        }\n        else if (series.type.indexOf('Step') > -1) {\n            position = 'Top';\n            if (index) {\n                position = (!previousPoint || !previousPoint.visible || (yValue > previousPoint.yValue !== this.yAxisInversed)\n                    || yValue === previousPoint.yValue) ? 'Top' : 'Bottom';\n            }\n        }\n        else if (series.type === 'BoxAndWhisker') {\n            if (labelIndex === 1 || labelIndex === 3 || labelIndex > 4) {\n                position = series.yAxis.isAxisInverse ? 'Bottom' : 'Top';\n            }\n            else if (labelIndex === 2 || labelIndex === 4) {\n                position = series.yAxis.isAxisInverse ? 'Top' : 'Bottom';\n            }\n            else {\n                isOverLap = false;\n                position = 'Middle';\n                yLocation = this.calculatePathPosition(y, position, series, point, size, labelIndex);\n            }\n        }\n        else {\n            if (index === 0) {\n                position = (!nextPoint || !nextPoint.visible || yValue > nextPoint.yValue ||\n                    (yValue < nextPoint.yValue && this.yAxisInversed)) ? 'Top' : 'Bottom';\n            }\n            else if (index === points.length - 1) {\n                position = (!previousPoint || !previousPoint.visible || yValue > previousPoint.yValue ||\n                    (yValue < previousPoint.yValue && this.yAxisInversed)) ? 'Top' : 'Bottom';\n            }\n            else {\n                if (!nextPoint.visible && !(previousPoint && previousPoint.visible)) {\n                    position = 'Top';\n                }\n                else if (!nextPoint.visible || !previousPoint) {\n                    position = (nextPoint.yValue > yValue || (previousPoint && previousPoint.yValue > yValue)) ?\n                        'Bottom' : 'Top';\n                }\n                else {\n                    var slope = (nextPoint.yValue - previousPoint.yValue) / 2;\n                    var intersectY = (slope * index) + (nextPoint.yValue - (slope * (index + 1)));\n                    position = !this.yAxisInversed ? intersectY < yValue ? 'Top' : 'Bottom' :\n                        intersectY < yValue ? 'Bottom' : 'Top';\n                }\n            }\n        }\n        isBottom = position === 'Bottom';\n        positionIndex = ['Outer', 'Top', 'Bottom', 'Middle', 'Auto'].indexOf(position);\n        while (isOverLap && positionIndex < 4) {\n            yLocation = this.calculatePathPosition(y, this.getPosition(positionIndex), series, point, size, labelIndex);\n            labelRect = calculateRect(new ChartLocation(this.locationX, yLocation), size, this.margin);\n            isOverLap = labelRect.y < 0 || isCollide(labelRect, collection, series.clipRect)\n                || (labelRect.y + labelRect.height) > series.clipRect.height;\n            positionIndex = isBottom ? positionIndex - 1 : positionIndex + 1;\n            isBottom = false;\n        }\n        return yLocation;\n    };\n    /**\n     * Initiates the animation for data labels.\n     *\n     * @param {Series} series - The series associated with the data labels.\n     * @param {Element} [element] - The element to animate.\n     * @returns {void}\n     * @private\n     */\n    DataLabel.prototype.doDataLabelAnimation = function (series, element) {\n        var shapeElements = series.shapeElement.childNodes;\n        var textNode = series.textElement.childNodes;\n        var delay = series.animation.delay + series.animation.duration;\n        var duration = series.chart.animated ? series.chart.duration : 200;\n        var location;\n        var length = element ? 1 : textNode.length;\n        var tempElement;\n        for (var i = 0; i < length; i++) {\n            tempElement = textNode[i];\n            if (element) {\n                element.style.visibility = 'hidden';\n                templateAnimate(element, delay, duration, 'ZoomIn');\n            }\n            else {\n                location = new ChartLocation((+tempElement.getAttribute('x')) + ((+tempElement.getAttribute('width')) / 2), (+tempElement.getAttribute('y')) + ((+tempElement.getAttribute('height')) / 2));\n                markerAnimate(tempElement, delay, series.animation.duration, series, null, location, true);\n                if (shapeElements[i]) {\n                    tempElement = shapeElements[i];\n                    location = new ChartLocation((+tempElement.getAttribute('x')) + ((+tempElement.getAttribute('width')) / 2), (+tempElement.getAttribute('y')) + ((+tempElement.getAttribute('height')) / 2));\n                    markerAnimate(tempElement, delay, series.animation.duration, series, null, location, true);\n                }\n            }\n        }\n    };\n    DataLabel.prototype.getPosition = function (index) {\n        return (['Outer', 'Top', 'Bottom', 'Middle', 'Auto'][index]);\n    };\n    /**\n     * Get module name.\n     *\n     * @returns {string} - Returns the module name.\n     */\n    DataLabel.prototype.getModuleName = function () {\n        // Returns the module name\n        return 'DataLabel';\n    };\n    /**\n     * To destroy the dataLabel for series.\n     *\n     * @returns {void}\n     * @private\n     */\n    DataLabel.prototype.destroy = function () {\n        // Destroy method performed here\n    };\n    return DataLabel;\n}());\nexport { DataLabel };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}