{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport { getPoint, appendClipElement, pathAnimation, animateAddPoints } from '../../common/utils/helper';\nimport { LineBase } from './line-base';\nimport { RectOption, getElement } from '../../common/utils/helper';\nimport { DataUtil } from '@syncfusion/ej2-data';\n/**\n * Base class for multi-colored series.\n *\n * @private\n */\nvar MultiColoredSeries = /** @class */function (_super) {\n  __extends(MultiColoredSeries, _super);\n  function MultiColoredSeries() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * To generate the area path direction.\n   *\n   * @param {number} xValue xValue\n   * @param {number} yValue yValue\n   * @param {Series} series series\n   * @param {boolean} isInverted isInverted\n   * @param {Function} getPointLocation getPointLocation\n   * @param {ChartLocation} startPoint startPoint\n   * @param {string} startPath startPath\n   * @returns {string} Returns the area path direction.\n   * @private\n   */\n  MultiColoredSeries.prototype.getAreaPathDirection = function (xValue, yValue, series, isInverted, getPointLocation, startPoint, startPath) {\n    var direction = '';\n    var firstPoint;\n    if (startPoint === null) {\n      firstPoint = getPointLocation(xValue, yValue, series.xAxis, series.yAxis, isInverted, series);\n      direction += startPath + ' ' + firstPoint.x + ' ' + firstPoint.y + ' ';\n    }\n    return direction;\n  };\n  /**\n   * To generate the empty point direction.\n   *\n   * @param {ChartLocation} firstPoint firstPoint\n   * @param {ChartLocation} secondPoint secondPoint\n   * @param {Series} series series\n   * @param {boolean} isInverted isInverted\n   * @param {Function} getPointLocation getPointLocation\n   * @returns {string} Returns the empty point direction.\n   * @private\n   */\n  MultiColoredSeries.prototype.getAreaEmptyDirection = function (firstPoint, secondPoint, series, isInverted, getPointLocation) {\n    var direction = '';\n    direction += this.getAreaPathDirection(firstPoint.x, firstPoint.y, series, isInverted, getPointLocation, null, 'L');\n    direction += this.getAreaPathDirection(secondPoint.x, secondPoint.y, series, isInverted, getPointLocation, null, 'L');\n    return direction;\n  };\n  /**\n   * Set the color for a point based on its current state and previous state.\n   *\n   * @param {Points} currentPoint - The current point whose color needs to be set.\n   * @param {Points} previous - The previous state of the point.\n   * @param {Series} series - The series associated with the point.\n   * @param {boolean} isXSegment - Indicates whether the point is in the x-segment.\n   * @param {ChartSegmentModel[]} segments - The segments associated with the point.\n   * @returns {boolean} - Returns true if the color is set successfully, false otherwise.\n   * @private\n   */\n  MultiColoredSeries.prototype.setPointColor = function (currentPoint, previous, series, isXSegment, segments) {\n    if (series.pointColorMapping === '') {\n      var segment = void 0;\n      var value = void 0;\n      for (var i = 0; i < segments.length; i++) {\n        segment = segments[i];\n        value = isXSegment ? currentPoint.xValue : currentPoint.yValue;\n        if (value <= this.getAxisValue(segment.value, isXSegment ? series.xAxis : series.yAxis, series.chart) || !segment.value && segment.value !== 0) {\n          currentPoint.interior = segment.color;\n          break;\n        }\n      }\n      if (currentPoint.interior == null) {\n        currentPoint.interior = series.interior;\n      }\n      return false;\n    } else {\n      if (previous) {\n        return series.setPointColor(currentPoint, series.interior) !== series.setPointColor(previous, series.interior);\n      } else {\n        return false;\n      }\n    }\n  };\n  MultiColoredSeries.prototype.sortSegments = function (series, chartSegments) {\n    var _this = this;\n    var axis = series.segmentAxis === 'X' ? series.xAxis : series.yAxis;\n    var segments = [].concat(chartSegments);\n    return segments.sort(function (a, b) {\n      return _this.getAxisValue(a.value, axis, series.chart) - _this.getAxisValue(b.value, axis, series.chart);\n    });\n  };\n  /**\n   * Segment calculation performed here.\n   *\n   * @param {Series} series series\n   * @param {PathOption[]} options options\n   * @param {ChartSegmentModel[]} segments chartSegments\n   * @param {boolean} pointAnimate pointAnimate\n   * @returns {void}\n   * @private\n   */\n  MultiColoredSeries.prototype.applySegmentAxis = function (series, options, segments, pointAnimate) {\n    var _this = this;\n    if (series.pointColorMapping !== '') {\n      options.map(function (option) {\n        _this[pointAnimate ? 'addMulticolorPath' : 'appendLinePath'](option, series, '');\n      });\n      return null;\n    }\n    var isXSegment = series.segmentAxis === 'X';\n    var axis = isXSegment ? series.xAxis : series.yAxis;\n    var chart = series.chart;\n    var segment;\n    this.includeSegment(segments, axis, series, segments.length);\n    var length = segments.length;\n    var value;\n    var clipPath;\n    var attributeOptions;\n    var areaBorderCount = 0;\n    var _loop_1 = function (index) {\n      segment = segments[index];\n      value = this_1.getAxisValue(segment.value, axis, series.chart);\n      clipPath = this_1.createClipRect(index ? this_1.getAxisValue(segments[index - 1].value, axis, series.chart) : axis.visibleRange.min, value, series, index, isXSegment);\n      if (clipPath) {\n        options.map(function (option) {\n          areaBorderCount += 1;\n          attributeOptions = {\n            'clip-path': clipPath,\n            'stroke-dasharray': segment.dashArray,\n            'opacity': option.opacity,\n            'stroke': series.type.indexOf('Line') > -1 ? segment.color || series.interior : option['stroke'],\n            'stroke-width': option['stroke-width'],\n            'fill': series.type.indexOf('Line') > -1 ? 'none' : segment.color || series.interior,\n            'id': option.id + '_Segment_' + index,\n            'd': option.d\n          };\n          if (areaBorderCount % 2 === 0 && _this.chart.multiColoredAreaSeriesModule && series.border.color !== 'transparent' && attributeOptions['stroke-width'] !== 0) {\n            attributeOptions.fill = 'transparent';\n          }\n          if (pointAnimate) {\n            _this.addMulticolorPath(attributeOptions, series, '', true);\n          } else {\n            pathAnimation(getElement(attributeOptions.id), attributeOptions.d, chart.redraw);\n          }\n          series.pathElement = chart.renderer.drawPath(attributeOptions);\n          if (!series.chart.enableCanvas && !pointAnimate) {\n            series.seriesElement.appendChild(chart.renderer.drawPath(attributeOptions));\n          }\n        });\n      }\n    };\n    var this_1 = this;\n    for (var index = 0; index < length; index++) {\n      _loop_1(index);\n    }\n  };\n  MultiColoredSeries.prototype.includeSegment = function (segments, axis, series, length) {\n    if (length <= 0) {\n      segments.push({\n        value: axis.visibleRange.max,\n        color: series.interior\n      });\n      return null;\n    }\n    if (this.getAxisValue(segments[length - 1].value, axis, series.chart) < axis.visibleRange.max) {\n      segments.push({\n        value: axis.visibleRange.max,\n        color: series.interior\n      });\n    }\n  };\n  MultiColoredSeries.prototype.addMulticolorPath = function (options, series, clipRect, isSegnment) {\n    var points = this.appendPathElement(options, series, clipRect);\n    if (points.previousDirection === null || points.previousDirection === '') {\n      points.previousDirection = 'M ' + options.d.split(' ').slice(-3)[0] + ' ' + options.d.split(' ').slice(-5)[0] + ' L ' + options.d.split(' ').slice(-3)[0] + ' ' + options.d.split(' ').slice(-5)[0] + ' L ' + options.d.split(' ').slice(-3)[0] + ' ' + options.d.split(' ').slice(-5)[0];\n    }\n    if (options.d === null || options.d === '') {\n      options.d = 'M ' + points.previousDirection.split(' ').slice(-3)[0] + ' ' + points.previousDirection.split(' ').slice(-5)[0] + ' L ' + points.previousDirection.split(' ').slice(-3)[0] + ' ' + points.previousDirection.split(' ').slice(-5)[0];\n    }\n    if (isSegnment) {\n      var startPathCommands = points.previousDirection.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);\n      var endPathCommands = options.d.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);\n      var maxLength = Math.max(startPathCommands.length, endPathCommands.length);\n      var minLength = Math.min(startPathCommands.length, endPathCommands.length);\n      if (startPathCommands.length === endPathCommands.length) {\n        animateAddPoints(getElement(options.id), options.d, series.chart.redraw, points.previousDirection, this.chart.duration);\n      }\n      if (startPathCommands.length < endPathCommands.length) {\n        for (var i = minLength; i < maxLength; i++) {\n          if (endPathCommands.length !== startPathCommands.length) {\n            startPathCommands.splice(startPathCommands.length - (series.type.indexOf('Line') !== -1 ? 1 : 2), 0, startPathCommands[startPathCommands.length - (series.type.indexOf('Line') !== -1 ? 1 : 2)]);\n          }\n        }\n        animateAddPoints(getElement(options.id), options.d, series.chart.redraw, startPathCommands.join(' '), this.chart.duration);\n      }\n      if (startPathCommands.length > endPathCommands.length) {\n        for (var i = minLength; i < maxLength; i++) {\n          if (endPathCommands.length !== startPathCommands.length) {\n            endPathCommands.splice(1, 0, endPathCommands[1].replace('M', 'L'));\n          }\n        }\n        animateAddPoints(points.element, endPathCommands.join(''), series.chart.redraw, startPathCommands.join(''), this.chart.duration, options.d);\n      }\n    }\n  };\n  /**\n   * To create clip rect for segment axis.\n   *\n   * @param {number} startValue startValue\n   * @param {number} endValue endValue\n   * @param {Series} series series\n   * @param {number} index index\n   * @param {boolean} isX isX\n   * @returns {string} clip rect for segment axis\n   * @private\n   */\n  MultiColoredSeries.prototype.createClipRect = function (startValue, endValue, series, index, isX) {\n    var isRequired = series.chart.requireInvertedAxis;\n    var startPointLocation = getPoint(isX ? startValue : series.xAxis.visibleRange.min, isX ? series.yAxis.visibleRange.max : endValue, series.xAxis, series.yAxis, isRequired);\n    var endPointLocation = getPoint(isX ? endValue : series.xAxis.visibleRange.max, isX ? series.yAxis.visibleRange.min : startValue, series.xAxis, series.yAxis, isRequired);\n    endPointLocation = isRequired ? [startPointLocation, startPointLocation = endPointLocation][0] : endPointLocation;\n    var options;\n    if ((series.xAxis.isInversed || series.xAxis.isAxisInverse ? startPointLocation.x - endPointLocation.x > 0 : endPointLocation.x - startPointLocation.x > 0) && (series.yAxis.isInversed ? startPointLocation.y - endPointLocation.y > 0 : endPointLocation.y - startPointLocation.y > 0)) {\n      options = new RectOption(series.chart.element.id + '_ChartSegment' + series.index + 'ClipRect_' + index, 'transparent', {\n        width: 1,\n        color: 'Gray'\n      }, 1, {\n        x: series.xAxis.isInversed || series.xAxis.isAxisInverse ? endPointLocation.x : startPointLocation.x,\n        y: series.yAxis.isInversed ? endPointLocation.y : startPointLocation.y,\n        width: series.xAxis.isInversed || series.xAxis.isAxisInverse ? startPointLocation.x - endPointLocation.x : endPointLocation.x - startPointLocation.x,\n        height: series.yAxis.isInversed ? startPointLocation.y - endPointLocation.y : endPointLocation.y - startPointLocation.y\n      });\n      if (!series.chart.enableCanvas) {\n        series.seriesElement.appendChild(appendClipElement(series.chart.redraw, options, series.chart.renderer));\n      }\n      return 'url(#' + series.chart.element.id + '_ChartSegment' + series.index + 'ClipRect_' + index + ')';\n    }\n    return null;\n  };\n  /**\n   * To get exact value from segment value.\n   *\n   * @param {Object} segmentValue segmentValue\n   * @param {Axis} axis axis\n   * @param {Chart} chart chart\n   * @returns {number} - Returns segment value.\n   * @private\n   */\n  MultiColoredSeries.prototype.getAxisValue = function (segmentValue, axis, chart) {\n    if (segmentValue === null) {\n      segmentValue = axis.visibleRange.max;\n    }\n    if (axis.valueType === 'DateTime') {\n      var option = {\n        skeleton: 'full',\n        type: 'dateTime'\n      };\n      return Date.parse(chart.intl.getDateParser(option)(chart.intl.getDateFormat(option)(new Date(DataUtil.parse.parseJson({\n        val: segmentValue\n      }).val))));\n    } else if (axis.valueType.indexOf('Category') > -1) {\n      var xValue = axis.valueType === 'DateTimeCategory' ? segmentValue.getTime().toString() : segmentValue;\n      return axis.labels.indexOf(xValue) < 0 ? +segmentValue : axis.labels.indexOf(xValue);\n    } else {\n      return +segmentValue;\n    }\n  };\n  return MultiColoredSeries;\n}(LineBase);\nexport { MultiColoredSeries };","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","getPoint","appendClipElement","pathAnimation","animateAddPoints","LineBase","RectOption","getElement","DataUtil","MultiColoredSeries","_super","apply","arguments","getAreaPathDirection","xValue","yValue","series","isInverted","getPointLocation","startPoint","startPath","direction","firstPoint","xAxis","yAxis","x","y","getAreaEmptyDirection","secondPoint","setPointColor","currentPoint","previous","isXSegment","segments","pointColorMapping","segment","value","i","length","getAxisValue","chart","interior","color","sortSegments","chartSegments","_this","axis","segmentAxis","concat","sort","a","applySegmentAxis","options","pointAnimate","map","option","includeSegment","clipPath","attributeOptions","areaBorderCount","_loop_1","index","this_1","createClipRect","visibleRange","min","dashArray","opacity","type","indexOf","id","multiColoredAreaSeriesModule","border","fill","addMulticolorPath","redraw","pathElement","renderer","drawPath","enableCanvas","seriesElement","appendChild","push","max","clipRect","isSegnment","points","appendPathElement","previousDirection","split","slice","startPathCommands","match","endPathCommands","maxLength","Math","minLength","duration","splice","join","replace","element","startValue","endValue","isX","isRequired","requireInvertedAxis","startPointLocation","endPointLocation","isInversed","isAxisInverse","width","height","segmentValue","valueType","skeleton","Date","parse","intl","getDateParser","getDateFormat","parseJson","val","getTime","toString","labels"],"sources":["C:/Users/mkfun/Desktop/ct assignment/admin/node_modules/@syncfusion/ej2-charts/src/chart/series/multi-colored-base.js"],"sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { getPoint, appendClipElement, pathAnimation, animateAddPoints } from '../../common/utils/helper';\nimport { LineBase } from './line-base';\nimport { RectOption, getElement } from '../../common/utils/helper';\nimport { DataUtil } from '@syncfusion/ej2-data';\n/**\n * Base class for multi-colored series.\n *\n * @private\n */\nvar MultiColoredSeries = /** @class */ (function (_super) {\n    __extends(MultiColoredSeries, _super);\n    function MultiColoredSeries() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * To generate the area path direction.\n     *\n     * @param {number} xValue xValue\n     * @param {number} yValue yValue\n     * @param {Series} series series\n     * @param {boolean} isInverted isInverted\n     * @param {Function} getPointLocation getPointLocation\n     * @param {ChartLocation} startPoint startPoint\n     * @param {string} startPath startPath\n     * @returns {string} Returns the area path direction.\n     * @private\n     */\n    MultiColoredSeries.prototype.getAreaPathDirection = function (xValue, yValue, series, isInverted, getPointLocation, startPoint, startPath) {\n        var direction = '';\n        var firstPoint;\n        if (startPoint === null) {\n            firstPoint = getPointLocation(xValue, yValue, series.xAxis, series.yAxis, isInverted, series);\n            direction += (startPath + ' ' + (firstPoint.x) + ' ' + (firstPoint.y) + ' ');\n        }\n        return direction;\n    };\n    /**\n     * To generate the empty point direction.\n     *\n     * @param {ChartLocation} firstPoint firstPoint\n     * @param {ChartLocation} secondPoint secondPoint\n     * @param {Series} series series\n     * @param {boolean} isInverted isInverted\n     * @param {Function} getPointLocation getPointLocation\n     * @returns {string} Returns the empty point direction.\n     * @private\n     */\n    MultiColoredSeries.prototype.getAreaEmptyDirection = function (firstPoint, secondPoint, series, isInverted, getPointLocation) {\n        var direction = '';\n        direction += this.getAreaPathDirection(firstPoint.x, firstPoint.y, series, isInverted, getPointLocation, null, 'L');\n        direction += this.getAreaPathDirection(secondPoint.x, secondPoint.y, series, isInverted, getPointLocation, null, 'L');\n        return direction;\n    };\n    /**\n     * Set the color for a point based on its current state and previous state.\n     *\n     * @param {Points} currentPoint - The current point whose color needs to be set.\n     * @param {Points} previous - The previous state of the point.\n     * @param {Series} series - The series associated with the point.\n     * @param {boolean} isXSegment - Indicates whether the point is in the x-segment.\n     * @param {ChartSegmentModel[]} segments - The segments associated with the point.\n     * @returns {boolean} - Returns true if the color is set successfully, false otherwise.\n     * @private\n     */\n    MultiColoredSeries.prototype.setPointColor = function (currentPoint, previous, series, isXSegment, segments) {\n        if (series.pointColorMapping === '') {\n            var segment = void 0;\n            var value = void 0;\n            for (var i = 0; i < segments.length; i++) {\n                segment = segments[i];\n                value = isXSegment ? currentPoint.xValue : currentPoint.yValue;\n                if (value <= this.getAxisValue(segment.value, isXSegment ? series.xAxis : series.yAxis, series.chart) ||\n                    (!segment.value && segment.value !== 0)) {\n                    currentPoint.interior = segment.color;\n                    break;\n                }\n            }\n            if (currentPoint.interior == null) {\n                currentPoint.interior = series.interior;\n            }\n            return false;\n        }\n        else {\n            if (previous) {\n                return series.setPointColor(currentPoint, series.interior) !== series.setPointColor(previous, series.interior);\n            }\n            else {\n                return false;\n            }\n        }\n    };\n    MultiColoredSeries.prototype.sortSegments = function (series, chartSegments) {\n        var _this = this;\n        var axis = series.segmentAxis === 'X' ? series.xAxis : series.yAxis;\n        var segments = [].concat(chartSegments);\n        return segments.sort(function (a, b) {\n            return _this.getAxisValue(a.value, axis, series.chart) - _this.getAxisValue(b.value, axis, series.chart);\n        });\n    };\n    /**\n     * Segment calculation performed here.\n     *\n     * @param {Series} series series\n     * @param {PathOption[]} options options\n     * @param {ChartSegmentModel[]} segments chartSegments\n     * @param {boolean} pointAnimate pointAnimate\n     * @returns {void}\n     * @private\n     */\n    MultiColoredSeries.prototype.applySegmentAxis = function (series, options, segments, pointAnimate) {\n        var _this = this;\n        if (series.pointColorMapping !== '') {\n            options.map(function (option) {\n                _this[pointAnimate ? 'addMulticolorPath' : 'appendLinePath'](option, series, '');\n            });\n            return null;\n        }\n        var isXSegment = series.segmentAxis === 'X';\n        var axis = isXSegment ? series.xAxis : series.yAxis;\n        var chart = series.chart;\n        var segment;\n        this.includeSegment(segments, axis, series, segments.length);\n        var length = segments.length;\n        var value;\n        var clipPath;\n        var attributeOptions;\n        var areaBorderCount = 0;\n        var _loop_1 = function (index) {\n            segment = segments[index];\n            value = this_1.getAxisValue(segment.value, axis, series.chart);\n            clipPath = this_1.createClipRect(index ? this_1.getAxisValue(segments[index - 1].value, axis, series.chart)\n                : axis.visibleRange.min, value, series, index, isXSegment);\n            if (clipPath) {\n                options.map(function (option) {\n                    areaBorderCount += 1;\n                    attributeOptions = {\n                        'clip-path': clipPath,\n                        'stroke-dasharray': segment.dashArray,\n                        'opacity': option.opacity,\n                        'stroke': series.type.indexOf('Line') > -1 ? segment.color || series.interior : option['stroke'],\n                        'stroke-width': option['stroke-width'],\n                        'fill': series.type.indexOf('Line') > -1 ? 'none' : segment.color || series.interior,\n                        'id': option.id + '_Segment_' + index,\n                        'd': option.d\n                    };\n                    if (areaBorderCount % 2 === 0 && _this.chart.multiColoredAreaSeriesModule && series.border.color !== 'transparent' && attributeOptions['stroke-width'] !== 0) {\n                        attributeOptions.fill = 'transparent';\n                    }\n                    if (pointAnimate) {\n                        _this.addMulticolorPath(attributeOptions, series, '', true);\n                    }\n                    else {\n                        pathAnimation(getElement(attributeOptions.id), attributeOptions.d, chart.redraw);\n                    }\n                    series.pathElement = chart.renderer.drawPath(attributeOptions);\n                    if (!series.chart.enableCanvas && !pointAnimate) {\n                        series.seriesElement.appendChild(chart.renderer.drawPath(attributeOptions));\n                    }\n                });\n            }\n        };\n        var this_1 = this;\n        for (var index = 0; index < length; index++) {\n            _loop_1(index);\n        }\n    };\n    MultiColoredSeries.prototype.includeSegment = function (segments, axis, series, length) {\n        if (length <= 0) {\n            segments.push({ value: axis.visibleRange.max, color: series.interior });\n            return null;\n        }\n        if (this.getAxisValue(segments[length - 1].value, axis, series.chart) < axis.visibleRange.max) {\n            segments.push({ value: axis.visibleRange.max, color: series.interior });\n        }\n    };\n    MultiColoredSeries.prototype.addMulticolorPath = function (options, series, clipRect, isSegnment) {\n        var points = this.appendPathElement(options, series, clipRect);\n        if (points.previousDirection === null || points.previousDirection === '') {\n            points.previousDirection = 'M ' + (options.d).split(' ').slice(-3)[0] + ' ' + (options.d).split(' ').slice(-5)[0] + ' L ' + (options.d).split(' ').slice(-3)[0] + ' ' + (options.d).split(' ').slice(-5)[0] + ' L ' + (options.d).split(' ').slice(-3)[0] + ' ' + (options.d).split(' ').slice(-5)[0];\n        }\n        if (options.d === null || options.d === '') {\n            options.d = 'M ' + (points.previousDirection).split(' ').slice(-3)[0] + ' ' + (points.previousDirection).split(' ').slice(-5)[0] + ' L ' + (points.previousDirection).split(' ').slice(-3)[0] + ' ' + (points.previousDirection).split(' ').slice(-5)[0];\n        }\n        if (isSegnment) {\n            var startPathCommands = points.previousDirection.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);\n            var endPathCommands = (options.d).match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);\n            var maxLength = Math.max(startPathCommands.length, endPathCommands.length);\n            var minLength = Math.min(startPathCommands.length, endPathCommands.length);\n            if (startPathCommands.length === endPathCommands.length) {\n                animateAddPoints(getElement(options.id), options.d, series.chart.redraw, points.previousDirection, this.chart.duration);\n            }\n            if (startPathCommands.length < endPathCommands.length) {\n                for (var i = minLength; i < maxLength; i++) {\n                    if (endPathCommands.length !== startPathCommands.length) {\n                        startPathCommands.splice(startPathCommands.length - ((series.type.indexOf('Line') !== -1) ? 1 : 2), 0, startPathCommands[startPathCommands.length - ((series.type.indexOf('Line') !== -1) ? 1 : 2)]);\n                    }\n                }\n                animateAddPoints(getElement(options.id), options.d, series.chart.redraw, startPathCommands.join(' '), this.chart.duration);\n            }\n            if (startPathCommands.length > endPathCommands.length) {\n                for (var i = minLength; i < maxLength; i++) {\n                    if (endPathCommands.length !== startPathCommands.length) {\n                        endPathCommands.splice(1, 0, endPathCommands[1].replace('M', 'L'));\n                    }\n                }\n                animateAddPoints(points.element, endPathCommands.join(''), series.chart.redraw, startPathCommands.join(''), this.chart.duration, options.d);\n            }\n        }\n    };\n    /**\n     * To create clip rect for segment axis.\n     *\n     * @param {number} startValue startValue\n     * @param {number} endValue endValue\n     * @param {Series} series series\n     * @param {number} index index\n     * @param {boolean} isX isX\n     * @returns {string} clip rect for segment axis\n     * @private\n     */\n    MultiColoredSeries.prototype.createClipRect = function (startValue, endValue, series, index, isX) {\n        var isRequired = series.chart.requireInvertedAxis;\n        var startPointLocation = getPoint(isX ? startValue : series.xAxis.visibleRange.min, isX ? series.yAxis.visibleRange.max : endValue, series.xAxis, series.yAxis, isRequired);\n        var endPointLocation = getPoint(isX ? endValue : series.xAxis.visibleRange.max, isX ? series.yAxis.visibleRange.min : startValue, series.xAxis, series.yAxis, isRequired);\n        endPointLocation = isRequired ?\n            [startPointLocation, startPointLocation = endPointLocation][0] : endPointLocation;\n        var options;\n        if (((series.xAxis.isInversed || series.xAxis.isAxisInverse) ?\n            startPointLocation.x - endPointLocation.x > 0 : endPointLocation.x - startPointLocation.x > 0) &&\n            (series.yAxis.isInversed ? startPointLocation.y - endPointLocation.y > 0 : endPointLocation.y - startPointLocation.y > 0)) {\n            options = new RectOption(series.chart.element.id + '_ChartSegment' + series.index + 'ClipRect_' + index, 'transparent', { width: 1, color: 'Gray' }, 1, {\n                x: (series.xAxis.isInversed || series.xAxis.isAxisInverse) ? endPointLocation.x : startPointLocation.x,\n                y: series.yAxis.isInversed ? endPointLocation.y : startPointLocation.y,\n                width: (series.xAxis.isInversed || series.xAxis.isAxisInverse) ? startPointLocation.x - endPointLocation.x :\n                    endPointLocation.x - startPointLocation.x,\n                height: series.yAxis.isInversed ? startPointLocation.y - endPointLocation.y : endPointLocation.y - startPointLocation.y\n            });\n            if (!series.chart.enableCanvas) {\n                series.seriesElement.appendChild(appendClipElement(series.chart.redraw, options, series.chart.renderer));\n            }\n            return 'url(#' + series.chart.element.id + '_ChartSegment' + series.index + 'ClipRect_' + index + ')';\n        }\n        return null;\n    };\n    /**\n     * To get exact value from segment value.\n     *\n     * @param {Object} segmentValue segmentValue\n     * @param {Axis} axis axis\n     * @param {Chart} chart chart\n     * @returns {number} - Returns segment value.\n     * @private\n     */\n    MultiColoredSeries.prototype.getAxisValue = function (segmentValue, axis, chart) {\n        if (segmentValue === null) {\n            segmentValue = axis.visibleRange.max;\n        }\n        if (axis.valueType === 'DateTime') {\n            var option = { skeleton: 'full', type: 'dateTime' };\n            return Date.parse(chart.intl.getDateParser(option)(chart.intl.getDateFormat(option)(new Date(DataUtil.parse.parseJson({ val: segmentValue }).val))));\n        }\n        else if (axis.valueType.indexOf('Category') > -1) {\n            var xValue = axis.valueType === 'DateTimeCategory' ?\n                (segmentValue.getTime()).toString() :\n                segmentValue;\n            return (axis.labels.indexOf(xValue) < 0) ? +segmentValue : axis.labels.indexOf(xValue);\n        }\n        else {\n            return +segmentValue;\n        }\n    };\n    return MultiColoredSeries;\n}(LineBase));\nexport { MultiColoredSeries };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}