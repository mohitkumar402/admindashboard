{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nimport { measureText } from '@syncfusion/ej2-svg-base';\nimport { appendChildElement, colorNameToHex } from '../../common/utils/helper';\nimport { isNullOrUndefined } from '@syncfusion/ej2-base';\n/**\n * Represents a 3D rendering configuration for the EJ3D rendering engine.\n *\n */\nvar Chart3DRender = /** @class */function () {\n  function Chart3DRender() {\n    this.transform = null; // Chart3DBasicTransform\n  }\n  return Chart3DRender;\n}();\nexport { Chart3DRender };\nvar chart3DRender = new Chart3DRender();\n/**\n * Represents a three-dimensional vector in space.\n */\nvar Vector3D = /** @class */function () {\n  /**\n   * Constructs a new Vector3D instance.\n   *\n   * @constructor\n   * @param {number | { x: number, y: number }} pointX - Either an object with x and y properties or the x-coordinate.\n   * @param {number} [vy] - The y-coordinate (if the first parameter is a number).\n   * @param {number} [vz] - The z-coordinate (if the first parameter is a number).\n   */\n  function Vector3D(pointX, vy, vz) {\n    /** The x-coordinate of the vector. */\n    this.x = 0;\n    /** The y-coordinate of the vector. */\n    this.y = 0;\n    /** The z-coordinate of the vector. */\n    this.z = 0;\n    /** A small value used for epsilon comparisons to handle floating-point inaccuracies.*/\n    this.epsilon = 0.00001;\n    this.x = pointX;\n    this.y = vy || 0;\n    this.z = vz || 0;\n  }\n  /**\n   * Checks if a vector is valid (not NaN for any component).\n   *\n   * @param {Chart3DVector} point - The vector to check.\n   * @returns {boolean} - True if the vector is valid, false otherwise.\n   */\n  Vector3D.prototype.isValid = function (point) {\n    return !isNaN(point.x) && !isNaN(point.y) && !isNaN(point.z);\n  };\n  /**\n   * Creates a new Vector3D instance from provided coordinates.\n   *\n   * @param {number | { x: number, y: number }} vx - Either an object with x and y properties or the x-coordinate.\n   * @param {number} vy - The y-coordinate.\n   * @param {number} vz - The z-coordinate.\n   * @returns {Chart3DVector} - The new Vector3D instance.\n   */\n  Vector3D.prototype.vector3D = function (vx, vy, vz) {\n    this.x = vx;\n    this.y = vy;\n    this.z = vz;\n    return {\n      x: this.x,\n      y: this.y,\n      z: this.z\n    };\n  };\n  /**\n   * Subtracts one vector from another and returns the result.\n   *\n   * @param {Chart3DVector} v1 - The first vector.\n   * @param {Chart3DVector} v2 - The second vector to subtract from the first.\n   * @returns {Chart3DVector} - The resulting vector.\n   */\n  Vector3D.prototype.vector3DMinus = function (v1, v2) {\n    return this.vector3D(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);\n  };\n  /**\n   * Adds two vectors and returns the result.\n   *\n   * @param {Chart3DVector} v1 - The first vector.\n   * @param {Chart3DVector} v2 - The second vector to add to the first.\n   * @returns {Chart3DVector} - The resulting vector.\n   */\n  Vector3D.prototype.vector3DPlus = function (v1, v2) {\n    return this.vector3D(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z);\n  };\n  /**\n   * Multiplies two vectors using the cross product and returns the result.\n   *\n   * @param {Chart3DVector} v1 - The first vector.\n   * @param {Chart3DVector} v2 - The second vector.\n   * @returns {Chart3DVector} - The resulting vector.\n   */\n  Vector3D.prototype.vector3DMultiply = function (v1, v2) {\n    var x = v1.y * v2.z - v2.y * v1.z;\n    var y = v1.z * v2.x - v2.z * v1.x;\n    var z = v1.x * v2.y - v2.x * v1.y;\n    return this.vector3D(x, y, z);\n  };\n  /**\n   * Calculates the dot product of two vectors.\n   *\n   * @param {Chart3DVector} v1 - The first vector.\n   * @param {Chart3DVector} v2 - The second vector.\n   * @returns {number} - The dot product.\n   */\n  Vector3D.prototype.vector3DAdd = function (v1, v2) {\n    return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;\n  };\n  /**\n   * Multiplies a vector by a scalar value.\n   *\n   * @param {Chart3DVector} v1 - The vector to multiply.\n   * @param {number} value - The scalar value.\n   * @returns {Chart3DVector} - The resulting vector.\n   */\n  Vector3D.prototype.vector3DStarMultiply = function (v1, value) {\n    var x = v1.x * value;\n    var y = v1.y * value;\n    var z = v1.z * value;\n    return this.vector3D(x, y, z);\n  };\n  /**\n   * Calculates the length of a vector.\n   *\n   * @param {Chart3DVector} vector - The vector to calculate the length of.\n   * @returns {number} - The length of the vector.\n   */\n  Vector3D.prototype.getLength = function (vector) {\n    var sqt = this.vector3DAdd(vector, vector);\n    return Math.sqrt(sqt);\n  };\n  /**\n   * Normalizes the vector to have a length of 1.\n   *\n   * @returns {void}\n   */\n  Vector3D.prototype.normalize = function () {\n    var length = this.getLength(this);\n    this.x /= length;\n    this.y /= length;\n    this.z /= length;\n  };\n  /**\n   * Calculates the normal vector of a triangle defined by three vectors.\n   *\n   * @param {Chart3DVector} v1 - The first vertex of the triangle.\n   * @param {Chart3DVector} v2 - The second vertex of the triangle.\n   * @param {Chart3DVector} v3 - The third vertex of the triangle.\n   * @returns {Chart3DVector} - The normal vector of the triangle.\n   */\n  Vector3D.prototype.getNormal = function (v1, v2, v3) {\n    var vector4 = this.vector3DMinus(v1, v2);\n    var vector5 = this.vector3DMinus(v3, v2);\n    var n = this.vector3DMultiply(vector4, vector5);\n    var length = this.getLength(n);\n    if (length < this.epsilon) {\n      return this.vector3D(0, 0, 0);\n    }\n    return this.vector3D(n.x / length, n.y / length, n.z / length);\n  };\n  return Vector3D;\n}();\nexport { Vector3D };\n/**\n * Represents a 3x3 or 4x4 matrix in 3D space and provides various matrix operations.\n *\n */\nvar Matrix3D = /** @class */function () {\n  function Matrix3D() {\n    /** The size of the matrix, which is set to 4 by default. */\n    this.matrixSize = 4;\n  }\n  /**\n   * Creates a 3D matrix with the specified size.\n   *\n   * @param {number} size - The size of the matrix.\n   * @returns {number[][]} - The created 3D matrix.\n   */\n  Matrix3D.prototype.matrix3D = function (size) {\n    var matrixData = [];\n    for (var i = 0; i < size; i++) {\n      matrixData[i] = this.createArray(size);\n    }\n    return matrixData;\n  };\n  /**\n   * Checks if a matrix is an affine matrix.\n   *\n   * @param {number[][]} matrixData - The matrix to check.\n   * @returns {boolean} - True if the matrix is an affine matrix, false otherwise.\n   */\n  Matrix3D.prototype.isAffine = function (matrixData) {\n    return matrixData[0][3] === 0 && matrixData[1][3] === 0 && matrixData[2][3] === 0 && matrixData[3][3] === 1;\n  };\n  /**\n   * Creates a new array with zeros.\n   *\n   * @param {number} initialSize - The size of the array.\n   * @returns {number[]} - The created array.\n   */\n  Matrix3D.prototype.createArray = function (initialSize) {\n    var matrixData = [];\n    for (var index = 0; index < initialSize; ++index) {\n      matrixData[index] = 0;\n    }\n    return matrixData;\n  };\n  /**\n   * Gets the identity matrix.\n   *\n   * @returns {number[][]} -The identity matrix.\n   */\n  Matrix3D.prototype.getIdentity = function () {\n    var matrixData = this.matrix3D(this.matrixSize);\n    for (var i = 0; i < this.matrixSize; i++) {\n      matrixData[i][i] = 1.0;\n    }\n    return matrixData;\n  };\n  /**\n   * Gets the interval of a matrix.\n   *\n   * @param {number[][]} matrix - The matrix to get the interval for.\n   * @returns {number[][]} - The interval matrix.\n   */\n  Matrix3D.prototype.getInterval = function (matrix) {\n    var matrixData = this.getIdentity();\n    for (var i = 0; i < this.matrixSize; i++) {\n      for (var j = 0; j < this.matrixSize; j++) {\n        matrixData[i][j] = this.getMinor(matrix, i, j);\n      }\n    }\n    matrixData = this.transposed(matrixData);\n    matrixData = this.getMatrixMultiple(1 / this.getDeterminant(matrix), matrixData);\n    return matrixData;\n  };\n  /**\n   * Multiplies all elements of a matrix by a factor.\n   *\n   * @param {number} factor - The factor to multiply with.\n   * @param {number[][]} matrix - The matrix to multiply.\n   * @returns {number[][]} - The resulting matrix.\n   */\n  Matrix3D.prototype.getMatrixMultiple = function (factor, matrix) {\n    for (var i = 0; i < matrix.length; i++) {\n      for (var j = 0; j < matrix[i].length; j++) {\n        matrix[i][j] = matrix[i][j] * factor;\n      }\n    }\n    return matrix;\n  };\n  /**\n   * Multiplies a matrix by a vector.\n   *\n   * @param {number[][]} matrix - The matrix.\n   * @param {Chart3DVector} point - The vector to multiply with.\n   * @returns {Chart3DVector} - The resulting vector.\n   */\n  Matrix3D.prototype.getMatrixVectorMultiple = function (matrix, point) {\n    var x = matrix[0][0] * point.x + matrix[1][0] * point.y + matrix[2][0] * point.z + matrix[3][0];\n    var y = matrix[0][1] * point.x + matrix[1][1] * point.y + matrix[2][1] * point.z + matrix[3][1];\n    var z = matrix[0][2] * point.x + matrix[1][2] * point.y + matrix[2][2] * point.z + matrix[3][2];\n    if (!this.isAffine(matrix)) {\n      var c = 1 / (matrix[0][3] * point.x + matrix[1][3] * point.y + matrix[2][3] * point.z + matrix[3][3]);\n      x *= c;\n      y *= c;\n      z *= c;\n    }\n    return {\n      x: x,\n      y: y,\n      z: z\n    };\n  };\n  /**\n   * Multiplies a matrix by a vector and applies translation.\n   *\n   * @param {number[][]} matrix - The matrix.\n   * @param {Chart3DVector} vector - The vector to multiply with.\n   * @returns {Vector3D} - The resulting vector.\n   */\n  Matrix3D.prototype.getMatrixVectorAnd = function (matrix, vector) {\n    var x = matrix[0][0] * vector.x + matrix[1][0] * vector.y + matrix[2][0] * vector.z;\n    var y = matrix[0][1] * vector.x + matrix[1][1] * vector.y + matrix[2][1] * vector.z;\n    var z = matrix[0][2] * vector.x + matrix[1][2] * vector.y + matrix[2][2] * vector.z;\n    return new Vector3D(x, y, z);\n  };\n  /**\n   * Multiplies two matrices.\n   *\n   * @param {number[][]} matrix1 - The first matrix.\n   * @param {number[][]} matrix2 - The second matrix.\n   * @returns {number[][]} - The resulting matrix.\n   */\n  Matrix3D.prototype.getMatrixMultiplication = function (matrix1, matrix2) {\n    var result = this.getIdentity();\n    for (var i = 0; i < this.matrixSize; i++) {\n      for (var j = 0; j < this.matrixSize; j++) {\n        var value = 0;\n        for (var k = 0; k < this.matrixSize; k++) {\n          value += matrix1[k][j] * matrix2[i][k];\n        }\n        result[i][j] = value;\n      }\n    }\n    return result;\n  };\n  /**\n   * Gets the minor of a matrix.\n   *\n   * @param {number[][]} matrix - The matrix.\n   * @param {number} columnIndex - The column index.\n   * @param {number} rowIndex - The row index.\n   * @returns {number} - The minor of the matrix.\n   * @private\n   */\n  Matrix3D.prototype.getMinor = function (matrix, columnIndex, rowIndex) {\n    return ((columnIndex + rowIndex) % 2 === 0 ? 1 : -1) * this.getDeterminant(this.getMatrix(matrix, columnIndex, rowIndex));\n  };\n  /**\n   * Gets a submatrix of a matrix.\n   *\n   * @param {number[][]} matrix - The matrix.\n   * @param {number} columnIndex - The column index.\n   * @param {number} rowIndex - The row index.\n   * @returns {number[][]} - The submatrix.\n   */\n  Matrix3D.prototype.getMatrix = function (matrix, columnIndex, rowIndex) {\n    var count = matrix.length - 1;\n    var subMatrix = this.createArray(count);\n    for (var i = 0; i < count; i++) {\n      var matrixColumn = i >= columnIndex ? i + 1 : i;\n      subMatrix[i] = this.createArray(count);\n      for (var j = 0; j < count; j++) {\n        var matrixRow = j >= rowIndex ? j + 1 : j;\n        subMatrix[i][j] = matrix[matrixColumn][matrixRow];\n      }\n    }\n    return subMatrix;\n  };\n  /**\n   * Gets the determinant of a matrix.\n   *\n   * @param {number[][]} matrix - The matrix.\n   * @returns {number} - The determinant of the matrix.\n   */\n  Matrix3D.prototype.getDeterminant = function (matrix) {\n    var count = matrix.length;\n    var determinant = 0;\n    if (count < 2) {\n      determinant = matrix[0][0];\n    } else {\n      var k = 1;\n      for (var i = 0; i < count; i++) {\n        var submatrix = this.getMatrix(matrix, i, 0);\n        determinant += k * matrix[i][0] * this.getDeterminant(submatrix);\n        k = k > 0 ? -1 : 1;\n      }\n    }\n    return determinant;\n  };\n  /**\n   * Transforms a matrix by translation.\n   *\n   * @param {number} x - The x-coordinate of the translation.\n   * @param {number} y - The y-coordinate of the translation.\n   * @param {number} z - The z-coordinate of the translation.\n   * @returns {number[][]} - The transformed matrix.\n   */\n  Matrix3D.prototype.transform = function (x, y, z) {\n    var transformedMatrix = this.getIdentity();\n    transformedMatrix[3][0] = x;\n    transformedMatrix[3][1] = y;\n    transformedMatrix[3][2] = z;\n    return transformedMatrix;\n  };\n  /**\n   * Creates a matrix for rotation around the y-axis.\n   *\n   * @param {number} angle - The angle of rotation.\n   * @returns {number[][]} - The rotation matrix.\n   */\n  Matrix3D.prototype.turn = function (angle) {\n    var rotatedMatrix = this.getIdentity();\n    rotatedMatrix[0][0] = Math.cos(angle);\n    rotatedMatrix[2][0] = -Math.sin(angle);\n    rotatedMatrix[0][2] = Math.sin(angle);\n    rotatedMatrix[2][2] = Math.cos(angle);\n    return rotatedMatrix;\n  };\n  /**\n   * Creates a matrix for rotation around the x-axis.\n   *\n   * @param {number} angle - The angle of rotation.\n   * @returns {number[][]} - The rotation matrix.\n   */\n  Matrix3D.prototype.tilt = function (angle) {\n    var rotatedMatrix = this.getIdentity();\n    rotatedMatrix[1][1] = Math.cos(angle);\n    rotatedMatrix[2][1] = Math.sin(angle);\n    rotatedMatrix[1][2] = -Math.sin(angle);\n    rotatedMatrix[2][2] = Math.cos(angle);\n    return rotatedMatrix;\n  };\n  /**\n   * Transposes a matrix.\n   *\n   * @param {number[][]} matrix3D - The matrix to transpose.\n   * @returns {number[][]} - The transposed matrix.\n   */\n  Matrix3D.prototype.transposed = function (matrix3D) {\n    var transposedMatrix = this.getIdentity();\n    for (var i = 0; i < this.matrixSize; i++) {\n      for (var j = 0; j < this.matrixSize; j++) {\n        transposedMatrix[i][j] = matrix3D[j][i];\n      }\n    }\n    return transposedMatrix;\n  };\n  return Matrix3D;\n}();\nexport { Matrix3D };\n/**\n * Represents a 3D chart transformation utility that provides methods for transforming\n * and projecting 3D coordinates onto a 2D screen.\n *\n */\nvar ChartTransform3D = /** @class */function () {\n  /**\n   * Initializes a new instance of the `ChartTransform3D` class.\n   */\n  function ChartTransform3D() {\n    /** Represents the angle conversion factor from degrees to radians. */\n    this.toRadial = Math.PI / 180;\n    this.vector = new Vector3D(0, 0, 0);\n    this.matrixObj = new Matrix3D();\n  }\n  /**\n   * Creates a 3D transformation based on the specified size.\n   *\n   * @param {Size} size - The size of the viewing area.\n   * @returns {Chart3DBasicTransform} - The 3D transformation.\n   */\n  ChartTransform3D.prototype.transform3D = function (size) {\n    return {\n      viewingArea: size,\n      rotation: 0,\n      tilt: 0,\n      depth: 0,\n      perspectiveAngle: 0,\n      needUpdate: true,\n      centeredMatrix: this.matrixObj.getIdentity(),\n      perspective: this.matrixObj.getIdentity(),\n      resultMatrix: this.matrixObj.getIdentity(),\n      viewMatrix: this.matrixObj.getIdentity()\n    };\n  };\n  /**\n   * Applies the specified 3D transformation to the current state.\n   *\n   * @param {Chart3DBasicTransform} transform - The 3D transformation to apply.\n   * @returns {void} - The 3D transformation.\n   */\n  ChartTransform3D.prototype.transform = function (transform) {\n    this.setCenter(this.vector.vector3D(transform.viewingArea.width / 2, transform.viewingArea.height / 2, transform.depth / 2), transform);\n    this.setViewMatrix(this.matrixObj.transform(0, 0, transform.depth), transform);\n    this.setViewMatrix(this.matrixObj.getMatrixMultiplication(transform.viewMatrix, this.matrixObj.turn(-this.toRadial * transform.rotation)), transform);\n    this.setViewMatrix(this.matrixObj.getMatrixMultiplication(transform.viewMatrix, this.matrixObj.tilt(-this.toRadial * transform.tilt)), transform);\n    this.updatePerspective(transform.perspectiveAngle, transform);\n    transform.needUpdate = true;\n  };\n  /**\n   * Updates the perspective matrix based on the specified angle.\n   *\n   * @param {number} angle - The perspective angle.\n   * @param {Chart3DBasicTransform} transform - The 3D transformation.\n   * @returns {void}\n   */\n  ChartTransform3D.prototype.updatePerspective = function (angle, transform) {\n    var width = (transform.viewingArea.width + transform.viewingArea.height) * Math.tan(this.degreeToRadianConverter((180 - Math.abs(angle % 181)) / 2.0)) + transform.depth * 2 / 2;\n    transform.perspective[0][0] = width;\n    transform.perspective[1][1] = width;\n    transform.perspective[2][3] = 1;\n    transform.perspective[3][3] = width;\n  };\n  /**\n   * Converts degrees to radians.\n   *\n   * @param {number} angle - The angle in degrees.\n   * @returns {number} - The angle in radians.\n   * @private\n   */\n  ChartTransform3D.prototype.degreeToRadianConverter = function (angle) {\n    return angle * Math.PI / 180;\n  };\n  /**\n   * Transforms a 3D vector to screen coordinates based on the current state.\n   *\n   * @param {Chart3DVector} vector3D - The 3D vector to transform.\n   * @param {Chart3DBasicTransform} transform - The 3D transformation.\n   * @param {Matrix3D} chartObj - Optional custom matrix object for transformation.\n   * @returns {Chart3DLocation} - The screen coordinates.\n   */\n  ChartTransform3D.prototype.toScreen = function (vector3D, transform, chartObj) {\n    if (!chartObj) {\n      transform.chartObj = this.matrixObj;\n      vector3D = this.matrixObj.getMatrixVectorMultiple(this.result(transform), vector3D);\n    } else {\n      this.matrixObj = chartObj;\n      vector3D = chartObj.getMatrixVectorMultiple(this.result(transform, chartObj), vector3D);\n    }\n    return {\n      x: vector3D.x,\n      y: vector3D.y\n    };\n  };\n  /**\n   * Sets the view matrix in the transformation state.\n   *\n   * @param {number[][]} matrix - The new view matrix.\n   * @param {Chart3DBasicTransform} transform - The 3D transformation.\n   * @returns {void}\n   */\n  ChartTransform3D.prototype.setViewMatrix = function (matrix, transform) {\n    if (transform.viewMatrix === matrix) {\n      return;\n    }\n    transform.viewMatrix = matrix;\n    transform.needUpdate = true;\n  };\n  /**\n   * Calculates the final result matrix based on the current state.\n   *\n   * @param {Chart3DBasicTransform} transform - The 3D transformation.\n   * @param {Matrix3D} matrixobj - Optional custom matrix object for transformation.\n   * @returns {number[][]} - The final result matrix.\n   */\n  ChartTransform3D.prototype.result = function (transform, matrixobj) {\n    var chartObj = transform.chartObj ? transform.chartObj : this.matrixObj;\n    if (!chartObj) {\n      chartObj = matrixobj;\n    }\n    if (!transform.needUpdate) {\n      return transform.resultMatrix;\n    }\n    var matrixObj = this.matrixObj ? this.matrixObj : matrixobj;\n    transform.resultMatrix = chartObj.getMatrixMultiplication(matrixObj.getInterval(transform.centeredMatrix), transform.perspective);\n    transform.resultMatrix = chartObj.getMatrixMultiplication(transform.resultMatrix, transform.viewMatrix);\n    transform.resultMatrix = chartObj.getMatrixMultiplication(transform.resultMatrix, transform.centeredMatrix);\n    transform.needUpdate = false;\n    return transform.resultMatrix;\n  };\n  /**\n   * Sets the center in the transformation state.\n   *\n   * @param {Chart3DVector} center - The new center vector.\n   * @param {Chart3DBasicTransform} transform - The 3D transformation.\n   * @returns {void}\n   */\n  ChartTransform3D.prototype.setCenter = function (center, transform) {\n    transform.centeredMatrix = this.matrixObj.transform(-center.x, -center.y, -center.z);\n    transform.needUpdate = true;\n  };\n  return ChartTransform3D;\n}();\nexport { ChartTransform3D };\n/**\n * Represents a 3D graphics rendering utility for drawing and managing 3D elements in a chart.\n *\n */\nvar Graphics3D = /** @class */function () {\n  function Graphics3D() {\n    /** The vector class. */\n    this.vector = new Vector3D(0, 0, 0);\n  }\n  /**\n   * Adds a visual polygon to the 3D chart and returns its identifier.\n   *\n   * @param {Chart3DPolygon} polygon - The polygon to add.\n   * @param {Chart3D} chart - The 3D chart.\n   * @returns {number} - The identifier of the added polygon.\n   */\n  Graphics3D.prototype.addVisual = function (polygon, chart) {\n    if (polygon == null || polygonObj.test()) {\n      return -1;\n    }\n    return bspTreeObj.add(polygon, chart);\n  };\n  /**\n   * Prepares the view for rendering based on specified parameters.\n   *\n   * @param {number} perspectiveAngle - The perspective angle.\n   * @param {number} depth - The depth of the view.\n   * @param {number} rotation - The rotation angle.\n   * @param {number} tilt - The tilt angle.\n   * @param {Size} size - The size of the viewing area.\n   * @param {Chart3D} chart - The 3D chart.\n   * @returns {void}\n   */\n  Graphics3D.prototype.prepareView = function (perspectiveAngle, depth, rotation, tilt, size, chart) {\n    if (chart3DRender.transform == null) {\n      chart3DRender.transform = chart.transform3D.transform3D(size);\n    } else {\n      chart3DRender.transform.viewingArea = size;\n    }\n    if (!chart3DRender.tree) {\n      chart3DRender.tree = [];\n    }\n    chart3DRender.transform.rotation = rotation;\n    chart3DRender.transform.tilt = tilt;\n    chart3DRender.transform.depth = depth;\n    chart3DRender.transform.perspectiveAngle = perspectiveAngle;\n    chart.transform3D.transform(chart3DRender.transform);\n    chart3DRender.tree[chart.chart3D.id] = bspTreeObj.build();\n  };\n  /**\n   * Renders the 3D view on the specified panel element.\n   *\n   * @param {Element} panel - The panel element to render the view on.\n   * @param {Chart3D} chart - The 3D chart.\n   * @param {number} rotation - The rotation angle.\n   * @param {number} tilt - The tilt angle.\n   * @param {Size} size - The size of the viewing area.\n   * @param {number} perspectiveAngle - The perspective angle.\n   * @param {number} depth - The depth of the view.\n   * @returns {void}\n   */\n  Graphics3D.prototype.view = function (panel, chart, rotation, tilt, size, perspectiveAngle, depth) {\n    var MaxValue = 32767;\n    if (arguments.length === 2) {\n      if (panel == null) {\n        return;\n      }\n      var eyeVector = this.vector.vector3D(0, 0, MaxValue);\n      this.drawNode3D(chart3DRender.tree[chart.chart3D.id], eyeVector, panel, chart);\n    } else {\n      if (panel == null) {\n        return;\n      }\n      if (chart3DRender.transform == null) {\n        chart3DRender.transform = chart.transform3D.transform3D(size);\n      } else {\n        chart3DRender.transform.viewingArea = size;\n      }\n      chart3DRender.transform.rotation = rotation;\n      chart3DRender.transform.tilt = tilt;\n      chart3DRender.transform.depth = depth;\n      chart3DRender.transform.perspectiveAngle = perspectiveAngle;\n      chart.transform3D.transform(chart3DRender.transform);\n      var eye = this.vector.vector3D(0, 0, MaxValue);\n      this.drawNode3D(chart3DRender.tree[chart.chart3D.id], eye, panel, chart);\n    }\n  };\n  /**\n   * Draws a 3D element based on the specified Binary Space Partitioning Node.\n   *\n   * @param {Chart3DBspNode} bspElement - The Binary Space Partitioning Node representing the 3D element.\n   * @param {Chart3D} chart - The 3D chart.\n   * @returns {void}\n   */\n  Graphics3D.prototype.draw3DElement = function (bspElement, chart) {\n    if (bspElement.plane.element) {\n      if (bspElement.plane.element.tag === 'text' || bspElement.plane.element.tag === 'dataLabel') {\n        polygonObj.drawText(bspElement.plane, chart);\n      } else if (bspElement.plane.element.tag === 'template') {\n        polygonObj.drawTemplate(bspElement.plane, chart);\n      } else {\n        polygonObj.drawLine(bspElement.plane, chart);\n      }\n    } else {\n      polygonObj.draw(bspElement.plane, chart);\n    }\n  };\n  /**\n   * Draws the 3D nodes starting from the root based on the eye vector.\n   *\n   * @param {Chart3DBspNode} bspElement - The root Binary Space Partitioning Node.\n   * @param {Chart3DVector} eyeVector - The eye vector.\n   * @param {Element} panel - The panel element to render the view on.\n   * @param {Chart3D} chart - The 3D chart.\n   * @returns {void}\n   */\n  Graphics3D.prototype.drawNode3D = function (bspElement, eyeVector, panel, chart) {\n    if (bspElement === null || chart3DRender.transform == null) {\n      return;\n    }\n    var isVector = true;\n    while (isVector) {\n      var r = vector.vector3DAdd(polygonObj.getNormal(chart.transform3D.result(chart3DRender.transform), bspElement.plane.vectorPoints), eyeVector);\n      if (r > bspElement.plane.d) {\n        if (bspElement.front != null) {\n          this.drawNode3D(bspElement.front, eyeVector, panel, chart);\n        }\n        this.draw3DElement(bspElement, chart);\n        if (bspElement.back != null) {\n          bspElement = bspElement.back;\n          continue;\n        }\n      } else {\n        if (bspElement.back != null) {\n          this.drawNode3D(bspElement.back, eyeVector, panel, chart);\n        }\n        this.draw3DElement(bspElement, chart);\n        if (bspElement.front != null) {\n          bspElement = bspElement.front;\n          continue;\n        }\n      }\n      break;\n    }\n  };\n  return Graphics3D;\n}();\nexport { Graphics3D };\n/**\n * Represents a binary tree builder for 3D polygons in a chart.\n *\n */\nvar BinaryTreeBuilder = /** @class */function () {\n  function BinaryTreeBuilder(chart) {\n    /** A small value used for epsilon comparisons to handle floating-point inaccuracies.*/\n    this.epsilon = 0.0005;\n    this.chart = chart;\n  }\n  /**\n   * Adds a polygon to the binary tree and returns its index.\n   *\n   * @param {Chart3DPolygon} polygon - The polygon to add.\n   * @param {Chart3D} chart - The 3D chart.\n   * @returns {number} - The index of the added polygon.\n   */\n  BinaryTreeBuilder.prototype.add = function (polygon, chart) {\n    this.chart = chart;\n    chart.polygons.push(polygon);\n    return chart.polygons.length - 1;\n  };\n  /**\n   * Gets the next index considering the array length and the current index.\n   *\n   * @param {number} index - The current index.\n   * @param {number} count - The length of the array.\n   * @returns {number} - The next index.\n   */\n  BinaryTreeBuilder.prototype.getNext = function (index, count) {\n    if (index >= count) {\n      return index - count;\n    }\n    if (index < 0) {\n      return index + count;\n    }\n    return index;\n  };\n  /**\n   * Creates a PolyAttributes object based on the vector, index, and result.\n   *\n   * @param {Chart3DVector} point - The vector representing the point.\n   * @param {number} index - The index of the point.\n   * @param {string} result - The result classification.\n   * @returns {Chart3DPolyAttributes} - The created PolyAttributes object.\n   */\n  BinaryTreeBuilder.prototype.vector3DIndexClassification = function (point, index, result) {\n    return {\n      index: index,\n      result: result,\n      vector: point,\n      isCuttingBackPoint: false,\n      cuttingBackPairIndex: null,\n      alreadyCutBack: false,\n      isCuttingFrontPoint: false,\n      cuttingFrontPairIndex: null,\n      alreadyCutFront: false\n    };\n  };\n  /**\n   * Classifies a point relative to a polygon.\n   *\n   * @param {Chart3DVector} point - The point to classify.\n   * @param {Chart3DPolygon} polygon - The polygon for classification.\n   * @returns {string} - The classification result ('OnPlane', 'OnBack', 'OnFront').\n   */\n  BinaryTreeBuilder.prototype.classifyPoint = function (point, polygon) {\n    var result = 'OnPlane';\n    var signedDistance = -polygon.d - vector.vector3DAdd(point, polygon.normal);\n    if (signedDistance > this.epsilon) {\n      result = 'OnBack';\n    } else if (signedDistance < -this.epsilon) {\n      result = 'OnFront';\n    }\n    return result;\n  };\n  /**\n   * Classifies a polygon relative to another polygon.\n   *\n   * @param {Chart3DPolygon} refPolygon - The reference polygon.\n   * @param {Chart3DPolygon} classPolygon - The polygon to classify.\n   * @returns {string} - The classification result ('OnPlane', 'ToRight', 'ToLeft', 'Unknown').\n   */\n  BinaryTreeBuilder.prototype.classifyPolygon = function (refPolygon, classPolygon) {\n    var result = 'Unknown';\n    var points = classPolygon.points;\n    if (points == null) {\n      return result;\n    }\n    var onBack = 0;\n    var onFront = 0;\n    var onPlane = 0;\n    var normal = refPolygon.normal;\n    var polygonValue = refPolygon.d;\n    for (var i = 0, len = points.length; i < len; i++) {\n      var value = -polygonValue - vector.vector3DAdd(points[i], normal);\n      if (value > this.epsilon) {\n        onBack++;\n      } else if (value < -this.epsilon) {\n        onFront++;\n      } else {\n        onPlane++;\n      }\n      if (onBack > 0 && onFront > 0) {\n        break;\n      }\n    }\n    if (onPlane === points.length) {\n      result = 'OnPlane';\n    } else if (onFront + onPlane === points.length) {\n      result = 'ToRight';\n    } else if (onBack + onPlane === points.length) {\n      result = 'ToLeft';\n    } else {\n      result = 'Unknown';\n    }\n    return result;\n  };\n  /**\n   * Splits a polygon into two parts based on another polygon.\n   *\n   * @param {Chart3DPolygon} splitPolygon - The polygon to split.\n   * @param {Chart3DPolygon} refPolygon - The reference polygon for splitting.\n   * @returns {Chart3DPolyCollections} - The resulting back and front parts.\n   * @private\n   */\n  BinaryTreeBuilder.prototype.splitPolygon = function (splitPolygon, refPolygon) {\n    var backPoint = [];\n    var frontPoint = [];\n    if (splitPolygon.points != null) {\n      var polyPoints = [];\n      var backPartPoints = [];\n      var frontPartPoints = [];\n      var outputs = void 0;\n      var inputs = void 0;\n      var count = splitPolygon.points.length;\n      for (var i = 0; i < count; i++) {\n        var pointB = splitPolygon.points[i];\n        var pointC = splitPolygon.points[this.getNext(i + 1, count)];\n        var sideB = this.classifyPoint(pointB, refPolygon);\n        var sideC = this.classifyPoint(pointC, refPolygon);\n        var attributeB = this.vector3DIndexClassification(pointB, polyPoints.length, sideB);\n        polyPoints.push(attributeB);\n        if (sideB !== sideC && sideB !== 'OnPlane' && sideC !== 'OnPlane') {\n          var vectorValue = vector.vector3DMinus(pointB, pointC);\n          var direction = vector.vector3DMinus(vector.vector3DStarMultiply(refPolygon.normal, -refPolygon.d), pointC);\n          var signedDistance = vector.vector3DAdd(direction, refPolygon.normal);\n          var intersectionParameter = signedDistance / vector.vector3DAdd(refPolygon.normal, vectorValue);\n          var intersectionPoint = vector.vector3DPlus(pointC, vector.vector3DStarMultiply(vectorValue, intersectionParameter));\n          var attributeIntersection = this.vector3DIndexClassification(intersectionPoint, polyPoints.length, 'OnPlane');\n          polyPoints.push(attributeIntersection);\n          backPartPoints.push(attributeIntersection);\n          frontPartPoints.push(attributeIntersection);\n        } else if (sideB === 'OnPlane') {\n          var pointA = splitPolygon.points[this.getNext(i - 1, count)];\n          var sideA = this.classifyPoint(pointA, refPolygon);\n          if (sideA === sideC) {\n            continue;\n          }\n          if (sideA !== 'OnPlane' && sideC !== 'OnPlane') {\n            backPartPoints.push(attributeB);\n            frontPartPoints.push(attributeB);\n          } else if (sideA === 'OnPlane') {\n            switch (sideC) {\n              case 'OnBack':\n                backPartPoints.push(attributeB);\n                break;\n              case 'OnFront':\n                frontPartPoints.push(attributeB);\n                break;\n            }\n          } else if (sideC === 'OnPlane') {\n            switch (sideA) {\n              case 'OnBack':\n                backPartPoints.push(attributeB);\n                break;\n              case 'OnFront':\n                frontPartPoints.push(attributeB);\n                break;\n            }\n          }\n        }\n      }\n      if (frontPartPoints.length !== 0 || backPartPoints.length !== 0) {\n        for (var i = 0; i < backPartPoints.length - 1; i += 2) {\n          var backAttribute1 = backPartPoints[i];\n          var backAttribute2 = backPartPoints[i + 1];\n          backAttribute1.cuttingBackPoint = true;\n          backAttribute2.cuttingBackPoint = true;\n          backAttribute1.alterCuttingBackPairIndex = backAttribute2.index;\n          backAttribute2.alterCuttingBackPairIndex = backAttribute1.index;\n        }\n        for (var i = 0; i < frontPartPoints.length - 1; i += 2) {\n          var frontAttribute1 = frontPartPoints[i];\n          var frontAttribute2 = frontPartPoints[i + 1];\n          frontAttribute1.cuttingFrontPoint = true;\n          frontAttribute2.cuttingFrontPoint = true;\n          frontAttribute1.alterCuttingFrontPairIndex = frontAttribute2.index;\n          frontAttribute2.alterCuttingFrontPairIndex = frontAttribute1.index;\n        }\n        for (var i = 0; i < backPartPoints.length - 1; i++) {\n          var backAttribute1 = backPartPoints[i];\n          if (backAttribute1.alreadyCutBack) {\n            continue;\n          }\n          outputs = this.cutOutBackPolygon(polyPoints, backAttribute1);\n          if (outputs.length > 2) {\n            var polygon1 = polygonObj.polygon3D(outputs, splitPolygon);\n            backPoint.push(__assign({}, polygon1));\n          }\n        }\n        for (var i = 0; i < frontPartPoints.length - 1; i++) {\n          var backAttribute2 = frontPartPoints[i];\n          if (backAttribute2.alreadyCutFront) {\n            continue;\n          }\n          inputs = this.cutOutFrontPolygon(polyPoints, backAttribute2);\n          if (inputs.length > 2) {\n            var polygon2 = polygonObj.polygon3D(inputs, splitPolygon);\n            frontPoint.push(__assign({}, polygon2));\n          }\n        }\n      }\n    } else {\n      backPoint.push(splitPolygon);\n      frontPoint.push(splitPolygon);\n    }\n    return {\n      backPolygon: backPoint,\n      frontPolygon: frontPoint\n    };\n  };\n  /**\n   * Cuts out the front part of a polygon based on the PolyAttributes.\n   *\n   * @param {Chart3DPolyAttributes[]} polyPoints - The PolyAttributes array of the polygon.\n   * @param {Chart3DPolyAttributes} initialVertex - The PolyAttributes representing the cutting point.\n   * @returns {Chart3DVector[]} - The resulting points of the front part.\n   */\n  BinaryTreeBuilder.prototype.cutOutFrontPolygon = function (polyPoints, initialVertex) {\n    var points = [];\n    var currentVertex = initialVertex;\n    var isVector = true;\n    while (isVector) {\n      currentVertex.alreadyCutFront = true;\n      points.push(currentVertex.vector);\n      var currentVertexPair = polyPoints[currentVertex.alterCuttingFrontPairIndex];\n      if (currentVertex.cuttingFrontPoint) {\n        if (!currentVertexPair.alreadyCutFront) {\n          currentVertex = currentVertexPair;\n        } else {\n          var previousVertexOnBack = polyPoints[this.getNext(currentVertex.index - 1, polyPoints.length)];\n          var nextVertexOnBack = polyPoints[this.getNext(currentVertex.index + 1, polyPoints.length)];\n          if (previousVertexOnBack.result === 'OnFront' && !previousVertexOnBack.alreadyCutFront) {\n            currentVertex = previousVertexOnBack;\n          } else if (nextVertexOnBack.result === 'OnFront' && !nextVertexOnBack.alreadyCutFront) {\n            currentVertex = nextVertexOnBack;\n          } else {\n            return points;\n          }\n        }\n      } else {\n        var previousVertexOnBack = polyPoints[this.getNext(currentVertex.index - 1, polyPoints.length)];\n        var nextVertexOnBack = polyPoints[this.getNext(currentVertex.index + 1, polyPoints.length)];\n        if (previousVertexOnBack.result !== 'OnBack' && !previousVertexOnBack.alreadyCutFront) {\n          currentVertex = previousVertexOnBack;\n        } else if (nextVertexOnBack.result !== 'OnBack' && !nextVertexOnBack.alreadyCutFront) {\n          currentVertex = nextVertexOnBack;\n        } else {\n          return points;\n        }\n      }\n    }\n    return null;\n  };\n  /**\n   * Cuts out the back part of a polygon based on the PolyAttributes.\n   *\n   * @param {Chart3DPolyAttributes[]} polyPoints - The PolyAttributes array of the polygon.\n   * @param {Chart3DPolyAttributes} initialVertex - The PolyAttributes representing the cutting point.\n   * @returns {Chart3DVector[]} - The resulting points of the back part.\n   */\n  BinaryTreeBuilder.prototype.cutOutBackPolygon = function (polyPoints, initialVertex) {\n    var points = [];\n    var currentVertex = initialVertex;\n    var isVector = true;\n    while (isVector) {\n      currentVertex.alreadyCutBack = true;\n      points.push(currentVertex.vector);\n      var currentVertexPair = polyPoints[currentVertex.alterCuttingBackPairIndex];\n      if (currentVertex.cuttingBackPoint) {\n        if (!currentVertexPair.alreadyCutBack) {\n          currentVertex = currentVertexPair;\n        } else {\n          var previousVertexOnBack = polyPoints[this.getNext(currentVertex.index - 1, polyPoints.length)];\n          var nextVertexOnBack = polyPoints[this.getNext(currentVertex.index + 1, polyPoints.length)];\n          if (previousVertexOnBack.result === 'OnBack' && !previousVertexOnBack.alreadyCutBack) {\n            currentVertex = previousVertexOnBack;\n          } else if (nextVertexOnBack.result === 'OnBack' && !nextVertexOnBack.alreadyCutBack) {\n            currentVertex = nextVertexOnBack;\n          } else {\n            return points;\n          }\n        }\n      } else {\n        var previousVertexOnBack = polyPoints[this.getNext(currentVertex.index - 1, polyPoints.length)];\n        var nextVertexOnBack = polyPoints[this.getNext(currentVertex.index + 1, polyPoints.length)];\n        if (previousVertexOnBack.result !== 'OnFront' && !previousVertexOnBack.alreadyCutBack) {\n          currentVertex = previousVertexOnBack;\n        } else if (nextVertexOnBack.result !== 'OnFront' && !nextVertexOnBack.alreadyCutBack) {\n          currentVertex = nextVertexOnBack;\n        } else {\n          return points;\n        }\n      }\n    }\n    return null;\n  };\n  /**\n   * Builds a Binary Space Partitioning from a list of polygons.\n   *\n   * @param {Chart3DPolygon[]} [points] - The list of polygons to build the tree from.\n   * @returns {Chart3DBspNode} - The root node of the Binary Space Partitioning tree.\n   */\n  BinaryTreeBuilder.prototype.build = function (points) {\n    if (!points) {\n      return this.build(this.chart.polygons);\n    } else {\n      var inputPolygons = points;\n      if (inputPolygons.length < 1) {\n        return null;\n      }\n      var bspNode = {\n        back: null,\n        front: null,\n        plane: null\n      };\n      var plane = inputPolygons[0];\n      bspNode.plane = plane;\n      var polygonsToLeft = [];\n      var polygonsToRight = [];\n      for (var i = 1, len = inputPolygons.length; i < len; i++) {\n        var currentPolygon = inputPolygons[i];\n        if (currentPolygon === plane) {\n          continue;\n        }\n        var classificationResult = this.classifyPolygon(plane, currentPolygon);\n        switch (classificationResult) {\n          case 'OnPlane':\n          case 'ToRight':\n            polygonsToRight.push(currentPolygon);\n            break;\n          case 'ToLeft':\n            polygonsToLeft.push(currentPolygon);\n            break;\n          case 'Unknown':\n            if (currentPolygon.element && (currentPolygon.element.tag === 'line' || currentPolygon.element.tag === 'text')) {\n              polygonsToLeft.push(currentPolygon);\n            } else {\n              var result = this.splitPolygon(currentPolygon, plane);\n              for (var k = 0; k < result.backPolygon.length; k++) {\n                result.backPolygon[k].name = result.backPolygon[k].name + '-back';\n                polygonsToLeft.push(result.backPolygon[k]);\n              }\n              for (var j = 0; j < result.frontPolygon.length; j++) {\n                result.frontPolygon[j].name = result.frontPolygon[j].name + '-front';\n                polygonsToRight.push(result.frontPolygon[j]);\n              }\n            }\n            break;\n        }\n      }\n      if (polygonsToLeft.length > 0) {\n        bspNode.back = this.build(polygonsToLeft);\n      }\n      if (polygonsToRight.length > 0) {\n        bspNode.front = this.build(polygonsToRight);\n      }\n      return bspNode;\n    }\n  };\n  return BinaryTreeBuilder;\n}();\nexport { BinaryTreeBuilder };\n/**\n * The Svg3DRenderer class provides methods for rendering SVG graphics in a 3D context.\n */\nvar Svg3DRenderer = /** @class */function () {\n  function Svg3DRenderer() {}\n  /**\n   * Gets a Chart3DStringBuilder instance for constructing strings.\n   *\n   * @returns {Chart3DStringBuilder} - The StringBuilder instance.\n   */\n  Svg3DRenderer.prototype.getStringBuilder = function () {\n    var data = [];\n    var counter = 0;\n    return {\n      append: function (text) {\n        data[counter++] = text;\n        return this;\n      },\n      remove: function (i, j) {\n        data.splice(i, j || 1);\n        return this;\n      },\n      insert: function (i, text) {\n        data.splice(i, 0, text);\n        return this;\n      },\n      toString: function (text) {\n        return data.join(text || '');\n      }\n    };\n  };\n  /**\n   * Parses a hex color code and returns its Red green Blue values.\n   *\n   * @param {string} hexColorCode - The hex color code.\n   * @returns {Chart3DColorFormat | null} - The parsed color format (Red green Blue) or null if parsing fails.\n   */\n  Svg3DRenderer.prototype.hexToValue = function (hexColorCode) {\n    var result;\n    var values;\n    if (hexColorCode.indexOf('rgba(') === 0) {\n      values = hexColorCode.slice(5, -1).split(',');\n      return values ? {\n        red: parseInt(values[0], 10),\n        green: parseInt(values[1], 10),\n        blue: parseInt(values[2], 10),\n        alpha: parseFloat(values[3])\n      } : null;\n    } else if (hexColorCode.indexOf('rgb(') === 0) {\n      values = hexColorCode.slice(4, -1).split(',');\n      return values ? {\n        red: parseInt(values[0], 10),\n        green: parseInt(values[1], 10),\n        blue: parseInt(values[2], 10)\n      } : null;\n    } else {\n      result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hexColorCode);\n      return result ? {\n        red: parseInt(result[1], 16),\n        green: parseInt(result[2], 16),\n        blue: parseInt(result[3], 16)\n      } : null;\n    }\n  };\n  /**\n   * Converts a Chart3DColorFormat object to its corresponding color string.\n   *\n   * @param {Chart3DColorFormat} color - The color in Chart3DColorFormat.\n   * @returns {string} - The color string representation.\n   */\n  Svg3DRenderer.prototype.hexColor = function (color) {\n    var redValue = color.red;\n    var greenValue = color.green;\n    var blueValue = color.blue;\n    if (color.alpha) {\n      var returnColor = \"rgba(\" + redValue.toString() + \",\" + greenValue.toString() + \",\" + blueValue.toString() + \",\" + color.alpha + \")\";\n      return returnColor;\n    } else {\n      var hex_1 = [redValue.toString(16), greenValue.toString(16), blueValue.toString(16)];\n      hex_1.forEach(function (val, nr) {\n        if (val.length === 1) {\n          hex_1[nr] = '0' + val;\n        }\n      });\n      return '#' + hex_1.join('').toUpperCase();\n    }\n  };\n  /**\n   * Checks if a given color string is in a valid format (hex or rgba).\n   *\n   * @param {string} color - The color string to check.\n   * @returns {boolean} - True if the color string is valid, otherwise false.\n   */\n  Svg3DRenderer.prototype.checkColorFormat = function (color) {\n    if (color.indexOf('rgba(') === 0 || color.indexOf('rgb(') === 0) {\n      var rgbaValues = color.substring(color.indexOf('(') + 1, color.lastIndexOf(')')).split(',');\n      if (rgbaValues.length === 3 || rgbaValues.length === 4) {\n        return rgbaValues.every(function (val) {\n          var num = parseFloat(val);\n          return !isNaN(num) && num >= 0 && num <= 255;\n        });\n      }\n    } else if (color.indexOf('#') === 0) {\n      var hex = color.substring(1);\n      return (hex.length === 3 || hex.length === 6) && /^[0-9A-Fa-f]{3,6}$/.test(hex);\n    }\n    return false;\n  };\n  /**\n   * Draws text on an SVG element.\n   *\n   * @param {any} options - The options for drawing the text.\n   * @param {string | string[]} label - The text label.\n   * @param {FontModel} font - The font settings for the text.\n   * @param {Chart3D} chart - The 3D chart instance.\n   * @returns {Element} - The created SVG text element.\n   */\n  Svg3DRenderer.prototype.drawText = function (options, label, font, chart) {\n    var text = document.getElementById(options.id);\n    if (text === null) {\n      text = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n    }\n    if (label.length > 1 && typeof label !== 'string') {\n      var dy = 0;\n      for (var i = 0; i < label.length; i++) {\n        var tspanElement = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');\n        tspanElement.textContent = label[i];\n        tspanElement.setAttribute('x', String(options.x));\n        tspanElement.setAttribute('dy', String(dy));\n        text.appendChild(tspanElement);\n        dy = measureText(label[i], font, chart.themeStyle.axisLabelFont).height;\n      }\n    } else {\n      text.textContent = label;\n    }\n    text = chart.svgRenderer.setElementAttributes(options, text);\n    return text;\n  };\n  /**\n   * Transforms 3D coordinates to visible 2D coordinates on the chart.\n   *\n   * @param {Chart3DSeries} currentSeries - The current 3D series.\n   * @param {number} x - The x-coordinate in 3D space.\n   * @param {number} y - The y-coordinate in 3D space.\n   * @param {Chart3D} chart - The 3D chart instance.\n   * @returns {Chart3DLocation} - The transformed 2D coordinates.\n   */\n  Svg3DRenderer.prototype.transform3DToVisible = function (currentSeries, x, y, chart) {\n    if (currentSeries.xAxis != null && currentSeries.yAxis != null) {\n      var valueType = currentSeries.xAxis.valueType;\n      var xlogarithmicBase = 10; // Replace with the actual logarithmic base if needed\n      var xIsLogarithmic = valueType === 'Logarithmic';\n      // Apply logarithmic transformation if necessary\n      if (xIsLogarithmic && x > 0) {\n        x = Math.log(x) / Math.log(xlogarithmicBase);\n      }\n      var ylogarithmicBase = currentSeries.yAxis.logBase;\n      var yIsLogarithmic = currentSeries.yAxis.valueType === 'Logarithmic';\n      // Apply logarithmic transformation if necessary\n      if (yIsLogarithmic && y > 0) {\n        y = Math.log(y) / Math.log(ylogarithmicBase);\n      }\n      // Adjust the coordinates based on inverted axes\n      if (chart.requireInvertedAxis) {\n        var left = chart.chartAxisLayoutPanel.seriesClipRect.x;\n        var top_1 = chart.chartAxisLayoutPanel.seriesClipRect.y;\n        var pointX = left + currentSeries.yAxis.rect.width * valueToCoefficients(y, currentSeries.yAxis);\n        var pointY = top_1 + currentSeries.xAxis.rect.height * (1 - valueToCoefficients(x, currentSeries.xAxis));\n        return {\n          x: pointX,\n          y: pointY\n        };\n      } else {\n        var left = currentSeries.xAxis.rect.x;\n        var top_2 = currentSeries.yAxis.rect.y;\n        var newX = left + Math.round(currentSeries.xAxis.rect.width * valueToCoefficients(x, currentSeries.xAxis));\n        var newY = top_2 + Math.round(currentSeries.yAxis.rect.height * (1 - valueToCoefficients(y, currentSeries.yAxis)));\n        return {\n          x: newX,\n          y: newY\n        };\n      }\n    }\n    // Return a default Point if xAxis and yAxis are null\n    return {\n      x: 0,\n      y: 0\n    };\n  };\n  return Svg3DRenderer;\n}();\nexport { Svg3DRenderer };\n/**\n * Represents a 3D polygon in a chart.\n *\n */\nvar Polygon3D = /** @class */function () {\n  function Polygon3D() {\n    /** A small constant used for numerical comparisons. */\n    this.epsilon = 0.00001;\n    /** A small constant used for numerical comparisons. */\n    this.normal = {\n      x: 0,\n      y: 0,\n      z: 0\n    };\n    /** A small constant used for numerical comparisons. */\n    this.vector = new Vector3D(0, 0, 0);\n    /** A small constant used for numerical comparisons. */\n    this.vectorPoints = [];\n    /** A small constant used for numerical comparisons. */\n    this.matrixObj = new Matrix3D();\n    /** A small constant used for numerical comparisons. */\n    this.tabIndex = true;\n  }\n  /**\n   * Creates a 3D polygon.\n   *\n   * @param {Chart3DVector[]} [points] - An array of 3D vectors representing points on the polygon.\n   * @param {any} [tag] - Additional information or metadata for the polygon.\n   * @param {number} [index] - An index associated with the polygon.\n   * @param {string} [stroke] - The stroke color of the polygon.\n   * @param {number} [strokeThickness] - The thickness of the polygon's stroke.\n   * @param {number} [opacity] - The opacity of the polygon.\n   * @param {string} [fill] - The fill color of the polygon.\n   * @param {string} [name] - The name or identifier of the polygon.\n   * @param {Element} [parent] - The parent element to which the polygon belongs.\n   * @param {string} [text] - Additional text associated with the polygon.\n   * @returns {Chart3DPolygon} - Returns the created polygon.\n   */\n  Polygon3D.prototype.polygon3D = function (points, tag, index, stroke, strokeThickness, opacity, fill, name, parent, text) {\n    if (arguments.length === 3) {\n      this.calculateNormal(points, tag, index);\n      return null;\n    } else if (arguments.length === 2) {\n      //points = arguments[0];\n      this.calculateNormal(points[0], points[1], points[2]);\n      this.vectorPoints = points;\n      this.calculateNormal(this.vectorPoints);\n      var polygon = tag;\n      polygon.normal = this.normal;\n      polygon.points = points;\n      polygon.vectorPoints = this.vectorPoints;\n      polygon.isSplit = true;\n      polygon.d = this.d;\n      return polygon;\n    } else {\n      this.calculateNormal(points[0], points[1], points[2]);\n      this.vectorPoints = points;\n      this.calculateNormal(this.vectorPoints);\n      var element = {\n        tag: 'path',\n        parent: parent\n      };\n      var polygon = {\n        normal: this.normal,\n        points: points,\n        vectorPoints: this.vectorPoints,\n        index: index,\n        tag: tag,\n        name: name ? name : null,\n        strokeThickness: strokeThickness,\n        opacity: opacity,\n        fill: fill,\n        d: this.d,\n        text: text ? text : '',\n        polygonElement: element\n      };\n      if (arguments.length !== 1) {\n        polygon.polygonElement = element;\n      }\n      return polygon;\n    }\n  };\n  /**\n   * Creates a 3D line.\n   *\n   * @param {Chart3DTickElement} line - The tick elements associated with the line.\n   * @param {number} x1 - The x-coordinate of the starting point.\n   * @param {number} y1 - The y-coordinate of the starting point.\n   * @param {number} x2 - The x-coordinate of the ending point.\n   * @param {number} y2 - The y-coordinate of the ending point.\n   * @param {number} depth - The depth or z-coordinate of the line in 3D space.\n   * @returns {Chart3DPolygon} - Returns the created 3D line as a polygon.\n   */\n  Polygon3D.prototype.createLine = function (line, x1, y1, x2, y2, depth) {\n    var strokeThickness = line.width;\n    var vectorCollection = [];\n    vectorCollection[0] = this.vector.vector3D(x1, y1, depth);\n    vectorCollection[1] = this.vector.vector3D(x1 + strokeThickness, y2 + strokeThickness, depth);\n    vectorCollection[2] = this.vector.vector3D(x2, y2, depth);\n    return this.line3D(line, vectorCollection);\n  };\n  /**\n   *  Creates a 3D line polygon based on the given tick elements and points.\n   *\n   * @param {Chart3DTickElement} element - The tick elements associated with the line.\n   * @param {Chart3DVector[]} points - The array of 3D vector points defining the line in 3D space.\n   * @returns {Chart3DPolygon} - Returns the created 3D line polygon.\n   */\n  Polygon3D.prototype.line3D = function (element, points) {\n    var plane = this.polygon3D(points);\n    plane.element = element;\n    return plane;\n  };\n  /**\n   * Creates a 3D text polygon based on the given label element and points.\n   *\n   * @param {Chart3DLabelElement} element - The label element associated with the text.\n   * @param {Chart3DVector[]} points - The array of 3D vector points defining the position of the text in 3D space.\n   * @returns {Chart3DPolygon} - Returns the created 3D text polygon.\n   */\n  Polygon3D.prototype.text3D = function (element, points) {\n    var plane = this.polygon3D(points);\n    plane.element = element;\n    return plane;\n  };\n  /**\n   * Creates a 3D cylinder based on the given vectors, chart, and styling parameters.\n   *\n   * @param {Chart3DVector} v1 - The start vector of the cylinder.\n   * @param {Chart3DVector} v2 - The end vector of the cylinder.\n   * @param {Chart3D} chart - The 3D chart to which the cylinder belongs.\n   * @param {number} index - The index of the cylinder.\n   * @param {string} type - The type of the cylinder.\n   * @param {string} stroke - The stroke color of the cylinder.\n   * @param {string} fill - The fill color of the cylinder.\n   * @param {number} strokeThickness - The thickness of the stroke.\n   * @param {number} opacity - The opacity of the cylinder.\n   * @param {string} name - The name of the cylinder.\n   * @param {Element} parent - The parent element of the cylinder.\n   * @returns {Chart3DPolygon[]} - Returns an array of polygons representing the 3D cylinder.\n   */\n  Polygon3D.prototype.createCylinder = function (v1,\n  //top left front vecotr.\n  v2,\n  // bottom right back vector.\n  chart, index, type, stroke, fill, strokeThickness, opacity, name, parent) {\n    var i = 0; //cylinder path count.\n    var offsetX;\n    var offsetY;\n    var offsetZ;\n    var vectorCollection;\n    var pathCount = 24;\n    var theta = 360 / pathCount;\n    var degreeToRadian = Math.PI / 180;\n    var centerZ = (v1.z + v2.z) / 2;\n    var result = [];\n    var outPoints = [];\n    var topVector = [];\n    var bottomVector = [];\n    var radiusB = v2.y - v1.y < v2.z - v1.z ? (v2.y - v1.y) / 2 : (v2.z - v1.z) / 2;\n    var radiusC = v2.x - v1.x < v2.z - v1.z ? (v2.x - v1.x) / 2 : (v2.z - v1.z) / 2;\n    var centerX = (v1.x + v2.x) / 2;\n    var centerY = (v1.y + v2.y) / 2;\n    switch (type) {\n      case 'Bar':\n      case 'StackingBar':\n      case 'StackingBar100':\n        pathCount++;\n        while (pathCount--) {\n          offsetY = centerY + radiusB * Math.cos(i * theta * degreeToRadian);\n          offsetZ = centerZ + radiusB * Math.sin(i * theta * degreeToRadian);\n          outPoints[i] = {\n            Y: offsetY,\n            Z: offsetZ\n          };\n          topVector.push(this.vector.vector3D(v1.x, outPoints[i].Y, outPoints[i].Z));\n          bottomVector.push(this.vector.vector3D(v2.x, outPoints[i].Y, outPoints[i].Z));\n          if (i > 0) {\n            vectorCollection = [this.vector.vector3D(v1.x, outPoints[i - 1].Y, outPoints[i - 1].Z), this.vector.vector3D(v2.x, outPoints[i - 1].Y, outPoints[i - 1].Z), this.vector.vector3D(v2.x, outPoints[i].Y, outPoints[i].Z), this.vector.vector3D(v1.x, outPoints[i].Y, outPoints[i].Z)];\n            result[i + 1] = this.polygon3D(vectorCollection, chart, index, fill, 0, opacity, fill, '-' + (i + 1).toString() + '-' + name, parent);\n            graphics.addVisual(result[i + 1], chart);\n          }\n          i++;\n        }\n        break;\n      case 'Column':\n      case 'StackingColumn':\n      case 'StackingColumn100':\n        pathCount++;\n        while (pathCount--) {\n          offsetX = centerX + radiusC * Math.cos(i * theta * degreeToRadian);\n          offsetZ = centerZ + radiusC * Math.sin(i * theta * degreeToRadian);\n          outPoints[i] = {\n            Y: offsetX,\n            Z: offsetZ\n          };\n          topVector.push(this.vector.vector3D(outPoints[i].Y, v1.y, outPoints[i].Z));\n          bottomVector.push(this.vector.vector3D(outPoints[i].Y, v2.y, outPoints[i].Z));\n          if (i > 0) {\n            vectorCollection = [this.vector.vector3D(outPoints[i - 1].Y, v1.y, outPoints[i - 1].Z), this.vector.vector3D(outPoints[i - 1].Y, v2.y, outPoints[i - 1].Z), this.vector.vector3D(outPoints[i].Y, v2.y, outPoints[i].Z), this.vector.vector3D(outPoints[i].Y, v1.y, outPoints[i].Z)];\n            result[i + 1] = this.polygon3D(vectorCollection, chart, index, fill, 0, opacity, fill, '-' + (i + 1).toString() + '-' + name, parent);\n            graphics.addVisual(result[i + 1], chart);\n          }\n          i++;\n        }\n        break;\n    }\n    result[0] = this.polygon3D(bottomVector, chart, index, stroke, 0, opacity, fill, '-0-' + name, parent);\n    result[1] = this.polygon3D(topVector, chart, index, stroke, strokeThickness, opacity, fill, '-1-' + name, parent);\n    graphics.addVisual(result[0], chart);\n    graphics.addVisual(result[1], chart);\n    return result;\n  };\n  /**\n   * Creates a 3D box based on the given vectors, chart, and styling parameters.\n   *\n   * @param {Chart3DVector} v1 - The start vector of the box.\n   * @param {Chart3DVector} v2 - The end vector of the box.\n   * @param {Chart3D} chart - The 3D chart to which the box belongs.\n   * @param {number} index - The index of the box.\n   * @param {string} stroke - The stroke color of the box.\n   * @param {string} fill - The fill color of the box.\n   * @param {number} strokeThickness - The thickness of the stroke.\n   * @param {number} opacity - The opacity of the box.\n   * @param {boolean} inverse - A boolean indicating whether to inverse the box.\n   * @param {string} name - The name of the box.\n   * @param {Element} parent - The parent element of the box.\n   * @param {string} [text] - Optional text associated with the box.\n   * @returns {Chart3DPolygon[]} - Returns an array of polygons representing the 3D box.\n   *\n   */\n  Polygon3D.prototype.createBox = function (v1,\n  //top left front vecotr.\n  v2,\n  // bottom right back vector.\n  chart, index, stroke, fill, strokeThickness, opacity, inverse, name, parent, text) {\n    var result = [];\n    var point1 = [this.vector.vector3D(v1.x, v1.y, v1.z), this.vector.vector3D(v2.x, v1.y, v1.z), this.vector.vector3D(v2.x, v2.y, v1.z), this.vector.vector3D(v1.x, v2.y, v1.z)];\n    var point2 = [this.vector.vector3D(v1.x, v1.y, v2.z), this.vector.vector3D(v2.x, v1.y, v2.z), this.vector.vector3D(v2.x, v2.y, v2.z), this.vector.vector3D(v1.x, v2.y, v2.z)];\n    var point3 = [this.vector.vector3D(v1.x, v1.y, v2.z), this.vector.vector3D(v2.x, v1.y, v2.z), this.vector.vector3D(v2.x, v1.y, v1.z), this.vector.vector3D(v1.x, v1.y, v1.z)];\n    var point4 = [this.vector.vector3D(v1.x, v2.y, v2.z), this.vector.vector3D(v2.x, v2.y, v2.z), this.vector.vector3D(v2.x, v2.y, v1.z), this.vector.vector3D(v1.x, v2.y, v1.z)];\n    var point5 = [this.vector.vector3D(v1.x, v1.y, v1.z), this.vector.vector3D(v1.x, v1.y, v2.z), this.vector.vector3D(v1.x, v2.y, v2.z), this.vector.vector3D(v1.x, v2.y, v1.z)];\n    var point6 = [this.vector.vector3D(v2.x, v1.y, v1.z), this.vector.vector3D(v2.x, v1.y, v2.z), this.vector.vector3D(v2.x, v2.y, v2.z), this.vector.vector3D(v2.x, v2.y, v1.z)];\n    if (name) {\n      result[0] = this.polygon3D(point1, chart, index, stroke, strokeThickness, opacity, fill, '-0-' + name, parent, text);\n      result[1] = this.polygon3D(point2, chart, index, stroke, strokeThickness, opacity, fill, '-1-' + name, parent, text);\n      result[2] = this.polygon3D(point3, chart, index, stroke, strokeThickness, opacity, fill, '-2-' + name, parent, text);\n      result[3] = this.polygon3D(point4, chart, index, stroke, strokeThickness, opacity, fill, '-3-' + name, parent, text);\n      result[4] = this.polygon3D(point5, chart, index, stroke, strokeThickness, opacity, fill, '-4-' + name, parent, text);\n      result[5] = this.polygon3D(point6, chart, index, stroke, strokeThickness, opacity, fill, '-5-' + name, parent, text);\n    } else {\n      result[0] = this.polygon3D(point1, chart, index, stroke, strokeThickness, opacity, fill, '-0-' + index, parent, text);\n      result[1] = this.polygon3D(point2, chart, index, stroke, strokeThickness, opacity, fill, '-1-' + index, parent, text);\n      result[2] = this.polygon3D(point3, chart, index, stroke, strokeThickness, opacity, fill, '-2-' + index, parent, text);\n      result[3] = this.polygon3D(point4, chart, index, stroke, strokeThickness, opacity, fill, '-3-' + index, parent, text);\n      result[4] = this.polygon3D(point5, chart, index, stroke, strokeThickness, opacity, fill, '-4-' + index, parent, text);\n      result[5] = this.polygon3D(point6, chart, index, stroke, strokeThickness, opacity, fill, '-5-' + index, parent, text);\n    }\n    if (inverse) {\n      graphics.addVisual(result[0], chart);\n      graphics.addVisual(result[1], chart);\n      graphics.addVisual(result[2], chart);\n      graphics.addVisual(result[3], chart);\n      graphics.addVisual(result[4], chart);\n      graphics.addVisual(result[5], chart);\n    } else {\n      graphics.addVisual(result[5], chart);\n      graphics.addVisual(result[4], chart);\n      graphics.addVisual(result[0], chart);\n      graphics.addVisual(result[1], chart);\n      graphics.addVisual(result[2], chart);\n      graphics.addVisual(result[3], chart);\n    }\n    return result;\n  };\n  /**\n   * Calculates the normal vector for a 3D polygon based on the provided points.\n   *\n   * @param {...Chart3DVector} args - Variable number of vector3d arguments representing points of the polygon.\n   * @returns {void}\n   */\n  Polygon3D.prototype.calculateNormal = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    if (args.length >= 3) {\n      // Relative information of the points\n      var vector1 = args[0];\n      var vector2 = args[1];\n      var vector3 = args[2];\n      var vector4 = this.vector.vector3DMinus(vector1, vector2);\n      var vector5 = this.vector.vector3DMinus(vector3, vector2);\n      var normal = this.vector.vector3DMultiply(vector4, vector5);\n      var length_1 = this.vector.getLength(normal); // Get length of the vector\n      if (length_1 < this.epsilon) {\n        length_1 = 1;\n      }\n      this.normal = this.vector.vector3D(normal.x / length_1, normal.y / length_1, normal.z / length_1); // Calculate normalization of the vector\n      this.d = -(this.normal.x * vector1.x + this.normal.y * vector1.y + this.normal.z * vector1.z); // Normalized values * 1st coordinates Coordinates - Depth of the plan\n      if (args[3]) {\n        args[3].normal = this.normal;\n        args[3].d = this.d;\n      }\n    } else {\n      var Points = args[0];\n      this.calculateNormal(Points[0], Points[1], Points[2], args[1]);\n      for (var i = 3; i < Points.length && this.test(); i++) {\n        this.calculateNormal(Points[i], Points[0], Points[i / 2]);\n      }\n    }\n  };\n  /**\n   * Tests whether the calculated normal vector is valid.\n   *\n   * @returns {boolean} - Returns true if the normal vector is valid, false otherwise.\n   */\n  Polygon3D.prototype.test = function () {\n    return !this.vector.isValid(this.normal);\n  };\n  /**\n   * Transforms the vector points of the specified polygon using the provided matrix.\n   *\n   * @param {number[][]} matrix - The transformation matrix.\n   * @param {Chart3DPolygon} polygon - The polygon to transform.\n   * @returns {void}\n   */\n  Polygon3D.prototype.transform = function (matrix, polygon) {\n    if (polygon.points != null) {\n      for (var i = 0; i < polygon.points.length; i++) {\n        polygon.vectorPoints[i] = polygon.points[i] = matrixObj.getMatrixVectorMultiple(matrix, polygon.points[i]);\n      }\n      this.calculateNormal(polygon.vectorPoints, polygon);\n    }\n  };\n  /**\n   *  Gets the normal vector based on the transformed points using the specified transformation matrix.\n   *\n   * @param {number[][]} transform - The transformation matrix.\n   * @param {Chart3DVector[]} [vectorPoints] - The vector points.\n   * @returns {Chart3DVector} - Returns the normal vector.\n   * @private\n   */\n  Polygon3D.prototype.getNormal = function (transform, vectorPoints) {\n    var normal;\n    if (vectorPoints != null) {\n      normal = this.vector.getNormal(this.matrixObj.getMatrixVectorMultiple(transform, vectorPoints[0]), matrixObj.getMatrixVectorMultiple(transform, vectorPoints[1]), this.matrixObj.getMatrixVectorMultiple(transform, vectorPoints[2]));\n      for (var i = 3; i < vectorPoints.length && !this.vector.isValid(normal) && vectorPoints[i / 2]; i++) {\n        var v1 = matrixObj.getMatrixVectorMultiple(transform, vectorPoints[i]);\n        var v2 = matrixObj.getMatrixVectorMultiple(transform, vectorPoints[0]);\n        var v3 = matrixObj.getMatrixVectorMultiple(transform, vectorPoints[i / 2]);\n        normal = this.vector.getNormal(v1, v2, v3);\n      }\n    } else {\n      normal = matrixObj.getMatrixVectorAnd(transform);\n      this.vector.normalize();\n    }\n    return normal;\n  };\n  /**\n   * A method for creating text element.\n   *\n   * @param {Chart3DVector} position - text position.\n   * @param {Chart3DLabelElement} element - text element.\n   * @param {number} xLength - text element x value.\n   * @param {number} yLength - text element y value.\n   * @returns {Chart3DPolygon} - Returns the polygon.\n   */\n  Polygon3D.prototype.createTextElement = function (position, element, xLength, yLength) {\n    var vectorCollection = [];\n    var x = position.x;\n    var y = position.y;\n    var desiredWidth = element.width;\n    var desiredHeight = element.height;\n    vectorCollection[0] = this.vector.vector3D(x, y, position.z);\n    vectorCollection[1] = this.vector.vector3D(x + desiredWidth, y + desiredHeight + yLength, position.z);\n    vectorCollection[2] = this.vector.vector3D(x + desiredWidth + xLength, y + desiredHeight + yLength, position.z);\n    return this.text3D(element, vectorCollection);\n  };\n  /**\n   * Draws a template on the specified 3D chart panel.\n   *\n   * @param {Chart3DPolygon} panel - The 3D polygon representing the panel on which the template will be drawn.\n   * @param {Chart3D} chart - The 3D chart to which the panel belongs.\n   * @returns {void}\n   */\n  Polygon3D.prototype.drawLine = function (panel, chart) {\n    var transform = chart3DRender.transform;\n    if (transform == null) {\n      return;\n    }\n    var actual3DPosition1 = chart.transform3D.toScreen(panel.vectorPoints[0], transform);\n    var actual3DPosition2 = chart.transform3D.toScreen(panel.vectorPoints[2], transform);\n    var optionsLine = {\n      'id': panel.element.id,\n      'x1': actual3DPosition1.x,\n      'y1': actual3DPosition1.y,\n      'x2': actual3DPosition2.x,\n      'y2': actual3DPosition2.y,\n      'stroke-dasharray': '',\n      'stroke-width': panel.element.width,\n      'stroke': panel.element.stroke,\n      'opacity': panel.element.opacity\n    };\n    chart.chart3D.appendChild(chart.svgRenderer.drawLine(optionsLine));\n    if (chart.previousID && chart.isTouch) {\n      var previousElement = document.getElementById(chart.previousID);\n      var currentElement = document.getElementById(optionsLine.id);\n      if (previousElement && currentElement) {\n        currentElement.parentNode.insertBefore(currentElement, previousElement.nextSibling);\n      }\n    }\n    chart.previousID = optionsLine.id;\n  };\n  /**\n   * Draws text on the specified 3D chart panel.\n   *\n   * @param {Chart3DPolygon} panel - The 3D polygon representing the panel on which the text will be drawn.\n   * @param {Chart3D} chart - The 3D chart to which the panel belongs.\n   * @returns {void}\n   */\n  Polygon3D.prototype.drawTemplate = function (panel, chart) {\n    var element = panel.element;\n    var transform = chart3DRender.transform;\n    if (transform == null) {\n      return;\n    }\n    var label = element.label;\n    var actual3DPosition = chart.transform3D.toScreen(panel.vectorPoints[0], transform);\n    chart.dataLabel3DModule.createDataLabelTemplate(label.series.dataLabelElement, label.series, label.series.dataLabel, label.series.visiblePoints[label.pointIndex], element.argsData, label.pointIndex, false, actual3DPosition);\n  };\n  /**\n   * Draws a data label symbol for a specific data point in a three-dimensional series.\n   *\n   * @param {Chart3DPolygon} panel - The 3D polygon representing the panel on which the text will be drawn.\n   * @param {Chart3D} chart - The 3D chart to which the panel belongs.\n   * @returns {void}\n   */\n  Polygon3D.prototype.drawText = function (panel, chart) {\n    var element = panel.element;\n    var transform = chart3DRender.transform;\n    if (transform == null) {\n      return;\n    }\n    var actual3DPosition = chart.transform3D.toScreen(panel.vectorPoints[0], transform);\n    var x = actual3DPosition.x;\n    var y = actual3DPosition.y;\n    if (element.tag === 'text') {\n      var options = {\n        'id': element.id,\n        'x': x,\n        'y': y,\n        'fill': element.font.color || element.fill,\n        'font-size': element.font.size,\n        'font-family': element.font.fontFamily,\n        'font-style': element.font.fontStyle,\n        'font-weight': element.font.fontWeight,\n        'opacity': element.font.opacity,\n        'text-anchor': element.textAnchor,\n        'cursor': 'default',\n        'transform': element.angle ? 'rotate(' + element.angle + ',' + x + ',' + y + ')' : ''\n      };\n      var textElement = chart.svg3DRenderer.drawText(options, element.label.text, panel.element.font, chart);\n      if (element.id.indexOf('-axis-title') > -1) {\n        textElement.setAttribute('aria-hidden', 'true');\n      }\n      chart.chart3D.append(textElement);\n    } else {\n      var series = element.series;\n      var labelFormat = series.yAxis && series.yAxis.labelFormat ? series.yAxis.labelFormat : '';\n      var pointText = element.point.text ? element.point.text : element.point.y + labelFormat.substring(labelFormat.indexOf('}') + 1);\n      var textOffset = measureText(pointText, series.dataLabel.font, chart.themeStyle.datalabelFont);\n      var margin = series.dataLabel.margin;\n      var width = textOffset.width + margin.left + margin.right;\n      var height = textOffset.height + margin.top + margin.bottom;\n      var location_1 = {\n        x: actual3DPosition.x,\n        y: actual3DPosition.y\n      };\n      var xXalue = location_1.x - margin.left / 2 + margin.right / 2;\n      var yValue = location_1.y - margin.top / 2 - height / margin.top + margin.bottom / 2;\n      var seriesIndex = series.index;\n      this.dataLabelSymbol(seriesIndex, series, element.pointIndex, xXalue, yValue, width, height, chart);\n    }\n  };\n  /**\n   * Draws a data label symbol for a specific data point in a three-dimensional series.\n   *\n   * @param {number} seriesIndex - The index of the series to which the data point belongs.\n   * @param {Chart3DSeries} series - The three-dimensional series containing the data point.\n   * @param {number} pointIndex - The index of the data point within the series.\n   * @param {number} x - The x-coordinate of the center of the symbol.\n   * @param {number} y - The y-coordinate of the center of the symbol.\n   * @param {number} width - The width of the symbol.\n   * @param {number} height - The height of the symbol.\n   * @param {Chart3D} chart - The three-dimensional chart containing the series.\n   * @returns {void}\n   */\n  Polygon3D.prototype.dataLabelSymbol = function (seriesIndex, series, pointIndex, x, y, width, height, chart) {\n    var path = 'M' + ' ' + (x + -width / 2) + ' ' + (y + -height / 2) + ' ' + 'L' + ' ' + (x + width / 2) + ' ' + (y + -height / 2) + ' ' + 'L' + ' ' + (x + width / 2) + ' ' + (y + height / 2) + ' ' + 'L' + ' ' + (x + -width / 2) + ' ' + (y + height / 2) + ' ' + 'L' + ' ' + (x + -width / 2) + ' ' + (y + -height / 2) + ' z';\n    var Rectoptions = {\n      id: chart.element.id + '-svg' + '-data-label-series-' + seriesIndex + '-point-' + pointIndex,\n      fill: series.dataLabel.fill,\n      'stroke-width': series.dataLabel.border.width,\n      'stroke-dasharray': series.dataLabel.border.dashArray,\n      stroke: series.dataLabel.border.color,\n      opacity: series.dataLabel.opacity,\n      visibility: '',\n      d: path\n    };\n    var element = chart.svgRenderer.drawPath(Rectoptions);\n    chart.chart3D.append(element);\n  };\n  /**\n   * Draws a three-dimensional polygon on the specified chart.\n   *\n   * @param {Chart3DPolygon} panel - The polygon to be drawn.\n   * @param {Chart3D} chart - The three-dimensional chart on which the polygon is to be drawn.\n   * @returns {void}\n   */\n  Polygon3D.prototype.draw = function (panel, chart) {\n    if (panel.vectorPoints == null || panel.vectorPoints.length <= 0) {\n      return;\n    }\n    var transform = chart3DRender.transform;\n    var pathDirection = chart.svg3DRenderer.getStringBuilder();\n    var color = panel.fill;\n    var format = chart.svg3DRenderer.checkColorFormat(color);\n    if (!format) {\n      if (color !== 'transparent') {\n        color = colorNameToHex(color);\n      }\n    }\n    var figure = {\n      StartPoint: null\n    };\n    if (transform != null) {\n      figure.StartPoint = chart.transform3D.toScreen(panel.vectorPoints[0], transform);\n      pathDirection.append('M' + ' ' + figure.StartPoint.x + ' ' + figure.StartPoint.y + ' ');\n      for (var i = 0; i < panel.vectorPoints.length; i++) {\n        var lineSegment = chart.transform3D.toScreen(panel.vectorPoints[i], transform);\n        pathDirection.append('L' + ' ' + lineSegment.x + ' ' + lineSegment.y + ' ');\n      }\n    }\n    var direction = pathDirection.toString();\n    var name = 'Light';\n    var lightCoefficientZ = 2 * (Math.abs(this.vector.vector3DAdd(panel.normal, this.vector.vector3D(0, 0, 1))) - 1);\n    var lightCoefficientY = 2 * (Math.abs(this.vector.vector3DAdd(panel.normal, this.vector.vector3D(0, 1, 0))) - 1);\n    var lightCoefficientX = 2 * (Math.abs(this.vector.vector3DAdd(panel.normal, this.vector.vector3D(1, 0, 0))) - 1);\n    if (panel.name && !(panel.name.indexOf('-wall-brush') > -1)) {\n      if (lightCoefficientZ === lightCoefficientX) {\n        name = 'ZLight';\n        color = this.applyZLight(color, chart);\n      } else if (lightCoefficientY === lightCoefficientZ || lightCoefficientZ !== 0 && lightCoefficientY < lightCoefficientZ) {\n        name = 'XLight';\n        color = this.applyXLight(color, chart);\n      } else if (lightCoefficientZ < 0) {\n        name = 'ZLight';\n        color = this.applyZLight(color, chart);\n      } else {\n        name = 'Light';\n      }\n    }\n    var options = {\n      'id': chart.element.id + '-svg' + panel.name,\n      'name': name,\n      'fill': color,\n      'stroke': '',\n      'stroke-width': panel.strokeThickness,\n      'opacity': panel.opacity,\n      'd': direction\n    };\n    var element = chart.svgRenderer.drawPath(options);\n    if (panel.text) {\n      element.setAttribute('aria-label', panel.text);\n      element.setAttribute('role', 'img');\n    }\n    if (panel.name && panel.name.indexOf('-wall-brush') > -1) {\n      element.setAttribute('aria-hidden', 'true');\n    }\n    if (element.id.indexOf('0-region-series-0-point-0') > -1) {\n      if (this.tabIndex) {\n        element.setAttribute('tabindex', '0');\n      } else {\n        var elements = panel.polygonElement.parent.querySelectorAll('[id*=\"0-region-series-0-point-0\"]');\n        if (elements.length > 0) {\n          elements[elements.length - 1].removeAttribute('tabindex');\n        }\n        element.setAttribute('tabindex', '0');\n      }\n      this.tabIndex = false;\n    }\n    appendChildElement(false, panel.polygonElement.parent, element, chart.redraw, true, 'x', 'y', null, direction);\n    if (chart.previousID && chart.isTouch) {\n      var previousElement = document.getElementById(chart.previousID);\n      var currentElement = document.getElementById(options.id);\n      if (previousElement && currentElement) {\n        currentElement.parentNode.insertBefore(currentElement, previousElement.nextSibling);\n      }\n    }\n    chart.previousID = options.id;\n  };\n  /**\n   * Applies a lightening effect to the given color by reducing its red, green and blue components.\n   *\n   * @param {string} color - The input color in hexadecimal format.\n   * @param {Chart3D} chart - The three-dimensional chart associated with the color.\n   * @returns {string} - The lightened color in hexadecimal format.\n   */\n  Polygon3D.prototype.applyXLight = function (color, chart) {\n    var RGB = chart.svg3DRenderer.hexToValue(color);\n    RGB.red = parseInt((RGB.red * 0.7).toString(), 10);\n    RGB.green = parseInt((RGB.green * 0.7).toString(), 10);\n    RGB.blue = parseInt((RGB.blue * 0.7).toString(), 10);\n    return chart.svg3DRenderer.hexColor(RGB);\n  };\n  /**\n   * Applies a lightening effect to the given color by reducing its red, green and blue components with a focus on the Z-axis.\n   *\n   * @param {string} color - The input color in hexadecimal format.\n   * @param {Chart3D} chart - The three-dimensional chart associated with the color.\n   * @returns {string} - The lightened color in hexadecimal format.\n   */\n  Polygon3D.prototype.applyZLight = function (color, chart) {\n    var RGB = chart.svg3DRenderer.hexToValue(color);\n    RGB.red = parseInt((RGB.red * 0.9).toString(), 10);\n    RGB.green = parseInt((RGB.green * 0.9).toString(), 10);\n    RGB.blue = parseInt((RGB.blue * 0.9).toString(), 10);\n    return chart.svg3DRenderer.hexColor(RGB);\n  };\n  return Polygon3D;\n}();\nexport { Polygon3D };\nvar vector = new Vector3D(0, 0, 0);\nvar matrixObj = new Matrix3D();\nvar bspTreeObj = new BinaryTreeBuilder();\nvar polygonObj = new Polygon3D();\nvar graphics = new Graphics3D();\n/**\n * Gets the minimum delta value between adjacent data points on a given axis in a three-dimensional chart.\n *\n * @param {Chart3DAxis} axis - The three-dimensional axis for which the delta value is calculated.\n * @param {Chart3DSeries[]} seriesCollection - Collection of three-dimensional series in the chart.\n * @returns {number} - The minimum delta value between adjacent data points on the specified axis.\n */\nexport function getMinPointsDeltaValue(axis, seriesCollection) {\n  var minDelta = Number.MAX_VALUE;\n  var xValues;\n  var minVal;\n  var seriesMin;\n  for (var index = 0; index < seriesCollection.length; index++) {\n    var series = seriesCollection[index];\n    xValues = [];\n    if (series.visible && (axis.name === series.xAxisName || axis.name === 'primaryXAxis' && series.xAxisName === null)) {\n      xValues = series.points.map(function (point) {\n        return point.xValue;\n      });\n      xValues.sort(function (first, second) {\n        return first - second;\n      });\n      if (xValues.length === 1) {\n        seriesMin = axis.valueType === 'DateTime' && series.xMin === series.xMax ? series.xMin - 25920000 : series.xMin;\n        minVal = xValues[0] - (!isNullOrUndefined(seriesMin) ? seriesMin : axis.visibleRange.min);\n        if (minVal !== 0) {\n          minDelta = Math.min(minDelta, minVal);\n        }\n      } else {\n        for (var index_1 = 0; index_1 < xValues.length; index_1++) {\n          var value = xValues[index_1];\n          if (index_1 > 0 && value) {\n            minVal = value - xValues[index_1 - 1];\n            if (minVal !== 0) {\n              minDelta = Math.min(minDelta, minVal);\n            }\n          }\n        }\n      }\n    }\n  }\n  if (minDelta === Number.MAX_VALUE) {\n    minDelta = 1;\n  }\n  return minDelta;\n}\n/**\n * Converts a numeric value to a coefficient based on the given 3D axis.\n *\n * @param {number} value - The numeric value to be converted.\n * @param {Chart3DAxis} axis - The 3D axis for reference.\n * @returns {number} - The coefficient value.\n * @private\n */\nexport function valueToCoefficients(value, axis) {\n  var range = axis.visibleRange;\n  var result = (value - range.min) / range.delta;\n  var isInverse = axis.isAxisInverse;\n  return isInverse ? 1 - result : result;\n}","map":{"version":3,"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","measureText","appendChildElement","colorNameToHex","isNullOrUndefined","Chart3DRender","transform","chart3DRender","Vector3D","pointX","vy","vz","x","y","z","epsilon","isValid","point","isNaN","vector3D","vx","vector3DMinus","v1","v2","vector3DPlus","vector3DMultiply","vector3DAdd","vector3DStarMultiply","value","getLength","vector","sqt","Math","sqrt","normalize","getNormal","v3","vector4","vector5","Matrix3D","matrixSize","matrix3D","size","matrixData","createArray","isAffine","initialSize","index","getIdentity","getInterval","matrix","j","getMinor","transposed","getMatrixMultiple","getDeterminant","factor","getMatrixVectorMultiple","c","getMatrixVectorAnd","getMatrixMultiplication","matrix1","matrix2","result","k","columnIndex","rowIndex","getMatrix","count","subMatrix","matrixColumn","matrixRow","determinant","submatrix","transformedMatrix","turn","angle","rotatedMatrix","cos","sin","tilt","transposedMatrix","ChartTransform3D","toRadial","PI","matrixObj","transform3D","viewingArea","rotation","depth","perspectiveAngle","needUpdate","centeredMatrix","perspective","resultMatrix","viewMatrix","setCenter","width","height","setViewMatrix","updatePerspective","tan","degreeToRadianConverter","abs","toScreen","chartObj","matrixobj","center","Graphics3D","addVisual","polygon","chart","polygonObj","test","bspTreeObj","add","prepareView","tree","chart3D","id","build","view","panel","MaxValue","eyeVector","drawNode3D","eye","draw3DElement","bspElement","plane","element","tag","drawText","drawTemplate","drawLine","draw","isVector","r","vectorPoints","d","front","back","BinaryTreeBuilder","polygons","push","getNext","vector3DIndexClassification","isCuttingBackPoint","cuttingBackPairIndex","alreadyCutBack","isCuttingFrontPoint","cuttingFrontPairIndex","alreadyCutFront","classifyPoint","signedDistance","normal","classifyPolygon","refPolygon","classPolygon","points","onBack","onFront","onPlane","polygonValue","len","splitPolygon","backPoint","frontPoint","polyPoints","backPartPoints","frontPartPoints","outputs","inputs","pointB","pointC","sideB","sideC","attributeB","vectorValue","direction","intersectionParameter","intersectionPoint","attributeIntersection","pointA","sideA","backAttribute1","backAttribute2","cuttingBackPoint","alterCuttingBackPairIndex","frontAttribute1","frontAttribute2","cuttingFrontPoint","alterCuttingFrontPairIndex","cutOutBackPolygon","polygon1","polygon3D","cutOutFrontPolygon","polygon2","backPolygon","frontPolygon","initialVertex","currentVertex","currentVertexPair","previousVertexOnBack","nextVertexOnBack","inputPolygons","bspNode","polygonsToLeft","polygonsToRight","currentPolygon","classificationResult","name","Svg3DRenderer","getStringBuilder","data","counter","append","text","remove","splice","insert","toString","join","hexToValue","hexColorCode","values","indexOf","slice","split","red","parseInt","green","blue","alpha","parseFloat","exec","hexColor","color","redValue","greenValue","blueValue","returnColor","hex_1","forEach","val","nr","toUpperCase","checkColorFormat","rgbaValues","substring","lastIndexOf","every","num","hex","options","label","font","document","getElementById","createElementNS","dy","tspanElement","textContent","setAttribute","String","appendChild","themeStyle","axisLabelFont","svgRenderer","setElementAttributes","transform3DToVisible","currentSeries","xAxis","yAxis","valueType","xlogarithmicBase","xIsLogarithmic","log","ylogarithmicBase","logBase","yIsLogarithmic","requireInvertedAxis","left","chartAxisLayoutPanel","seriesClipRect","top_1","rect","valueToCoefficients","pointY","top_2","newX","round","newY","Polygon3D","tabIndex","stroke","strokeThickness","opacity","fill","parent","calculateNormal","isSplit","polygonElement","createLine","line","x1","y1","x2","y2","vectorCollection","line3D","text3D","createCylinder","type","offsetX","offsetY","offsetZ","pathCount","theta","degreeToRadian","centerZ","outPoints","topVector","bottomVector","radiusB","radiusC","centerX","centerY","Y","Z","graphics","createBox","inverse","point1","point2","point3","point4","point5","point6","args","_i","vector1","vector2","vector3","length_1","Points","createTextElement","position","xLength","yLength","desiredWidth","desiredHeight","actual3DPosition1","actual3DPosition2","optionsLine","previousID","isTouch","previousElement","currentElement","parentNode","insertBefore","nextSibling","actual3DPosition","dataLabel3DModule","createDataLabelTemplate","series","dataLabelElement","dataLabel","visiblePoints","pointIndex","argsData","fontFamily","fontStyle","fontWeight","textAnchor","textElement","svg3DRenderer","labelFormat","pointText","textOffset","datalabelFont","margin","right","top","bottom","location_1","xXalue","yValue","seriesIndex","dataLabelSymbol","path","Rectoptions","border","dashArray","visibility","drawPath","pathDirection","format","figure","StartPoint","lineSegment","lightCoefficientZ","lightCoefficientY","lightCoefficientX","applyZLight","applyXLight","elements","querySelectorAll","removeAttribute","redraw","RGB","getMinPointsDeltaValue","axis","seriesCollection","minDelta","Number","MAX_VALUE","xValues","minVal","seriesMin","visible","xAxisName","map","xValue","sort","first","second","xMin","xMax","visibleRange","min","index_1","range","delta","isInverse","isAxisInverse"],"sources":["C:/Users/mkfun/Desktop/ct assignment/admin/node_modules/@syncfusion/ej2-charts/src/chart3d/utils/chart3dRender.js"],"sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { measureText } from '@syncfusion/ej2-svg-base';\nimport { appendChildElement, colorNameToHex } from '../../common/utils/helper';\nimport { isNullOrUndefined } from '@syncfusion/ej2-base';\n/**\n * Represents a 3D rendering configuration for the EJ3D rendering engine.\n *\n */\nvar Chart3DRender = /** @class */ (function () {\n    function Chart3DRender() {\n        this.transform = null; // Chart3DBasicTransform\n    }\n    return Chart3DRender;\n}());\nexport { Chart3DRender };\nvar chart3DRender = new Chart3DRender();\n/**\n * Represents a three-dimensional vector in space.\n */\nvar Vector3D = /** @class */ (function () {\n    /**\n     * Constructs a new Vector3D instance.\n     *\n     * @constructor\n     * @param {number | { x: number, y: number }} pointX - Either an object with x and y properties or the x-coordinate.\n     * @param {number} [vy] - The y-coordinate (if the first parameter is a number).\n     * @param {number} [vz] - The z-coordinate (if the first parameter is a number).\n     */\n    function Vector3D(pointX, vy, vz) {\n        /** The x-coordinate of the vector. */\n        this.x = 0;\n        /** The y-coordinate of the vector. */\n        this.y = 0;\n        /** The z-coordinate of the vector. */\n        this.z = 0;\n        /** A small value used for epsilon comparisons to handle floating-point inaccuracies.*/\n        this.epsilon = 0.00001;\n        this.x = pointX;\n        this.y = vy || 0;\n        this.z = vz || 0;\n    }\n    /**\n     * Checks if a vector is valid (not NaN for any component).\n     *\n     * @param {Chart3DVector} point - The vector to check.\n     * @returns {boolean} - True if the vector is valid, false otherwise.\n     */\n    Vector3D.prototype.isValid = function (point) {\n        return !isNaN(point.x) && !isNaN(point.y) && !isNaN(point.z);\n    };\n    /**\n     * Creates a new Vector3D instance from provided coordinates.\n     *\n     * @param {number | { x: number, y: number }} vx - Either an object with x and y properties or the x-coordinate.\n     * @param {number} vy - The y-coordinate.\n     * @param {number} vz - The z-coordinate.\n     * @returns {Chart3DVector} - The new Vector3D instance.\n     */\n    Vector3D.prototype.vector3D = function (vx, vy, vz) {\n        this.x = vx;\n        this.y = vy;\n        this.z = vz;\n        return { x: this.x, y: this.y, z: this.z };\n    };\n    /**\n     * Subtracts one vector from another and returns the result.\n     *\n     * @param {Chart3DVector} v1 - The first vector.\n     * @param {Chart3DVector} v2 - The second vector to subtract from the first.\n     * @returns {Chart3DVector} - The resulting vector.\n     */\n    Vector3D.prototype.vector3DMinus = function (v1, v2) {\n        return this.vector3D(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);\n    };\n    /**\n     * Adds two vectors and returns the result.\n     *\n     * @param {Chart3DVector} v1 - The first vector.\n     * @param {Chart3DVector} v2 - The second vector to add to the first.\n     * @returns {Chart3DVector} - The resulting vector.\n     */\n    Vector3D.prototype.vector3DPlus = function (v1, v2) {\n        return this.vector3D(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z);\n    };\n    /**\n     * Multiplies two vectors using the cross product and returns the result.\n     *\n     * @param {Chart3DVector} v1 - The first vector.\n     * @param {Chart3DVector} v2 - The second vector.\n     * @returns {Chart3DVector} - The resulting vector.\n     */\n    Vector3D.prototype.vector3DMultiply = function (v1, v2) {\n        var x = v1.y * v2.z - v2.y * v1.z;\n        var y = v1.z * v2.x - v2.z * v1.x;\n        var z = v1.x * v2.y - v2.x * v1.y;\n        return this.vector3D(x, y, z);\n    };\n    /**\n     * Calculates the dot product of two vectors.\n     *\n     * @param {Chart3DVector} v1 - The first vector.\n     * @param {Chart3DVector} v2 - The second vector.\n     * @returns {number} - The dot product.\n     */\n    Vector3D.prototype.vector3DAdd = function (v1, v2) {\n        return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;\n    };\n    /**\n     * Multiplies a vector by a scalar value.\n     *\n     * @param {Chart3DVector} v1 - The vector to multiply.\n     * @param {number} value - The scalar value.\n     * @returns {Chart3DVector} - The resulting vector.\n     */\n    Vector3D.prototype.vector3DStarMultiply = function (v1, value) {\n        var x = v1.x * value;\n        var y = v1.y * value;\n        var z = v1.z * value;\n        return this.vector3D(x, y, z);\n    };\n    /**\n     * Calculates the length of a vector.\n     *\n     * @param {Chart3DVector} vector - The vector to calculate the length of.\n     * @returns {number} - The length of the vector.\n     */\n    Vector3D.prototype.getLength = function (vector) {\n        var sqt = this.vector3DAdd(vector, vector);\n        return Math.sqrt(sqt);\n    };\n    /**\n     * Normalizes the vector to have a length of 1.\n     *\n     * @returns {void}\n     */\n    Vector3D.prototype.normalize = function () {\n        var length = this.getLength(this);\n        this.x /= length;\n        this.y /= length;\n        this.z /= length;\n    };\n    /**\n     * Calculates the normal vector of a triangle defined by three vectors.\n     *\n     * @param {Chart3DVector} v1 - The first vertex of the triangle.\n     * @param {Chart3DVector} v2 - The second vertex of the triangle.\n     * @param {Chart3DVector} v3 - The third vertex of the triangle.\n     * @returns {Chart3DVector} - The normal vector of the triangle.\n     */\n    Vector3D.prototype.getNormal = function (v1, v2, v3) {\n        var vector4 = this.vector3DMinus(v1, v2);\n        var vector5 = this.vector3DMinus(v3, v2);\n        var n = this.vector3DMultiply(vector4, vector5);\n        var length = this.getLength(n);\n        if (length < this.epsilon) {\n            return this.vector3D(0, 0, 0);\n        }\n        return this.vector3D(n.x / length, n.y / length, n.z / length);\n    };\n    return Vector3D;\n}());\nexport { Vector3D };\n/**\n * Represents a 3x3 or 4x4 matrix in 3D space and provides various matrix operations.\n *\n */\nvar Matrix3D = /** @class */ (function () {\n    function Matrix3D() {\n        /** The size of the matrix, which is set to 4 by default. */\n        this.matrixSize = 4;\n    }\n    /**\n     * Creates a 3D matrix with the specified size.\n     *\n     * @param {number} size - The size of the matrix.\n     * @returns {number[][]} - The created 3D matrix.\n     */\n    Matrix3D.prototype.matrix3D = function (size) {\n        var matrixData = [];\n        for (var i = 0; i < size; i++) {\n            matrixData[i] = this.createArray(size);\n        }\n        return matrixData;\n    };\n    /**\n     * Checks if a matrix is an affine matrix.\n     *\n     * @param {number[][]} matrixData - The matrix to check.\n     * @returns {boolean} - True if the matrix is an affine matrix, false otherwise.\n     */\n    Matrix3D.prototype.isAffine = function (matrixData) {\n        return matrixData[0][3] === 0 && matrixData[1][3] === 0 && matrixData[2][3] === 0 && matrixData[3][3] === 1;\n    };\n    /**\n     * Creates a new array with zeros.\n     *\n     * @param {number} initialSize - The size of the array.\n     * @returns {number[]} - The created array.\n     */\n    Matrix3D.prototype.createArray = function (initialSize) {\n        var matrixData = [];\n        for (var index = 0; index < initialSize; ++index) {\n            matrixData[index] = 0;\n        }\n        return matrixData;\n    };\n    /**\n     * Gets the identity matrix.\n     *\n     * @returns {number[][]} -The identity matrix.\n     */\n    Matrix3D.prototype.getIdentity = function () {\n        var matrixData = this.matrix3D(this.matrixSize);\n        for (var i = 0; i < this.matrixSize; i++) {\n            matrixData[i][i] = 1.0;\n        }\n        return matrixData;\n    };\n    /**\n     * Gets the interval of a matrix.\n     *\n     * @param {number[][]} matrix - The matrix to get the interval for.\n     * @returns {number[][]} - The interval matrix.\n     */\n    Matrix3D.prototype.getInterval = function (matrix) {\n        var matrixData = this.getIdentity();\n        for (var i = 0; i < this.matrixSize; i++) {\n            for (var j = 0; j < this.matrixSize; j++) {\n                matrixData[i][j] = this.getMinor(matrix, i, j);\n            }\n        }\n        matrixData = this.transposed(matrixData);\n        matrixData = this.getMatrixMultiple(1 / this.getDeterminant(matrix), matrixData);\n        return matrixData;\n    };\n    /**\n     * Multiplies all elements of a matrix by a factor.\n     *\n     * @param {number} factor - The factor to multiply with.\n     * @param {number[][]} matrix - The matrix to multiply.\n     * @returns {number[][]} - The resulting matrix.\n     */\n    Matrix3D.prototype.getMatrixMultiple = function (factor, matrix) {\n        for (var i = 0; i < matrix.length; i++) {\n            for (var j = 0; j < matrix[i].length; j++) {\n                matrix[i][j] = matrix[i][j] * factor;\n            }\n        }\n        return matrix;\n    };\n    /**\n     * Multiplies a matrix by a vector.\n     *\n     * @param {number[][]} matrix - The matrix.\n     * @param {Chart3DVector} point - The vector to multiply with.\n     * @returns {Chart3DVector} - The resulting vector.\n     */\n    Matrix3D.prototype.getMatrixVectorMultiple = function (matrix, point) {\n        var x = matrix[0][0] * point.x +\n            matrix[1][0] * point.y +\n            matrix[2][0] * point.z +\n            matrix[3][0];\n        var y = matrix[0][1] * point.x +\n            matrix[1][1] * point.y +\n            matrix[2][1] * point.z +\n            matrix[3][1];\n        var z = matrix[0][2] * point.x +\n            matrix[1][2] * point.y +\n            matrix[2][2] * point.z +\n            matrix[3][2];\n        if (!this.isAffine(matrix)) {\n            var c = 1 / (matrix[0][3] * point.x + matrix[1][3] * point.y + matrix[2][3] * point.z + matrix[3][3]);\n            x *= c;\n            y *= c;\n            z *= c;\n        }\n        return { x: x, y: y, z: z };\n    };\n    /**\n     * Multiplies a matrix by a vector and applies translation.\n     *\n     * @param {number[][]} matrix - The matrix.\n     * @param {Chart3DVector} vector - The vector to multiply with.\n     * @returns {Vector3D} - The resulting vector.\n     */\n    Matrix3D.prototype.getMatrixVectorAnd = function (matrix, vector) {\n        var x = matrix[0][0] * vector.x +\n            matrix[1][0] * vector.y +\n            matrix[2][0] * vector.z;\n        var y = matrix[0][1] * vector.x +\n            matrix[1][1] * vector.y +\n            matrix[2][1] * vector.z;\n        var z = matrix[0][2] * vector.x +\n            matrix[1][2] * vector.y +\n            matrix[2][2] * vector.z;\n        return new Vector3D(x, y, z);\n    };\n    /**\n     * Multiplies two matrices.\n     *\n     * @param {number[][]} matrix1 - The first matrix.\n     * @param {number[][]} matrix2 - The second matrix.\n     * @returns {number[][]} - The resulting matrix.\n     */\n    Matrix3D.prototype.getMatrixMultiplication = function (matrix1, matrix2) {\n        var result = this.getIdentity();\n        for (var i = 0; i < this.matrixSize; i++) {\n            for (var j = 0; j < this.matrixSize; j++) {\n                var value = 0;\n                for (var k = 0; k < this.matrixSize; k++) {\n                    value += matrix1[k][j] * matrix2[i][k];\n                }\n                result[i][j] = value;\n            }\n        }\n        return result;\n    };\n    /**\n     * Gets the minor of a matrix.\n     *\n     * @param {number[][]} matrix - The matrix.\n     * @param {number} columnIndex - The column index.\n     * @param {number} rowIndex - The row index.\n     * @returns {number} - The minor of the matrix.\n     * @private\n     */\n    Matrix3D.prototype.getMinor = function (matrix, columnIndex, rowIndex) {\n        return ((columnIndex + rowIndex) % 2 === 0 ? 1 : -1) * this.getDeterminant(this.getMatrix(matrix, columnIndex, rowIndex));\n    };\n    /**\n     * Gets a submatrix of a matrix.\n     *\n     * @param {number[][]} matrix - The matrix.\n     * @param {number} columnIndex - The column index.\n     * @param {number} rowIndex - The row index.\n     * @returns {number[][]} - The submatrix.\n     */\n    Matrix3D.prototype.getMatrix = function (matrix, columnIndex, rowIndex) {\n        var count = matrix.length - 1;\n        var subMatrix = this.createArray(count);\n        for (var i = 0; i < count; i++) {\n            var matrixColumn = i >= columnIndex ? i + 1 : i;\n            subMatrix[i] = this.createArray(count);\n            for (var j = 0; j < count; j++) {\n                var matrixRow = j >= rowIndex ? j + 1 : j;\n                subMatrix[i][j] = matrix[matrixColumn][matrixRow];\n            }\n        }\n        return subMatrix;\n    };\n    /**\n     * Gets the determinant of a matrix.\n     *\n     * @param {number[][]} matrix - The matrix.\n     * @returns {number} - The determinant of the matrix.\n     */\n    Matrix3D.prototype.getDeterminant = function (matrix) {\n        var count = matrix.length;\n        var determinant = 0;\n        if (count < 2) {\n            determinant = matrix[0][0];\n        }\n        else {\n            var k = 1;\n            for (var i = 0; i < count; i++) {\n                var submatrix = this.getMatrix(matrix, i, 0);\n                determinant += k * matrix[i][0] * this.getDeterminant(submatrix);\n                k = k > 0 ? -1 : 1;\n            }\n        }\n        return determinant;\n    };\n    /**\n     * Transforms a matrix by translation.\n     *\n     * @param {number} x - The x-coordinate of the translation.\n     * @param {number} y - The y-coordinate of the translation.\n     * @param {number} z - The z-coordinate of the translation.\n     * @returns {number[][]} - The transformed matrix.\n     */\n    Matrix3D.prototype.transform = function (x, y, z) {\n        var transformedMatrix = this.getIdentity();\n        transformedMatrix[3][0] = x;\n        transformedMatrix[3][1] = y;\n        transformedMatrix[3][2] = z;\n        return transformedMatrix;\n    };\n    /**\n     * Creates a matrix for rotation around the y-axis.\n     *\n     * @param {number} angle - The angle of rotation.\n     * @returns {number[][]} - The rotation matrix.\n     */\n    Matrix3D.prototype.turn = function (angle) {\n        var rotatedMatrix = this.getIdentity();\n        rotatedMatrix[0][0] = Math.cos(angle);\n        rotatedMatrix[2][0] = -Math.sin(angle);\n        rotatedMatrix[0][2] = Math.sin(angle);\n        rotatedMatrix[2][2] = Math.cos(angle);\n        return rotatedMatrix;\n    };\n    /**\n     * Creates a matrix for rotation around the x-axis.\n     *\n     * @param {number} angle - The angle of rotation.\n     * @returns {number[][]} - The rotation matrix.\n     */\n    Matrix3D.prototype.tilt = function (angle) {\n        var rotatedMatrix = this.getIdentity();\n        rotatedMatrix[1][1] = Math.cos(angle);\n        rotatedMatrix[2][1] = Math.sin(angle);\n        rotatedMatrix[1][2] = -Math.sin(angle);\n        rotatedMatrix[2][2] = Math.cos(angle);\n        return rotatedMatrix;\n    };\n    /**\n     * Transposes a matrix.\n     *\n     * @param {number[][]} matrix3D - The matrix to transpose.\n     * @returns {number[][]} - The transposed matrix.\n     */\n    Matrix3D.prototype.transposed = function (matrix3D) {\n        var transposedMatrix = this.getIdentity();\n        for (var i = 0; i < this.matrixSize; i++) {\n            for (var j = 0; j < this.matrixSize; j++) {\n                transposedMatrix[i][j] = matrix3D[j][i];\n            }\n        }\n        return transposedMatrix;\n    };\n    return Matrix3D;\n}());\nexport { Matrix3D };\n/**\n * Represents a 3D chart transformation utility that provides methods for transforming\n * and projecting 3D coordinates onto a 2D screen.\n *\n */\nvar ChartTransform3D = /** @class */ (function () {\n    /**\n     * Initializes a new instance of the `ChartTransform3D` class.\n     */\n    function ChartTransform3D() {\n        /** Represents the angle conversion factor from degrees to radians. */\n        this.toRadial = Math.PI / 180;\n        this.vector = new Vector3D(0, 0, 0);\n        this.matrixObj = new Matrix3D();\n    }\n    /**\n     * Creates a 3D transformation based on the specified size.\n     *\n     * @param {Size} size - The size of the viewing area.\n     * @returns {Chart3DBasicTransform} - The 3D transformation.\n     */\n    ChartTransform3D.prototype.transform3D = function (size) {\n        return {\n            viewingArea: size,\n            rotation: 0,\n            tilt: 0,\n            depth: 0,\n            perspectiveAngle: 0,\n            needUpdate: true,\n            centeredMatrix: this.matrixObj.getIdentity(),\n            perspective: this.matrixObj.getIdentity(),\n            resultMatrix: this.matrixObj.getIdentity(),\n            viewMatrix: this.matrixObj.getIdentity()\n        };\n    };\n    /**\n     * Applies the specified 3D transformation to the current state.\n     *\n     * @param {Chart3DBasicTransform} transform - The 3D transformation to apply.\n     * @returns {void} - The 3D transformation.\n     */\n    ChartTransform3D.prototype.transform = function (transform) {\n        this.setCenter(this.vector.vector3D(transform.viewingArea.width / 2, transform.viewingArea.height / 2, transform.depth / 2), transform);\n        this.setViewMatrix(this.matrixObj.transform(0, 0, transform.depth), transform);\n        this.setViewMatrix(this.matrixObj.getMatrixMultiplication(transform.viewMatrix, this.matrixObj.turn(-this.toRadial * transform.rotation)), transform);\n        this.setViewMatrix(this.matrixObj.getMatrixMultiplication(transform.viewMatrix, this.matrixObj.tilt(-this.toRadial * transform.tilt)), transform);\n        this.updatePerspective(transform.perspectiveAngle, transform);\n        transform.needUpdate = true;\n    };\n    /**\n     * Updates the perspective matrix based on the specified angle.\n     *\n     * @param {number} angle - The perspective angle.\n     * @param {Chart3DBasicTransform} transform - The 3D transformation.\n     * @returns {void}\n     */\n    ChartTransform3D.prototype.updatePerspective = function (angle, transform) {\n        var width = (((transform.viewingArea.width + transform.viewingArea.height) *\n            Math.tan(this.degreeToRadianConverter((180 - Math.abs(angle % 181)) / 2.0))) + (transform.depth * 2) / 2);\n        transform.perspective[0][0] = width;\n        transform.perspective[1][1] = width;\n        transform.perspective[2][3] = 1;\n        transform.perspective[3][3] = width;\n    };\n    /**\n     * Converts degrees to radians.\n     *\n     * @param {number} angle - The angle in degrees.\n     * @returns {number} - The angle in radians.\n     * @private\n     */\n    ChartTransform3D.prototype.degreeToRadianConverter = function (angle) {\n        return angle * Math.PI / 180;\n    };\n    /**\n     * Transforms a 3D vector to screen coordinates based on the current state.\n     *\n     * @param {Chart3DVector} vector3D - The 3D vector to transform.\n     * @param {Chart3DBasicTransform} transform - The 3D transformation.\n     * @param {Matrix3D} chartObj - Optional custom matrix object for transformation.\n     * @returns {Chart3DLocation} - The screen coordinates.\n     */\n    ChartTransform3D.prototype.toScreen = function (vector3D, transform, chartObj) {\n        if (!chartObj) {\n            transform.chartObj = this.matrixObj;\n            vector3D = this.matrixObj.getMatrixVectorMultiple(this.result(transform), vector3D);\n        }\n        else {\n            this.matrixObj = chartObj;\n            vector3D = chartObj.getMatrixVectorMultiple(this.result(transform, chartObj), vector3D);\n        }\n        return { x: vector3D.x, y: vector3D.y };\n    };\n    /**\n     * Sets the view matrix in the transformation state.\n     *\n     * @param {number[][]} matrix - The new view matrix.\n     * @param {Chart3DBasicTransform} transform - The 3D transformation.\n     * @returns {void}\n     */\n    ChartTransform3D.prototype.setViewMatrix = function (matrix, transform) {\n        if (transform.viewMatrix === matrix) {\n            return;\n        }\n        transform.viewMatrix = matrix;\n        transform.needUpdate = true;\n    };\n    /**\n     * Calculates the final result matrix based on the current state.\n     *\n     * @param {Chart3DBasicTransform} transform - The 3D transformation.\n     * @param {Matrix3D} matrixobj - Optional custom matrix object for transformation.\n     * @returns {number[][]} - The final result matrix.\n     */\n    ChartTransform3D.prototype.result = function (transform, matrixobj) {\n        var chartObj = transform.chartObj ? transform.chartObj : this.matrixObj;\n        if (!chartObj) {\n            chartObj = matrixobj;\n        }\n        if (!transform.needUpdate) {\n            return transform.resultMatrix;\n        }\n        var matrixObj = this.matrixObj ? this.matrixObj : matrixobj;\n        transform.resultMatrix = chartObj.getMatrixMultiplication(matrixObj.getInterval(transform.centeredMatrix), transform.perspective);\n        transform.resultMatrix = chartObj.getMatrixMultiplication(transform.resultMatrix, transform.viewMatrix);\n        transform.resultMatrix = chartObj.getMatrixMultiplication(transform.resultMatrix, transform.centeredMatrix);\n        transform.needUpdate = false;\n        return transform.resultMatrix;\n    };\n    /**\n     * Sets the center in the transformation state.\n     *\n     * @param {Chart3DVector} center - The new center vector.\n     * @param {Chart3DBasicTransform} transform - The 3D transformation.\n     * @returns {void}\n     */\n    ChartTransform3D.prototype.setCenter = function (center, transform) {\n        transform.centeredMatrix = this.matrixObj.transform(-center.x, -center.y, -center.z);\n        transform.needUpdate = true;\n    };\n    return ChartTransform3D;\n}());\nexport { ChartTransform3D };\n/**\n * Represents a 3D graphics rendering utility for drawing and managing 3D elements in a chart.\n *\n */\nvar Graphics3D = /** @class */ (function () {\n    function Graphics3D() {\n        /** The vector class. */\n        this.vector = new Vector3D(0, 0, 0);\n    }\n    /**\n     * Adds a visual polygon to the 3D chart and returns its identifier.\n     *\n     * @param {Chart3DPolygon} polygon - The polygon to add.\n     * @param {Chart3D} chart - The 3D chart.\n     * @returns {number} - The identifier of the added polygon.\n     */\n    Graphics3D.prototype.addVisual = function (polygon, chart) {\n        if (polygon == null || polygonObj.test()) {\n            return -1;\n        }\n        return bspTreeObj.add(polygon, chart);\n    };\n    /**\n     * Prepares the view for rendering based on specified parameters.\n     *\n     * @param {number} perspectiveAngle - The perspective angle.\n     * @param {number} depth - The depth of the view.\n     * @param {number} rotation - The rotation angle.\n     * @param {number} tilt - The tilt angle.\n     * @param {Size} size - The size of the viewing area.\n     * @param {Chart3D} chart - The 3D chart.\n     * @returns {void}\n     */\n    Graphics3D.prototype.prepareView = function (perspectiveAngle, depth, rotation, tilt, size, chart) {\n        if (chart3DRender.transform == null) {\n            chart3DRender.transform = chart.transform3D.transform3D(size);\n        }\n        else {\n            chart3DRender.transform.viewingArea = size;\n        }\n        if (!chart3DRender.tree) {\n            chart3DRender.tree = [];\n        }\n        chart3DRender.transform.rotation = rotation;\n        chart3DRender.transform.tilt = tilt;\n        chart3DRender.transform.depth = depth;\n        chart3DRender.transform.perspectiveAngle = perspectiveAngle;\n        chart.transform3D.transform(chart3DRender.transform);\n        chart3DRender.tree[chart.chart3D.id] = bspTreeObj.build();\n    };\n    /**\n     * Renders the 3D view on the specified panel element.\n     *\n     * @param {Element} panel - The panel element to render the view on.\n     * @param {Chart3D} chart - The 3D chart.\n     * @param {number} rotation - The rotation angle.\n     * @param {number} tilt - The tilt angle.\n     * @param {Size} size - The size of the viewing area.\n     * @param {number} perspectiveAngle - The perspective angle.\n     * @param {number} depth - The depth of the view.\n     * @returns {void}\n     */\n    Graphics3D.prototype.view = function (panel, chart, rotation, tilt, size, perspectiveAngle, depth) {\n        var MaxValue = 32767;\n        if (arguments.length === 2) {\n            if (panel == null) {\n                return;\n            }\n            var eyeVector = this.vector.vector3D(0, 0, MaxValue);\n            this.drawNode3D(chart3DRender.tree[chart.chart3D.id], eyeVector, panel, chart);\n        }\n        else {\n            if (panel == null) {\n                return;\n            }\n            if (chart3DRender.transform == null) {\n                chart3DRender.transform = chart.transform3D.transform3D(size);\n            }\n            else {\n                chart3DRender.transform.viewingArea = size;\n            }\n            chart3DRender.transform.rotation = rotation;\n            chart3DRender.transform.tilt = tilt;\n            chart3DRender.transform.depth = depth;\n            chart3DRender.transform.perspectiveAngle = perspectiveAngle;\n            chart.transform3D.transform(chart3DRender.transform);\n            var eye = this.vector.vector3D(0, 0, MaxValue);\n            this.drawNode3D(chart3DRender.tree[chart.chart3D.id], eye, panel, chart);\n        }\n    };\n    /**\n     * Draws a 3D element based on the specified Binary Space Partitioning Node.\n     *\n     * @param {Chart3DBspNode} bspElement - The Binary Space Partitioning Node representing the 3D element.\n     * @param {Chart3D} chart - The 3D chart.\n     * @returns {void}\n     */\n    Graphics3D.prototype.draw3DElement = function (bspElement, chart) {\n        if (bspElement.plane.element) {\n            if (bspElement.plane.element.tag === 'text' || bspElement.plane.element.tag === 'dataLabel') {\n                polygonObj.drawText(bspElement.plane, chart);\n            }\n            else if (bspElement.plane.element.tag === 'template') {\n                polygonObj.drawTemplate(bspElement.plane, chart);\n            }\n            else {\n                polygonObj.drawLine(bspElement.plane, chart);\n            }\n        }\n        else {\n            polygonObj.draw(bspElement.plane, chart);\n        }\n    };\n    /**\n     * Draws the 3D nodes starting from the root based on the eye vector.\n     *\n     * @param {Chart3DBspNode} bspElement - The root Binary Space Partitioning Node.\n     * @param {Chart3DVector} eyeVector - The eye vector.\n     * @param {Element} panel - The panel element to render the view on.\n     * @param {Chart3D} chart - The 3D chart.\n     * @returns {void}\n     */\n    Graphics3D.prototype.drawNode3D = function (bspElement, eyeVector, panel, chart) {\n        if (bspElement === null || chart3DRender.transform == null) {\n            return;\n        }\n        var isVector = true;\n        while (isVector) {\n            var r = vector.vector3DAdd(polygonObj.getNormal(chart.transform3D.result(chart3DRender.transform), bspElement.plane.vectorPoints), eyeVector);\n            if (r > bspElement.plane.d) {\n                if (bspElement.front != null) {\n                    this.drawNode3D(bspElement.front, eyeVector, panel, chart);\n                }\n                this.draw3DElement(bspElement, chart);\n                if (bspElement.back != null) {\n                    bspElement = bspElement.back;\n                    continue;\n                }\n            }\n            else {\n                if (bspElement.back != null) {\n                    this.drawNode3D(bspElement.back, eyeVector, panel, chart);\n                }\n                this.draw3DElement(bspElement, chart);\n                if (bspElement.front != null) {\n                    bspElement = bspElement.front;\n                    continue;\n                }\n            }\n            break;\n        }\n    };\n    return Graphics3D;\n}());\nexport { Graphics3D };\n/**\n * Represents a binary tree builder for 3D polygons in a chart.\n *\n */\nvar BinaryTreeBuilder = /** @class */ (function () {\n    function BinaryTreeBuilder(chart) {\n        /** A small value used for epsilon comparisons to handle floating-point inaccuracies.*/\n        this.epsilon = 0.0005;\n        this.chart = chart;\n    }\n    /**\n     * Adds a polygon to the binary tree and returns its index.\n     *\n     * @param {Chart3DPolygon} polygon - The polygon to add.\n     * @param {Chart3D} chart - The 3D chart.\n     * @returns {number} - The index of the added polygon.\n     */\n    BinaryTreeBuilder.prototype.add = function (polygon, chart) {\n        this.chart = chart;\n        chart.polygons.push(polygon);\n        return chart.polygons.length - 1;\n    };\n    /**\n     * Gets the next index considering the array length and the current index.\n     *\n     * @param {number} index - The current index.\n     * @param {number} count - The length of the array.\n     * @returns {number} - The next index.\n     */\n    BinaryTreeBuilder.prototype.getNext = function (index, count) {\n        if (index >= count) {\n            return index - count;\n        }\n        if (index < 0) {\n            return index + count;\n        }\n        return index;\n    };\n    /**\n     * Creates a PolyAttributes object based on the vector, index, and result.\n     *\n     * @param {Chart3DVector} point - The vector representing the point.\n     * @param {number} index - The index of the point.\n     * @param {string} result - The result classification.\n     * @returns {Chart3DPolyAttributes} - The created PolyAttributes object.\n     */\n    BinaryTreeBuilder.prototype.vector3DIndexClassification = function (point, index, result) {\n        return {\n            index: index,\n            result: result,\n            vector: point,\n            isCuttingBackPoint: false,\n            cuttingBackPairIndex: null,\n            alreadyCutBack: false,\n            isCuttingFrontPoint: false,\n            cuttingFrontPairIndex: null,\n            alreadyCutFront: false\n        };\n    };\n    /**\n     * Classifies a point relative to a polygon.\n     *\n     * @param {Chart3DVector} point - The point to classify.\n     * @param {Chart3DPolygon} polygon - The polygon for classification.\n     * @returns {string} - The classification result ('OnPlane', 'OnBack', 'OnFront').\n     */\n    BinaryTreeBuilder.prototype.classifyPoint = function (point, polygon) {\n        var result = 'OnPlane';\n        var signedDistance = -polygon.d - vector.vector3DAdd(point, polygon.normal);\n        if (signedDistance > this.epsilon) {\n            result = 'OnBack';\n        }\n        else if (signedDistance < -this.epsilon) {\n            result = 'OnFront';\n        }\n        return result;\n    };\n    /**\n     * Classifies a polygon relative to another polygon.\n     *\n     * @param {Chart3DPolygon} refPolygon - The reference polygon.\n     * @param {Chart3DPolygon} classPolygon - The polygon to classify.\n     * @returns {string} - The classification result ('OnPlane', 'ToRight', 'ToLeft', 'Unknown').\n     */\n    BinaryTreeBuilder.prototype.classifyPolygon = function (refPolygon, classPolygon) {\n        var result = 'Unknown';\n        var points = classPolygon.points;\n        if (points == null) {\n            return result;\n        }\n        var onBack = 0;\n        var onFront = 0;\n        var onPlane = 0;\n        var normal = refPolygon.normal;\n        var polygonValue = refPolygon.d;\n        for (var i = 0, len = points.length; i < len; i++) {\n            var value = -polygonValue - vector.vector3DAdd(points[i], normal);\n            if (value > this.epsilon) {\n                onBack++;\n            }\n            else if (value < -this.epsilon) {\n                onFront++;\n            }\n            else {\n                onPlane++;\n            }\n            if (onBack > 0 && onFront > 0) {\n                break;\n            }\n        }\n        if (onPlane === points.length) {\n            result = 'OnPlane';\n        }\n        else if (onFront + onPlane === points.length) {\n            result = 'ToRight';\n        }\n        else if (onBack + onPlane === points.length) {\n            result = 'ToLeft';\n        }\n        else {\n            result = 'Unknown';\n        }\n        return result;\n    };\n    /**\n     * Splits a polygon into two parts based on another polygon.\n     *\n     * @param {Chart3DPolygon} splitPolygon - The polygon to split.\n     * @param {Chart3DPolygon} refPolygon - The reference polygon for splitting.\n     * @returns {Chart3DPolyCollections} - The resulting back and front parts.\n     * @private\n     */\n    BinaryTreeBuilder.prototype.splitPolygon = function (splitPolygon, refPolygon) {\n        var backPoint = [];\n        var frontPoint = [];\n        if (splitPolygon.points != null) {\n            var polyPoints = [];\n            var backPartPoints = [];\n            var frontPartPoints = [];\n            var outputs = void 0;\n            var inputs = void 0;\n            var count = splitPolygon.points.length;\n            for (var i = 0; i < count; i++) {\n                var pointB = splitPolygon.points[i];\n                var pointC = splitPolygon.points[this.getNext(i + 1, count)];\n                var sideB = this.classifyPoint(pointB, refPolygon);\n                var sideC = this.classifyPoint(pointC, refPolygon);\n                var attributeB = this.vector3DIndexClassification(pointB, polyPoints.length, sideB);\n                polyPoints.push(attributeB);\n                if (sideB !== sideC && sideB !== 'OnPlane' && sideC !== 'OnPlane') {\n                    var vectorValue = vector.vector3DMinus(pointB, pointC);\n                    var direction = vector.vector3DMinus(vector.vector3DStarMultiply(refPolygon.normal, -refPolygon.d), pointC);\n                    var signedDistance = vector.vector3DAdd(direction, refPolygon.normal);\n                    var intersectionParameter = signedDistance / vector.vector3DAdd(refPolygon.normal, vectorValue);\n                    var intersectionPoint = vector.vector3DPlus(pointC, vector.vector3DStarMultiply(vectorValue, intersectionParameter));\n                    var attributeIntersection = this.vector3DIndexClassification(intersectionPoint, polyPoints.length, 'OnPlane');\n                    polyPoints.push(attributeIntersection);\n                    backPartPoints.push(attributeIntersection);\n                    frontPartPoints.push(attributeIntersection);\n                }\n                else if (sideB === 'OnPlane') {\n                    var pointA = splitPolygon.points[this.getNext(i - 1, count)];\n                    var sideA = this.classifyPoint(pointA, refPolygon);\n                    if (sideA === sideC) {\n                        continue;\n                    }\n                    if (sideA !== 'OnPlane' && sideC !== 'OnPlane') {\n                        backPartPoints.push(attributeB);\n                        frontPartPoints.push(attributeB);\n                    }\n                    else if (sideA === 'OnPlane') {\n                        switch (sideC) {\n                            case 'OnBack':\n                                backPartPoints.push(attributeB);\n                                break;\n                            case 'OnFront':\n                                frontPartPoints.push(attributeB);\n                                break;\n                        }\n                    }\n                    else if (sideC === 'OnPlane') {\n                        switch (sideA) {\n                            case 'OnBack':\n                                backPartPoints.push(attributeB);\n                                break;\n                            case 'OnFront':\n                                frontPartPoints.push(attributeB);\n                                break;\n                        }\n                    }\n                }\n            }\n            if (frontPartPoints.length !== 0 || backPartPoints.length !== 0) {\n                for (var i = 0; i < backPartPoints.length - 1; i += 2) {\n                    var backAttribute1 = backPartPoints[i];\n                    var backAttribute2 = backPartPoints[i + 1];\n                    backAttribute1.cuttingBackPoint = true;\n                    backAttribute2.cuttingBackPoint = true;\n                    backAttribute1.alterCuttingBackPairIndex = backAttribute2.index;\n                    backAttribute2.alterCuttingBackPairIndex = backAttribute1.index;\n                }\n                for (var i = 0; i < frontPartPoints.length - 1; i += 2) {\n                    var frontAttribute1 = frontPartPoints[i];\n                    var frontAttribute2 = frontPartPoints[i + 1];\n                    frontAttribute1.cuttingFrontPoint = true;\n                    frontAttribute2.cuttingFrontPoint = true;\n                    frontAttribute1.alterCuttingFrontPairIndex = frontAttribute2.index;\n                    frontAttribute2.alterCuttingFrontPairIndex = frontAttribute1.index;\n                }\n                for (var i = 0; i < backPartPoints.length - 1; i++) {\n                    var backAttribute1 = backPartPoints[i];\n                    if (backAttribute1.alreadyCutBack) {\n                        continue;\n                    }\n                    outputs = this.cutOutBackPolygon(polyPoints, backAttribute1);\n                    if (outputs.length > 2) {\n                        var polygon1 = polygonObj.polygon3D(outputs, splitPolygon);\n                        backPoint.push(__assign({}, polygon1));\n                    }\n                }\n                for (var i = 0; i < frontPartPoints.length - 1; i++) {\n                    var backAttribute2 = frontPartPoints[i];\n                    if (backAttribute2.alreadyCutFront) {\n                        continue;\n                    }\n                    inputs = this.cutOutFrontPolygon(polyPoints, backAttribute2);\n                    if (inputs.length > 2) {\n                        var polygon2 = polygonObj.polygon3D(inputs, splitPolygon);\n                        frontPoint.push(__assign({}, polygon2));\n                    }\n                }\n            }\n        }\n        else {\n            backPoint.push(splitPolygon);\n            frontPoint.push(splitPolygon);\n        }\n        return { backPolygon: backPoint, frontPolygon: frontPoint };\n    };\n    /**\n     * Cuts out the front part of a polygon based on the PolyAttributes.\n     *\n     * @param {Chart3DPolyAttributes[]} polyPoints - The PolyAttributes array of the polygon.\n     * @param {Chart3DPolyAttributes} initialVertex - The PolyAttributes representing the cutting point.\n     * @returns {Chart3DVector[]} - The resulting points of the front part.\n     */\n    BinaryTreeBuilder.prototype.cutOutFrontPolygon = function (polyPoints, initialVertex) {\n        var points = [];\n        var currentVertex = initialVertex;\n        var isVector = true;\n        while (isVector) {\n            currentVertex.alreadyCutFront = true;\n            points.push(currentVertex.vector);\n            var currentVertexPair = polyPoints[currentVertex.alterCuttingFrontPairIndex];\n            if (currentVertex.cuttingFrontPoint) {\n                if (!currentVertexPair.alreadyCutFront) {\n                    currentVertex = currentVertexPair;\n                }\n                else {\n                    var previousVertexOnBack = polyPoints[this.getNext(currentVertex.index - 1, polyPoints.length)];\n                    var nextVertexOnBack = polyPoints[this.getNext(currentVertex.index + 1, polyPoints.length)];\n                    if (previousVertexOnBack.result === 'OnFront' && !previousVertexOnBack.alreadyCutFront) {\n                        currentVertex = previousVertexOnBack;\n                    }\n                    else if (nextVertexOnBack.result === 'OnFront' && !nextVertexOnBack.alreadyCutFront) {\n                        currentVertex = nextVertexOnBack;\n                    }\n                    else {\n                        return points;\n                    }\n                }\n            }\n            else {\n                var previousVertexOnBack = polyPoints[this.getNext(currentVertex.index - 1, polyPoints.length)];\n                var nextVertexOnBack = polyPoints[this.getNext(currentVertex.index + 1, polyPoints.length)];\n                if (previousVertexOnBack.result !== 'OnBack' && !previousVertexOnBack.alreadyCutFront) {\n                    currentVertex = previousVertexOnBack;\n                }\n                else if (nextVertexOnBack.result !== 'OnBack' && !nextVertexOnBack.alreadyCutFront) {\n                    currentVertex = nextVertexOnBack;\n                }\n                else {\n                    return points;\n                }\n            }\n        }\n        return null;\n    };\n    /**\n     * Cuts out the back part of a polygon based on the PolyAttributes.\n     *\n     * @param {Chart3DPolyAttributes[]} polyPoints - The PolyAttributes array of the polygon.\n     * @param {Chart3DPolyAttributes} initialVertex - The PolyAttributes representing the cutting point.\n     * @returns {Chart3DVector[]} - The resulting points of the back part.\n     */\n    BinaryTreeBuilder.prototype.cutOutBackPolygon = function (polyPoints, initialVertex) {\n        var points = [];\n        var currentVertex = initialVertex;\n        var isVector = true;\n        while (isVector) {\n            currentVertex.alreadyCutBack = true;\n            points.push(currentVertex.vector);\n            var currentVertexPair = polyPoints[currentVertex.alterCuttingBackPairIndex];\n            if (currentVertex.cuttingBackPoint) {\n                if (!currentVertexPair.alreadyCutBack) {\n                    currentVertex = currentVertexPair;\n                }\n                else {\n                    var previousVertexOnBack = polyPoints[this.getNext(currentVertex.index - 1, polyPoints.length)];\n                    var nextVertexOnBack = polyPoints[this.getNext(currentVertex.index + 1, polyPoints.length)];\n                    if (previousVertexOnBack.result === 'OnBack' && !previousVertexOnBack.alreadyCutBack) {\n                        currentVertex = previousVertexOnBack;\n                    }\n                    else if (nextVertexOnBack.result === 'OnBack' && !nextVertexOnBack.alreadyCutBack) {\n                        currentVertex = nextVertexOnBack;\n                    }\n                    else {\n                        return points;\n                    }\n                }\n            }\n            else {\n                var previousVertexOnBack = polyPoints[this.getNext(currentVertex.index - 1, polyPoints.length)];\n                var nextVertexOnBack = polyPoints[this.getNext(currentVertex.index + 1, polyPoints.length)];\n                if (previousVertexOnBack.result !== 'OnFront' && !previousVertexOnBack.alreadyCutBack) {\n                    currentVertex = previousVertexOnBack;\n                }\n                else if (nextVertexOnBack.result !== 'OnFront' && !nextVertexOnBack.alreadyCutBack) {\n                    currentVertex = nextVertexOnBack;\n                }\n                else {\n                    return points;\n                }\n            }\n        }\n        return null;\n    };\n    /**\n     * Builds a Binary Space Partitioning from a list of polygons.\n     *\n     * @param {Chart3DPolygon[]} [points] - The list of polygons to build the tree from.\n     * @returns {Chart3DBspNode} - The root node of the Binary Space Partitioning tree.\n     */\n    BinaryTreeBuilder.prototype.build = function (points) {\n        if (!points) {\n            return this.build(this.chart.polygons);\n        }\n        else {\n            var inputPolygons = points;\n            if (inputPolygons.length < 1) {\n                return null;\n            }\n            var bspNode = { back: null, front: null, plane: null };\n            var plane = inputPolygons[0];\n            bspNode.plane = plane;\n            var polygonsToLeft = [];\n            var polygonsToRight = [];\n            for (var i = 1, len = inputPolygons.length; i < len; i++) {\n                var currentPolygon = inputPolygons[i];\n                if (currentPolygon === plane) {\n                    continue;\n                }\n                var classificationResult = this.classifyPolygon(plane, currentPolygon);\n                switch (classificationResult) {\n                    case 'OnPlane':\n                    case 'ToRight':\n                        polygonsToRight.push(currentPolygon);\n                        break;\n                    case 'ToLeft':\n                        polygonsToLeft.push(currentPolygon);\n                        break;\n                    case 'Unknown':\n                        if (currentPolygon.element && (currentPolygon.element.tag === 'line' || currentPolygon.element.tag === 'text')) {\n                            polygonsToLeft.push(currentPolygon);\n                        }\n                        else {\n                            var result = this.splitPolygon(currentPolygon, plane);\n                            for (var k = 0; k < result.backPolygon.length; k++) {\n                                result.backPolygon[k].name = result.backPolygon[k].name + '-back';\n                                polygonsToLeft.push(result.backPolygon[k]);\n                            }\n                            for (var j = 0; j < result.frontPolygon.length; j++) {\n                                result.frontPolygon[j].name = result.frontPolygon[j].name + '-front';\n                                polygonsToRight.push(result.frontPolygon[j]);\n                            }\n                        }\n                        break;\n                }\n            }\n            if (polygonsToLeft.length > 0) {\n                bspNode.back = this.build(polygonsToLeft);\n            }\n            if (polygonsToRight.length > 0) {\n                bspNode.front = this.build(polygonsToRight);\n            }\n            return bspNode;\n        }\n    };\n    return BinaryTreeBuilder;\n}());\nexport { BinaryTreeBuilder };\n/**\n * The Svg3DRenderer class provides methods for rendering SVG graphics in a 3D context.\n */\nvar Svg3DRenderer = /** @class */ (function () {\n    function Svg3DRenderer() {\n    }\n    /**\n     * Gets a Chart3DStringBuilder instance for constructing strings.\n     *\n     * @returns {Chart3DStringBuilder} - The StringBuilder instance.\n     */\n    Svg3DRenderer.prototype.getStringBuilder = function () {\n        var data = [];\n        var counter = 0;\n        return {\n            append: function (text) {\n                data[counter++] = text;\n                return this;\n            },\n            remove: function (i, j) {\n                data.splice(i, j || 1);\n                return this;\n            },\n            insert: function (i, text) {\n                data.splice(i, 0, text);\n                return this;\n            },\n            toString: function (text) {\n                return data.join(text || '');\n            }\n        };\n    };\n    /**\n     * Parses a hex color code and returns its Red green Blue values.\n     *\n     * @param {string} hexColorCode - The hex color code.\n     * @returns {Chart3DColorFormat | null} - The parsed color format (Red green Blue) or null if parsing fails.\n     */\n    Svg3DRenderer.prototype.hexToValue = function (hexColorCode) {\n        var result;\n        var values;\n        if (hexColorCode.indexOf('rgba(') === 0) {\n            values = hexColorCode.slice(5, -1).split(',');\n            return values ? {\n                red: parseInt(values[0], 10),\n                green: parseInt(values[1], 10),\n                blue: parseInt(values[2], 10),\n                alpha: parseFloat(values[3])\n            } : null;\n        }\n        else if (hexColorCode.indexOf('rgb(') === 0) {\n            values = hexColorCode.slice(4, -1).split(',');\n            return values ? {\n                red: parseInt(values[0], 10),\n                green: parseInt(values[1], 10),\n                blue: parseInt(values[2], 10)\n            } : null;\n        }\n        else {\n            result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hexColorCode);\n            return result\n                ? {\n                    red: parseInt(result[1], 16),\n                    green: parseInt(result[2], 16),\n                    blue: parseInt(result[3], 16)\n                }\n                : null;\n        }\n    };\n    /**\n     * Converts a Chart3DColorFormat object to its corresponding color string.\n     *\n     * @param {Chart3DColorFormat} color - The color in Chart3DColorFormat.\n     * @returns {string} - The color string representation.\n     */\n    Svg3DRenderer.prototype.hexColor = function (color) {\n        var redValue = color.red;\n        var greenValue = color.green;\n        var blueValue = color.blue;\n        if (color.alpha) {\n            var returnColor = \"rgba(\" + redValue.toString() + \",\" + greenValue.toString() + \",\" + blueValue.toString() + \",\" + color.alpha + \")\";\n            return returnColor;\n        }\n        else {\n            var hex_1 = [redValue.toString(16), greenValue.toString(16), blueValue.toString(16)];\n            hex_1.forEach(function (val, nr) {\n                if (val.length === 1) {\n                    hex_1[nr] = '0' + val;\n                }\n            });\n            return '#' + hex_1.join('').toUpperCase();\n        }\n    };\n    /**\n     * Checks if a given color string is in a valid format (hex or rgba).\n     *\n     * @param {string} color - The color string to check.\n     * @returns {boolean} - True if the color string is valid, otherwise false.\n     */\n    Svg3DRenderer.prototype.checkColorFormat = function (color) {\n        if (color.indexOf('rgba(') === 0 || color.indexOf('rgb(') === 0) {\n            var rgbaValues = color.substring(color.indexOf('(') + 1, color.lastIndexOf(')')).split(',');\n            if (rgbaValues.length === 3 || rgbaValues.length === 4) {\n                return rgbaValues.every(function (val) {\n                    var num = parseFloat(val);\n                    return !isNaN(num) && num >= 0 && num <= 255;\n                });\n            }\n        }\n        else if (color.indexOf('#') === 0) {\n            var hex = color.substring(1);\n            return (hex.length === 3 || hex.length === 6) && /^[0-9A-Fa-f]{3,6}$/.test(hex);\n        }\n        return false;\n    };\n    /**\n     * Draws text on an SVG element.\n     *\n     * @param {any} options - The options for drawing the text.\n     * @param {string | string[]} label - The text label.\n     * @param {FontModel} font - The font settings for the text.\n     * @param {Chart3D} chart - The 3D chart instance.\n     * @returns {Element} - The created SVG text element.\n     */\n    Svg3DRenderer.prototype.drawText = function (options, label, font, chart) {\n        var text = document.getElementById(options.id);\n        if (text === null) {\n            text = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n        }\n        if (label.length > 1 && typeof label !== 'string') {\n            var dy = 0;\n            for (var i = 0; i < label.length; i++) {\n                var tspanElement = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');\n                tspanElement.textContent = label[i];\n                tspanElement.setAttribute('x', String(options.x));\n                tspanElement.setAttribute('dy', String(dy));\n                text.appendChild(tspanElement);\n                dy = measureText(label[i], font, chart.themeStyle.axisLabelFont).height;\n            }\n        }\n        else {\n            text.textContent = label;\n        }\n        text = chart.svgRenderer.setElementAttributes(options, text);\n        return text;\n    };\n    /**\n     * Transforms 3D coordinates to visible 2D coordinates on the chart.\n     *\n     * @param {Chart3DSeries} currentSeries - The current 3D series.\n     * @param {number} x - The x-coordinate in 3D space.\n     * @param {number} y - The y-coordinate in 3D space.\n     * @param {Chart3D} chart - The 3D chart instance.\n     * @returns {Chart3DLocation} - The transformed 2D coordinates.\n     */\n    Svg3DRenderer.prototype.transform3DToVisible = function (currentSeries, x, y, chart) {\n        if (currentSeries.xAxis != null && currentSeries.yAxis != null) {\n            var valueType = currentSeries.xAxis.valueType;\n            var xlogarithmicBase = 10; // Replace with the actual logarithmic base if needed\n            var xIsLogarithmic = valueType === 'Logarithmic';\n            // Apply logarithmic transformation if necessary\n            if (xIsLogarithmic && x > 0) {\n                x = Math.log(x) / Math.log(xlogarithmicBase);\n            }\n            var ylogarithmicBase = currentSeries.yAxis.logBase;\n            var yIsLogarithmic = currentSeries.yAxis.valueType === 'Logarithmic';\n            // Apply logarithmic transformation if necessary\n            if (yIsLogarithmic && y > 0) {\n                y = Math.log(y) / Math.log(ylogarithmicBase);\n            }\n            // Adjust the coordinates based on inverted axes\n            if (chart.requireInvertedAxis) {\n                var left = chart.chartAxisLayoutPanel.seriesClipRect.x;\n                var top_1 = chart.chartAxisLayoutPanel.seriesClipRect.y;\n                var pointX = left + currentSeries.yAxis.rect.width * valueToCoefficients(y, currentSeries.yAxis);\n                var pointY = top_1 + currentSeries.xAxis.rect.height * (1 - valueToCoefficients(x, currentSeries.xAxis));\n                return { x: pointX, y: pointY };\n            }\n            else {\n                var left = currentSeries.xAxis.rect.x;\n                var top_2 = currentSeries.yAxis.rect.y;\n                var newX = left + Math.round(currentSeries.xAxis.rect.width * valueToCoefficients(x, currentSeries.xAxis));\n                var newY = top_2 + Math.round(currentSeries.yAxis.rect.height * (1 - valueToCoefficients(y, currentSeries.yAxis)));\n                return { x: newX, y: newY };\n            }\n        }\n        // Return a default Point if xAxis and yAxis are null\n        return { x: 0, y: 0 };\n    };\n    return Svg3DRenderer;\n}());\nexport { Svg3DRenderer };\n/**\n * Represents a 3D polygon in a chart.\n *\n */\nvar Polygon3D = /** @class */ (function () {\n    function Polygon3D() {\n        /** A small constant used for numerical comparisons. */\n        this.epsilon = 0.00001;\n        /** A small constant used for numerical comparisons. */\n        this.normal = { x: 0, y: 0, z: 0 };\n        /** A small constant used for numerical comparisons. */\n        this.vector = new Vector3D(0, 0, 0);\n        /** A small constant used for numerical comparisons. */\n        this.vectorPoints = [];\n        /** A small constant used for numerical comparisons. */\n        this.matrixObj = new Matrix3D();\n        /** A small constant used for numerical comparisons. */\n        this.tabIndex = true;\n    }\n    /**\n     * Creates a 3D polygon.\n     *\n     * @param {Chart3DVector[]} [points] - An array of 3D vectors representing points on the polygon.\n     * @param {any} [tag] - Additional information or metadata for the polygon.\n     * @param {number} [index] - An index associated with the polygon.\n     * @param {string} [stroke] - The stroke color of the polygon.\n     * @param {number} [strokeThickness] - The thickness of the polygon's stroke.\n     * @param {number} [opacity] - The opacity of the polygon.\n     * @param {string} [fill] - The fill color of the polygon.\n     * @param {string} [name] - The name or identifier of the polygon.\n     * @param {Element} [parent] - The parent element to which the polygon belongs.\n     * @param {string} [text] - Additional text associated with the polygon.\n     * @returns {Chart3DPolygon} - Returns the created polygon.\n     */\n    Polygon3D.prototype.polygon3D = function (points, tag, index, stroke, strokeThickness, opacity, fill, name, parent, text) {\n        if (arguments.length === 3) {\n            this.calculateNormal(points, tag, index);\n            return null;\n        }\n        else if (arguments.length === 2) {\n            //points = arguments[0];\n            this.calculateNormal(points[0], points[1], points[2]);\n            this.vectorPoints = points;\n            this.calculateNormal(this.vectorPoints);\n            var polygon = tag;\n            polygon.normal = this.normal;\n            polygon.points = points;\n            polygon.vectorPoints = this.vectorPoints;\n            polygon.isSplit = true;\n            polygon.d = this.d;\n            return polygon;\n        }\n        else {\n            this.calculateNormal(points[0], points[1], points[2]);\n            this.vectorPoints = points;\n            this.calculateNormal(this.vectorPoints);\n            var element = { tag: 'path', parent: parent };\n            var polygon = {\n                normal: this.normal,\n                points: points,\n                vectorPoints: this.vectorPoints,\n                index: index,\n                tag: tag,\n                name: name ? name : null,\n                strokeThickness: strokeThickness,\n                opacity: opacity,\n                fill: fill,\n                d: this.d,\n                text: text ? text : '',\n                polygonElement: element\n            };\n            if (arguments.length !== 1) {\n                polygon.polygonElement = element;\n            }\n            return polygon;\n        }\n    };\n    /**\n     * Creates a 3D line.\n     *\n     * @param {Chart3DTickElement} line - The tick elements associated with the line.\n     * @param {number} x1 - The x-coordinate of the starting point.\n     * @param {number} y1 - The y-coordinate of the starting point.\n     * @param {number} x2 - The x-coordinate of the ending point.\n     * @param {number} y2 - The y-coordinate of the ending point.\n     * @param {number} depth - The depth or z-coordinate of the line in 3D space.\n     * @returns {Chart3DPolygon} - Returns the created 3D line as a polygon.\n     */\n    Polygon3D.prototype.createLine = function (line, x1, y1, x2, y2, depth) {\n        var strokeThickness = line.width;\n        var vectorCollection = [];\n        vectorCollection[0] = this.vector.vector3D(x1, y1, depth);\n        vectorCollection[1] = this.vector.vector3D(x1 + strokeThickness, y2 + strokeThickness, depth);\n        vectorCollection[2] = this.vector.vector3D(x2, y2, depth);\n        return this.line3D(line, vectorCollection);\n    };\n    /**\n     *  Creates a 3D line polygon based on the given tick elements and points.\n     *\n     * @param {Chart3DTickElement} element - The tick elements associated with the line.\n     * @param {Chart3DVector[]} points - The array of 3D vector points defining the line in 3D space.\n     * @returns {Chart3DPolygon} - Returns the created 3D line polygon.\n     */\n    Polygon3D.prototype.line3D = function (element, points) {\n        var plane = this.polygon3D(points);\n        plane.element = element;\n        return plane;\n    };\n    /**\n     * Creates a 3D text polygon based on the given label element and points.\n     *\n     * @param {Chart3DLabelElement} element - The label element associated with the text.\n     * @param {Chart3DVector[]} points - The array of 3D vector points defining the position of the text in 3D space.\n     * @returns {Chart3DPolygon} - Returns the created 3D text polygon.\n     */\n    Polygon3D.prototype.text3D = function (element, points) {\n        var plane = this.polygon3D(points);\n        plane.element = element;\n        return plane;\n    };\n    /**\n     * Creates a 3D cylinder based on the given vectors, chart, and styling parameters.\n     *\n     * @param {Chart3DVector} v1 - The start vector of the cylinder.\n     * @param {Chart3DVector} v2 - The end vector of the cylinder.\n     * @param {Chart3D} chart - The 3D chart to which the cylinder belongs.\n     * @param {number} index - The index of the cylinder.\n     * @param {string} type - The type of the cylinder.\n     * @param {string} stroke - The stroke color of the cylinder.\n     * @param {string} fill - The fill color of the cylinder.\n     * @param {number} strokeThickness - The thickness of the stroke.\n     * @param {number} opacity - The opacity of the cylinder.\n     * @param {string} name - The name of the cylinder.\n     * @param {Element} parent - The parent element of the cylinder.\n     * @returns {Chart3DPolygon[]} - Returns an array of polygons representing the 3D cylinder.\n     */\n    Polygon3D.prototype.createCylinder = function (v1, //top left front vecotr.\n    v2, // bottom right back vector.\n    chart, index, type, stroke, fill, strokeThickness, opacity, name, parent) {\n        var i = 0; //cylinder path count.\n        var offsetX;\n        var offsetY;\n        var offsetZ;\n        var vectorCollection;\n        var pathCount = 24;\n        var theta = 360 / pathCount;\n        var degreeToRadian = Math.PI / 180;\n        var centerZ = (v1.z + v2.z) / 2;\n        var result = [];\n        var outPoints = [];\n        var topVector = [];\n        var bottomVector = [];\n        var radiusB = (v2.y - v1.y) < (v2.z - v1.z) ? (v2.y - v1.y) / 2 : (v2.z - v1.z) / 2;\n        var radiusC = (v2.x - v1.x) < (v2.z - v1.z) ? (v2.x - v1.x) / 2 : (v2.z - v1.z) / 2;\n        var centerX = (v1.x + v2.x) / 2;\n        var centerY = (v1.y + v2.y) / 2;\n        switch (type) {\n            case 'Bar':\n            case 'StackingBar':\n            case 'StackingBar100':\n                pathCount++;\n                while (pathCount--) {\n                    offsetY = centerY + radiusB * Math.cos((i * theta) * degreeToRadian);\n                    offsetZ = centerZ + radiusB * Math.sin((i * theta) * degreeToRadian);\n                    outPoints[i] = { Y: offsetY, Z: offsetZ };\n                    topVector.push(this.vector.vector3D(v1.x, outPoints[i].Y, outPoints[i].Z));\n                    bottomVector.push(this.vector.vector3D(v2.x, outPoints[i].Y, outPoints[i].Z));\n                    if (i > 0) {\n                        vectorCollection = [\n                            this.vector.vector3D(v1.x, outPoints[i - 1].Y, outPoints[i - 1].Z),\n                            this.vector.vector3D(v2.x, outPoints[i - 1].Y, outPoints[i - 1].Z),\n                            this.vector.vector3D(v2.x, outPoints[i].Y, outPoints[i].Z),\n                            this.vector.vector3D(v1.x, outPoints[i].Y, outPoints[i].Z)\n                        ];\n                        result[i + 1] = this.polygon3D(vectorCollection, chart, index, fill, 0, opacity, fill, ('-' + (i + 1).toString() + '-' + name), parent);\n                        graphics.addVisual(result[i + 1], chart);\n                    }\n                    i++;\n                }\n                break;\n            case 'Column':\n            case 'StackingColumn':\n            case 'StackingColumn100':\n                pathCount++;\n                while (pathCount--) {\n                    offsetX = centerX + radiusC * Math.cos((i * theta) * degreeToRadian);\n                    offsetZ = centerZ + radiusC * Math.sin((i * theta) * degreeToRadian);\n                    outPoints[i] = { Y: offsetX, Z: offsetZ };\n                    topVector.push(this.vector.vector3D(outPoints[i].Y, v1.y, outPoints[i].Z));\n                    bottomVector.push(this.vector.vector3D(outPoints[i].Y, v2.y, outPoints[i].Z));\n                    if (i > 0) {\n                        vectorCollection = [\n                            this.vector.vector3D(outPoints[i - 1].Y, v1.y, outPoints[i - 1].Z),\n                            this.vector.vector3D(outPoints[i - 1].Y, v2.y, outPoints[i - 1].Z),\n                            this.vector.vector3D(outPoints[i].Y, v2.y, outPoints[i].Z),\n                            this.vector.vector3D(outPoints[i].Y, v1.y, outPoints[i].Z)\n                        ];\n                        result[i + 1] = this.polygon3D(vectorCollection, chart, index, fill, 0, opacity, fill, '-' + (i + 1).toString() + '-' + name, parent);\n                        graphics.addVisual(result[i + 1], chart);\n                    }\n                    i++;\n                }\n                break;\n        }\n        result[0] = this.polygon3D(bottomVector, chart, index, stroke, 0, opacity, fill, '-0-' + name, parent);\n        result[1] = this.polygon3D(topVector, chart, index, stroke, strokeThickness, opacity, fill, '-1-' + name, parent);\n        graphics.addVisual(result[0], chart);\n        graphics.addVisual(result[1], chart);\n        return result;\n    };\n    /**\n     * Creates a 3D box based on the given vectors, chart, and styling parameters.\n     *\n     * @param {Chart3DVector} v1 - The start vector of the box.\n     * @param {Chart3DVector} v2 - The end vector of the box.\n     * @param {Chart3D} chart - The 3D chart to which the box belongs.\n     * @param {number} index - The index of the box.\n     * @param {string} stroke - The stroke color of the box.\n     * @param {string} fill - The fill color of the box.\n     * @param {number} strokeThickness - The thickness of the stroke.\n     * @param {number} opacity - The opacity of the box.\n     * @param {boolean} inverse - A boolean indicating whether to inverse the box.\n     * @param {string} name - The name of the box.\n     * @param {Element} parent - The parent element of the box.\n     * @param {string} [text] - Optional text associated with the box.\n     * @returns {Chart3DPolygon[]} - Returns an array of polygons representing the 3D box.\n     *\n     */\n    Polygon3D.prototype.createBox = function (v1, //top left front vecotr.\n    v2, // bottom right back vector.\n    chart, index, stroke, fill, strokeThickness, opacity, inverse, name, parent, text) {\n        var result = [];\n        var point1 = [\n            this.vector.vector3D(v1.x, v1.y, v1.z),\n            this.vector.vector3D(v2.x, v1.y, v1.z),\n            this.vector.vector3D(v2.x, v2.y, v1.z),\n            this.vector.vector3D(v1.x, v2.y, v1.z)\n        ];\n        var point2 = [\n            this.vector.vector3D(v1.x, v1.y, v2.z),\n            this.vector.vector3D(v2.x, v1.y, v2.z),\n            this.vector.vector3D(v2.x, v2.y, v2.z),\n            this.vector.vector3D(v1.x, v2.y, v2.z)\n        ];\n        var point3 = [\n            this.vector.vector3D(v1.x, v1.y, v2.z),\n            this.vector.vector3D(v2.x, v1.y, v2.z),\n            this.vector.vector3D(v2.x, v1.y, v1.z),\n            this.vector.vector3D(v1.x, v1.y, v1.z)\n        ];\n        var point4 = [\n            this.vector.vector3D(v1.x, v2.y, v2.z),\n            this.vector.vector3D(v2.x, v2.y, v2.z),\n            this.vector.vector3D(v2.x, v2.y, v1.z),\n            this.vector.vector3D(v1.x, v2.y, v1.z)\n        ];\n        var point5 = [\n            this.vector.vector3D(v1.x, v1.y, v1.z),\n            this.vector.vector3D(v1.x, v1.y, v2.z),\n            this.vector.vector3D(v1.x, v2.y, v2.z),\n            this.vector.vector3D(v1.x, v2.y, v1.z)\n        ];\n        var point6 = [\n            this.vector.vector3D(v2.x, v1.y, v1.z),\n            this.vector.vector3D(v2.x, v1.y, v2.z),\n            this.vector.vector3D(v2.x, v2.y, v2.z),\n            this.vector.vector3D(v2.x, v2.y, v1.z)\n        ];\n        if (name) {\n            result[0] = this.polygon3D(point1, chart, index, stroke, strokeThickness, opacity, fill, '-0-' + name, parent, text);\n            result[1] = this.polygon3D(point2, chart, index, stroke, strokeThickness, opacity, fill, '-1-' + name, parent, text);\n            result[2] = this.polygon3D(point3, chart, index, stroke, strokeThickness, opacity, fill, '-2-' + name, parent, text);\n            result[3] = this.polygon3D(point4, chart, index, stroke, strokeThickness, opacity, fill, '-3-' + name, parent, text);\n            result[4] = this.polygon3D(point5, chart, index, stroke, strokeThickness, opacity, fill, '-4-' + name, parent, text);\n            result[5] = this.polygon3D(point6, chart, index, stroke, strokeThickness, opacity, fill, '-5-' + name, parent, text);\n        }\n        else {\n            result[0] = this.polygon3D(point1, chart, index, stroke, strokeThickness, opacity, fill, '-0-' + index, parent, text);\n            result[1] = this.polygon3D(point2, chart, index, stroke, strokeThickness, opacity, fill, '-1-' + index, parent, text);\n            result[2] = this.polygon3D(point3, chart, index, stroke, strokeThickness, opacity, fill, '-2-' + index, parent, text);\n            result[3] = this.polygon3D(point4, chart, index, stroke, strokeThickness, opacity, fill, '-3-' + index, parent, text);\n            result[4] = this.polygon3D(point5, chart, index, stroke, strokeThickness, opacity, fill, '-4-' + index, parent, text);\n            result[5] = this.polygon3D(point6, chart, index, stroke, strokeThickness, opacity, fill, '-5-' + index, parent, text);\n        }\n        if (inverse) {\n            graphics.addVisual(result[0], chart);\n            graphics.addVisual(result[1], chart);\n            graphics.addVisual(result[2], chart);\n            graphics.addVisual(result[3], chart);\n            graphics.addVisual(result[4], chart);\n            graphics.addVisual(result[5], chart);\n        }\n        else {\n            graphics.addVisual(result[5], chart);\n            graphics.addVisual(result[4], chart);\n            graphics.addVisual(result[0], chart);\n            graphics.addVisual(result[1], chart);\n            graphics.addVisual(result[2], chart);\n            graphics.addVisual(result[3], chart);\n        }\n        return result;\n    };\n    /**\n     * Calculates the normal vector for a 3D polygon based on the provided points.\n     *\n     * @param {...Chart3DVector} args - Variable number of vector3d arguments representing points of the polygon.\n     * @returns {void}\n     */\n    Polygon3D.prototype.calculateNormal = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (args.length >= 3) {\n            // Relative information of the points\n            var vector1 = args[0];\n            var vector2 = args[1];\n            var vector3 = args[2];\n            var vector4 = this.vector.vector3DMinus(vector1, vector2);\n            var vector5 = this.vector.vector3DMinus(vector3, vector2);\n            var normal = this.vector.vector3DMultiply(vector4, vector5);\n            var length_1 = this.vector.getLength(normal); // Get length of the vector\n            if (length_1 < this.epsilon) {\n                length_1 = 1;\n            }\n            this.normal = this.vector.vector3D(normal.x / length_1, normal.y / length_1, normal.z / length_1); // Calculate normalization of the vector\n            this.d = -(this.normal.x * vector1.x + this.normal.y * vector1.y + this.normal.z * vector1.z); // Normalized values * 1st coordinates Coordinates - Depth of the plan\n            if (args[3]) {\n                args[3].normal = this.normal;\n                args[3].d = this.d;\n            }\n        }\n        else {\n            var Points = args[0];\n            this.calculateNormal(Points[0], Points[1], Points[2], args[1]);\n            for (var i = 3; (i < Points.length) && (this.test()); i++) {\n                this.calculateNormal(Points[i], Points[0], Points[i / 2]);\n            }\n        }\n    };\n    /**\n     * Tests whether the calculated normal vector is valid.\n     *\n     * @returns {boolean} - Returns true if the normal vector is valid, false otherwise.\n     */\n    Polygon3D.prototype.test = function () {\n        return !this.vector.isValid(this.normal);\n    };\n    /**\n     * Transforms the vector points of the specified polygon using the provided matrix.\n     *\n     * @param {number[][]} matrix - The transformation matrix.\n     * @param {Chart3DPolygon} polygon - The polygon to transform.\n     * @returns {void}\n     */\n    Polygon3D.prototype.transform = function (matrix, polygon) {\n        if (polygon.points != null) {\n            for (var i = 0; i < polygon.points.length; i++) {\n                polygon.vectorPoints[i] = polygon.points[i] =\n                    matrixObj.getMatrixVectorMultiple(matrix, polygon.points[i]);\n            }\n            this.calculateNormal(polygon.vectorPoints, polygon);\n        }\n    };\n    /**\n     *  Gets the normal vector based on the transformed points using the specified transformation matrix.\n     *\n     * @param {number[][]} transform - The transformation matrix.\n     * @param {Chart3DVector[]} [vectorPoints] - The vector points.\n     * @returns {Chart3DVector} - Returns the normal vector.\n     * @private\n     */\n    Polygon3D.prototype.getNormal = function (transform, vectorPoints) {\n        var normal;\n        if (vectorPoints != null) {\n            normal = this.vector.getNormal(this.matrixObj.getMatrixVectorMultiple(transform, vectorPoints[0]), matrixObj.getMatrixVectorMultiple(transform, vectorPoints[1]), this.matrixObj.getMatrixVectorMultiple(transform, vectorPoints[2]));\n            for (var i = 3; (i < vectorPoints.length) && !this.vector.isValid(normal) && vectorPoints[i / 2]; i++) {\n                var v1 = matrixObj.getMatrixVectorMultiple(transform, vectorPoints[i]);\n                var v2 = matrixObj.getMatrixVectorMultiple(transform, vectorPoints[0]);\n                var v3 = matrixObj.getMatrixVectorMultiple(transform, vectorPoints[i / 2]);\n                normal = this.vector.getNormal(v1, v2, v3);\n            }\n        }\n        else {\n            normal = matrixObj.getMatrixVectorAnd(transform);\n            this.vector.normalize();\n        }\n        return normal;\n    };\n    /**\n     * A method for creating text element.\n     *\n     * @param {Chart3DVector} position - text position.\n     * @param {Chart3DLabelElement} element - text element.\n     * @param {number} xLength - text element x value.\n     * @param {number} yLength - text element y value.\n     * @returns {Chart3DPolygon} - Returns the polygon.\n     */\n    Polygon3D.prototype.createTextElement = function (position, element, xLength, yLength) {\n        var vectorCollection = [];\n        var x = position.x;\n        var y = position.y;\n        var desiredWidth = element.width;\n        var desiredHeight = element.height;\n        vectorCollection[0] = this.vector.vector3D(x, y, position.z);\n        vectorCollection[1] = this.vector.vector3D(x + desiredWidth, y + desiredHeight + yLength, position.z);\n        vectorCollection[2] = this.vector.vector3D(x + desiredWidth + xLength, y + desiredHeight + yLength, position.z);\n        return this.text3D(element, vectorCollection);\n    };\n    /**\n     * Draws a template on the specified 3D chart panel.\n     *\n     * @param {Chart3DPolygon} panel - The 3D polygon representing the panel on which the template will be drawn.\n     * @param {Chart3D} chart - The 3D chart to which the panel belongs.\n     * @returns {void}\n     */\n    Polygon3D.prototype.drawLine = function (panel, chart) {\n        var transform = chart3DRender.transform;\n        if (transform == null) {\n            return;\n        }\n        var actual3DPosition1 = chart.transform3D.toScreen(panel.vectorPoints[0], transform);\n        var actual3DPosition2 = chart.transform3D.toScreen(panel.vectorPoints[2], transform);\n        var optionsLine = {\n            'id': panel.element.id,\n            'x1': actual3DPosition1.x,\n            'y1': actual3DPosition1.y,\n            'x2': actual3DPosition2.x,\n            'y2': actual3DPosition2.y,\n            'stroke-dasharray': '',\n            'stroke-width': panel.element.width,\n            'stroke': panel.element.stroke,\n            'opacity': panel.element.opacity\n        };\n        chart.chart3D.appendChild(chart.svgRenderer.drawLine(optionsLine));\n        if (chart.previousID && chart.isTouch) {\n            var previousElement = document.getElementById(chart.previousID);\n            var currentElement = document.getElementById(optionsLine.id);\n            if (previousElement && currentElement) {\n                currentElement.parentNode.insertBefore(currentElement, previousElement.nextSibling);\n            }\n        }\n        chart.previousID = optionsLine.id;\n    };\n    /**\n     * Draws text on the specified 3D chart panel.\n     *\n     * @param {Chart3DPolygon} panel - The 3D polygon representing the panel on which the text will be drawn.\n     * @param {Chart3D} chart - The 3D chart to which the panel belongs.\n     * @returns {void}\n     */\n    Polygon3D.prototype.drawTemplate = function (panel, chart) {\n        var element = panel.element;\n        var transform = chart3DRender.transform;\n        if (transform == null) {\n            return;\n        }\n        var label = element.label;\n        var actual3DPosition = chart.transform3D.toScreen(panel.vectorPoints[0], transform);\n        chart.dataLabel3DModule.createDataLabelTemplate(label.series.dataLabelElement, label.series, label.series.dataLabel, label.series.visiblePoints[label.pointIndex], element.argsData, label.pointIndex, false, actual3DPosition);\n    };\n    /**\n     * Draws a data label symbol for a specific data point in a three-dimensional series.\n     *\n     * @param {Chart3DPolygon} panel - The 3D polygon representing the panel on which the text will be drawn.\n     * @param {Chart3D} chart - The 3D chart to which the panel belongs.\n     * @returns {void}\n     */\n    Polygon3D.prototype.drawText = function (panel, chart) {\n        var element = panel.element;\n        var transform = chart3DRender.transform;\n        if (transform == null) {\n            return;\n        }\n        var actual3DPosition = chart.transform3D.toScreen(panel.vectorPoints[0], transform);\n        var x = actual3DPosition.x;\n        var y = actual3DPosition.y;\n        if (element.tag === 'text') {\n            var options = {\n                'id': element.id,\n                'x': x,\n                'y': y,\n                'fill': element.font.color || element.fill,\n                'font-size': element.font.size,\n                'font-family': element.font.fontFamily,\n                'font-style': element.font.fontStyle,\n                'font-weight': element.font.fontWeight,\n                'opacity': element.font.opacity,\n                'text-anchor': element.textAnchor,\n                'cursor': 'default',\n                'transform': element.angle ? 'rotate(' + element.angle + ',' + (x) + ',' + y + ')' : ''\n            };\n            var textElement = chart.svg3DRenderer.drawText(options, element.label.text, panel.element.font, chart);\n            if (element.id.indexOf('-axis-title') > -1) {\n                textElement.setAttribute('aria-hidden', 'true');\n            }\n            chart.chart3D.append(textElement);\n        }\n        else {\n            var series = element.series;\n            var labelFormat = (series.yAxis && series.yAxis.labelFormat) ? series.yAxis.labelFormat : '';\n            var pointText = (element.point.text) ? element.point.text : element.point.y + labelFormat.substring(labelFormat.indexOf('}') + 1);\n            var textOffset = measureText(pointText, series.dataLabel.font, chart.themeStyle.datalabelFont);\n            var margin = series.dataLabel.margin;\n            var width = textOffset.width + margin.left + margin.right;\n            var height = textOffset.height + margin.top + margin.bottom;\n            var location_1 = { x: actual3DPosition.x, y: actual3DPosition.y };\n            var xXalue = location_1.x - (margin.left) / 2 + (margin.right) / 2;\n            var yValue = location_1.y - (margin.top) / 2 - (height / margin.top) + (margin.bottom) / 2;\n            var seriesIndex = series.index;\n            this.dataLabelSymbol(seriesIndex, series, element.pointIndex, xXalue, yValue, width, height, chart);\n        }\n    };\n    /**\n     * Draws a data label symbol for a specific data point in a three-dimensional series.\n     *\n     * @param {number} seriesIndex - The index of the series to which the data point belongs.\n     * @param {Chart3DSeries} series - The three-dimensional series containing the data point.\n     * @param {number} pointIndex - The index of the data point within the series.\n     * @param {number} x - The x-coordinate of the center of the symbol.\n     * @param {number} y - The y-coordinate of the center of the symbol.\n     * @param {number} width - The width of the symbol.\n     * @param {number} height - The height of the symbol.\n     * @param {Chart3D} chart - The three-dimensional chart containing the series.\n     * @returns {void}\n     */\n    Polygon3D.prototype.dataLabelSymbol = function (seriesIndex, series, pointIndex, x, y, width, height, chart) {\n        var path = 'M' + ' ' + (x + (-width / 2)) + ' ' +\n            (y + (-height / 2)) + ' ' + 'L' + ' ' + (x + (width / 2)) +\n            ' ' + (y + (-height / 2)) + ' ' + 'L' + ' ' + (x + (width / 2)) +\n            ' ' + (y + (height / 2)) + ' ' + 'L' + ' ' + (x + (-width / 2)) +\n            ' ' + (y + (height / 2)) + ' ' + 'L' + ' ' + (x + (-width / 2)) +\n            ' ' + (y + (-height / 2)) + ' z';\n        var Rectoptions = {\n            id: chart.element.id + '-svg' + '-data-label-series-' + seriesIndex + '-point-' + pointIndex,\n            fill: series.dataLabel.fill,\n            'stroke-width': series.dataLabel.border.width,\n            'stroke-dasharray': series.dataLabel.border.dashArray,\n            stroke: series.dataLabel.border.color,\n            opacity: series.dataLabel.opacity,\n            visibility: '',\n            d: path\n        };\n        var element = chart.svgRenderer.drawPath(Rectoptions);\n        chart.chart3D.append(element);\n    };\n    /**\n     * Draws a three-dimensional polygon on the specified chart.\n     *\n     * @param {Chart3DPolygon} panel - The polygon to be drawn.\n     * @param {Chart3D} chart - The three-dimensional chart on which the polygon is to be drawn.\n     * @returns {void}\n     */\n    Polygon3D.prototype.draw = function (panel, chart) {\n        if (panel.vectorPoints == null || panel.vectorPoints.length <= 0) {\n            return;\n        }\n        var transform = chart3DRender.transform;\n        var pathDirection = chart.svg3DRenderer.getStringBuilder();\n        var color = panel.fill;\n        var format = chart.svg3DRenderer.checkColorFormat(color);\n        if (!format) {\n            if (color !== 'transparent') {\n                color = colorNameToHex(color);\n            }\n        }\n        var figure = { StartPoint: null };\n        if (transform != null) {\n            figure.StartPoint = chart.transform3D.toScreen(panel.vectorPoints[0], transform);\n            pathDirection.append('M' + ' ' + (figure.StartPoint.x) + ' ' + (figure.StartPoint.y) + ' ');\n            for (var i = 0; i < panel.vectorPoints.length; i++) {\n                var lineSegment = chart.transform3D.toScreen(panel.vectorPoints[i], transform);\n                pathDirection.append('L' + ' ' + (lineSegment.x) + ' ' + (lineSegment.y) + ' ');\n            }\n        }\n        var direction = pathDirection.toString();\n        var name = 'Light';\n        var lightCoefficientZ = (2 * (Math.abs(this.vector.vector3DAdd(panel.normal, this.vector.vector3D(0, 0, 1))) - 1));\n        var lightCoefficientY = (2 * (Math.abs(this.vector.vector3DAdd(panel.normal, this.vector.vector3D(0, 1, 0))) - 1));\n        var lightCoefficientX = (2 * (Math.abs(this.vector.vector3DAdd(panel.normal, this.vector.vector3D(1, 0, 0))) - 1));\n        if (panel.name && !(panel.name.indexOf('-wall-brush') > -1)) {\n            if (lightCoefficientZ === lightCoefficientX) {\n                name = 'ZLight';\n                color = this.applyZLight(color, chart);\n            }\n            else if (((lightCoefficientY === lightCoefficientZ) || (lightCoefficientZ !== 0 && lightCoefficientY < lightCoefficientZ))) {\n                name = 'XLight';\n                color = this.applyXLight(color, chart);\n            }\n            else if (lightCoefficientZ < 0) {\n                name = 'ZLight';\n                color = this.applyZLight(color, chart);\n            }\n            else {\n                name = 'Light';\n            }\n        }\n        var options = {\n            'id': chart.element.id + '-svg' + panel.name,\n            'name': name,\n            'fill': color,\n            'stroke': '',\n            'stroke-width': panel.strokeThickness,\n            'opacity': panel.opacity,\n            'd': direction\n        };\n        var element = chart.svgRenderer.drawPath(options);\n        if (panel.text) {\n            element.setAttribute('aria-label', panel.text);\n            element.setAttribute('role', 'img');\n        }\n        if (panel.name && panel.name.indexOf('-wall-brush') > -1) {\n            element.setAttribute('aria-hidden', 'true');\n        }\n        if (element.id.indexOf('0-region-series-0-point-0') > -1) {\n            if (this.tabIndex) {\n                element.setAttribute('tabindex', '0');\n            }\n            else {\n                var elements = panel.polygonElement.parent.querySelectorAll('[id*=\"0-region-series-0-point-0\"]');\n                if (elements.length > 0) {\n                    elements[elements.length - 1].removeAttribute('tabindex');\n                }\n                element.setAttribute('tabindex', '0');\n            }\n            this.tabIndex = false;\n        }\n        appendChildElement(false, panel.polygonElement.parent, element, chart.redraw, true, 'x', 'y', null, direction);\n        if (chart.previousID && chart.isTouch) {\n            var previousElement = document.getElementById(chart.previousID);\n            var currentElement = document.getElementById(options.id);\n            if (previousElement && currentElement) {\n                currentElement.parentNode.insertBefore(currentElement, previousElement.nextSibling);\n            }\n        }\n        chart.previousID = options.id;\n    };\n    /**\n     * Applies a lightening effect to the given color by reducing its red, green and blue components.\n     *\n     * @param {string} color - The input color in hexadecimal format.\n     * @param {Chart3D} chart - The three-dimensional chart associated with the color.\n     * @returns {string} - The lightened color in hexadecimal format.\n     */\n    Polygon3D.prototype.applyXLight = function (color, chart) {\n        var RGB = chart.svg3DRenderer.hexToValue(color);\n        RGB.red = parseInt((RGB.red * 0.7).toString(), 10);\n        RGB.green = parseInt((RGB.green * 0.7).toString(), 10);\n        RGB.blue = parseInt((RGB.blue * 0.7).toString(), 10);\n        return chart.svg3DRenderer.hexColor(RGB);\n    };\n    /**\n     * Applies a lightening effect to the given color by reducing its red, green and blue components with a focus on the Z-axis.\n     *\n     * @param {string} color - The input color in hexadecimal format.\n     * @param {Chart3D} chart - The three-dimensional chart associated with the color.\n     * @returns {string} - The lightened color in hexadecimal format.\n     */\n    Polygon3D.prototype.applyZLight = function (color, chart) {\n        var RGB = chart.svg3DRenderer.hexToValue(color);\n        RGB.red = parseInt((RGB.red * 0.9).toString(), 10);\n        RGB.green = parseInt((RGB.green * 0.9).toString(), 10);\n        RGB.blue = parseInt((RGB.blue * 0.9).toString(), 10);\n        return chart.svg3DRenderer.hexColor(RGB);\n    };\n    return Polygon3D;\n}());\nexport { Polygon3D };\nvar vector = new Vector3D(0, 0, 0);\nvar matrixObj = new Matrix3D();\nvar bspTreeObj = new BinaryTreeBuilder();\nvar polygonObj = new Polygon3D();\nvar graphics = new Graphics3D();\n/**\n * Gets the minimum delta value between adjacent data points on a given axis in a three-dimensional chart.\n *\n * @param {Chart3DAxis} axis - The three-dimensional axis for which the delta value is calculated.\n * @param {Chart3DSeries[]} seriesCollection - Collection of three-dimensional series in the chart.\n * @returns {number} - The minimum delta value between adjacent data points on the specified axis.\n */\nexport function getMinPointsDeltaValue(axis, seriesCollection) {\n    var minDelta = Number.MAX_VALUE;\n    var xValues;\n    var minVal;\n    var seriesMin;\n    for (var index = 0; index < seriesCollection.length; index++) {\n        var series = seriesCollection[index];\n        xValues = [];\n        if (series.visible &&\n            (axis.name === series.xAxisName || (axis.name === 'primaryXAxis' && series.xAxisName === null))) {\n            xValues = series.points.map(function (point) {\n                return point.xValue;\n            });\n            xValues.sort(function (first, second) { return first - second; });\n            if (xValues.length === 1) {\n                seriesMin = (axis.valueType === 'DateTime' && series.xMin === series.xMax) ? (series.xMin - 25920000) : series.xMin;\n                minVal = xValues[0] - (!isNullOrUndefined(seriesMin) ?\n                    seriesMin : axis.visibleRange.min);\n                if (minVal !== 0) {\n                    minDelta = Math.min(minDelta, minVal);\n                }\n            }\n            else {\n                for (var index_1 = 0; index_1 < xValues.length; index_1++) {\n                    var value = xValues[index_1];\n                    if (index_1 > 0 && value) {\n                        minVal = value - xValues[index_1 - 1];\n                        if (minVal !== 0) {\n                            minDelta = Math.min(minDelta, minVal);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (minDelta === Number.MAX_VALUE) {\n        minDelta = 1;\n    }\n    return minDelta;\n}\n/**\n * Converts a numeric value to a coefficient based on the given 3D axis.\n *\n * @param {number} value - The numeric value to be converted.\n * @param {Chart3DAxis} axis - The 3D axis for reference.\n * @returns {number} - The coefficient value.\n * @private\n */\nexport function valueToCoefficients(value, axis) {\n    var range = axis.visibleRange;\n    var result = (value - range.min) / (range.delta);\n    var isInverse = axis.isAxisInverse;\n    return isInverse ? (1 - result) : result;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}