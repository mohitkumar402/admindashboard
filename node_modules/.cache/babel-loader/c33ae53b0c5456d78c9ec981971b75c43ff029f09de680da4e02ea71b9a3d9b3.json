{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport { setRange, triggerLabelRender } from '../../common/utils/helper';\nimport { DoubleRange } from '../utils/doubleRange';\nimport { withIn, firstToLowerCase } from '../../common/utils/helper';\nimport { DataUtil } from '@syncfusion/ej2-data';\nimport { NiceIntervals } from '../axis/axis-helper';\nimport { extend, getValue } from '@syncfusion/ej2-base';\n/**\n * The `DateTime` module is used to render datetime axis.\n */\nvar DateTime3D = /** @class */function (_super) {\n  __extends(DateTime3D, _super);\n  /**\n   * Constructor for the dateTime module.\n   *\n   * @param {Chart3D} chart - Chart3D instance.\n   * @private\n   */\n  function DateTime3D(chart) {\n    return _super.call(this, chart) || this;\n  }\n  /**\n   * Calculates the range and interval for the specified axis based on the provided size.\n   *\n   * @param {Size} size - The size of the chart area used for range and interval calculation.\n   * @param {Chart3DAxis} axis - The axis for which the range and interval are calculated.\n   * @returns {void}\n   */\n  DateTime3D.prototype.calculateRangeAndInterval = function (size, axis) {\n    this.calculateRange(axis);\n    this.getActualRange(axis, size);\n    this.applyRangePadding(axis, size);\n    this.calculateVisibleLabels(axis, this.chart);\n  };\n  /**\n   * Retrieves the actual range for the specified axis based on the provided size.\n   *\n   * @param {Chart3DAxis} axis - The axis for which the actual range is calculated.\n   * @param {Size} size - The size of the chart area used in the range calculation.\n   * @returns {void}\n   */\n  DateTime3D.prototype.getActualRange = function (axis, size) {\n    var option = {\n      skeleton: 'full',\n      type: 'dateTime'\n    };\n    var dateParser = this.chart.intl.getDateParser(option);\n    var dateFormatter = this.chart.intl.getDateFormat(option);\n    // Axis min\n    if (axis.minimum !== null) {\n      this.min = Date.parse(dateParser(dateFormatter(new Date(DataUtil.parse.parseJson({\n        val: axis.minimum\n      }).val))));\n    } else if (this.min === null || this.min === Number.POSITIVE_INFINITY) {\n      this.min = Date.parse(dateParser(dateFormatter(new Date(1970, 1, 1))));\n    }\n    // Axis Max\n    if (axis.maximum !== null) {\n      this.max = Date.parse(dateParser(dateFormatter(new Date(DataUtil.parse.parseJson({\n        val: axis.maximum\n      }).val))));\n    } else if (this.max === null || this.max === Number.NEGATIVE_INFINITY) {\n      this.max = Date.parse(dateParser(dateFormatter(new Date(1970, 5, 1))));\n    }\n    if (this.min === this.max) {\n      this.max = this.max + 2592000000;\n      this.min = this.min - 2592000000;\n    }\n    axis.actualRange = {};\n    axis.doubleRange = new DoubleRange(this.min, this.max);\n    var datetimeInterval = this.calculateDateTimeNiceInterval(axis, size, axis.doubleRange.start, axis.doubleRange.end);\n    if (!axis.interval) {\n      axis.actualRange.interval = datetimeInterval;\n    } else {\n      axis.actualRange.interval = axis.interval;\n    }\n    axis.actualRange.min = axis.doubleRange.start;\n    axis.actualRange.max = axis.doubleRange.end;\n  };\n  /**\n   * Applies range padding to the specified axis based on the provided size.\n   *\n   * @param {Chart3DAxis} axis - The axis to which range padding is applied.\n   * @param {Size} size - The size of the chart area used in the padding calculation.\n   * @returns {void}\n   */\n  DateTime3D.prototype.applyRangePadding = function (axis, size) {\n    this.min = axis.actualRange.min;\n    this.max = axis.actualRange.max;\n    var minimum;\n    var maximum;\n    var interval = axis.actualRange.interval;\n    if (!setRange(axis)) {\n      var rangePadding = axis.getRangePadding(this.chart);\n      minimum = new Date(this.min);\n      maximum = new Date(this.max);\n      var intervalType = axis.actualIntervalType;\n      if (rangePadding === 'None') {\n        this.min = minimum.getTime();\n        this.max = maximum.getTime();\n      } else if (rangePadding === 'Additional' || rangePadding === 'Round') {\n        switch (intervalType) {\n          case 'Years':\n            this.getYear(minimum, maximum, rangePadding, interval);\n            break;\n          case 'Months':\n            this.getMonth(minimum, maximum, rangePadding, interval);\n            break;\n          case 'Days':\n            this.getDay(minimum, maximum, rangePadding, interval);\n            break;\n          case 'Hours':\n            this.getHour(minimum, maximum, rangePadding, interval);\n            break;\n          case 'Minutes':\n            {\n              var minute = minimum.getMinutes() / interval * interval;\n              var endMinute = maximum.getMinutes() + (minimum.getMinutes() - minute);\n              if (rangePadding === 'Round') {\n                this.min = new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), minimum.getHours(), minute, 0).getTime();\n                this.max = new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), maximum.getHours(), endMinute, 59).getTime();\n              } else {\n                this.min = new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), minimum.getHours(), minute + -interval, 0).getTime();\n                this.max = new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), maximum.getHours(), endMinute + interval, 0).getTime();\n              }\n              break;\n            }\n          case 'Seconds':\n            {\n              var second = minimum.getSeconds() / interval * interval;\n              var endSecond = maximum.getSeconds() + (minimum.getSeconds() - second);\n              if (rangePadding === 'Round') {\n                this.min = new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), minimum.getHours(), minimum.getMinutes(), second, 0).getTime();\n                this.max = new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), maximum.getHours(), maximum.getMinutes(), endSecond, 0).getTime();\n              } else {\n                this.min = new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), minimum.getHours(), minimum.getMinutes(), second + -interval, 0).getTime();\n                this.max = new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), maximum.getHours(), maximum.getMinutes(), endSecond + interval, 0).getTime();\n              }\n              break;\n            }\n        }\n      }\n    }\n    axis.actualRange.min = axis.minimum != null ? this.min : this.min;\n    axis.actualRange.max = axis.maximum != null ? this.max : this.max;\n    axis.actualRange.delta = axis.actualRange.max - axis.actualRange.min;\n    axis.doubleRange = new DoubleRange(axis.actualRange.min, axis.actualRange.max);\n    this.calculateVisibleRange(size, axis);\n  };\n  /**\n   * Determines the year values within the specified date range with consideration for range padding and interval.\n   *\n   * @param {Date} minimum - The minimum date of the range.\n   * @param {Date} maximum - The maximum date of the range.\n   * @param {ChartRangePadding} rangePadding - The type of range padding to apply.\n   * @param {number} interval - The desired interval between years.\n   * @returns {void}\n   */\n  DateTime3D.prototype.getYear = function (minimum, maximum, rangePadding, interval) {\n    var startYear = minimum.getFullYear();\n    var endYear = maximum.getFullYear();\n    if (rangePadding === 'Additional') {\n      this.min = new Date(startYear - interval, 1, 1, 0, 0, 0).getTime();\n      this.max = new Date(endYear + interval, 1, 1, 0, 0, 0).getTime();\n    } else {\n      this.min = new Date(startYear, 0, 0, 0, 0, 0).getTime();\n      this.max = new Date(endYear, 11, 30, 23, 59, 59).getTime();\n    }\n  };\n  /**\n   * Determines the month values within the specified date range with consideration for range padding and interval.\n   *\n   * @param {Date} minimum - The minimum date of the range.\n   * @param {Date} maximum - The maximum date of the range.\n   * @param {ChartRangePadding} rangePadding - The type of range padding to apply.\n   * @param {number} interval - The desired interval between months.\n   * @returns {void}\n   */\n  DateTime3D.prototype.getMonth = function (minimum, maximum, rangePadding, interval) {\n    var month = minimum.getMonth();\n    var endMonth = maximum.getMonth();\n    if (rangePadding === 'Round') {\n      this.min = new Date(minimum.getFullYear(), month, 0, 0, 0, 0).getTime();\n      this.max = new Date(maximum.getFullYear(), endMonth, new Date(maximum.getFullYear(), maximum.getMonth(), 0).getDate(), 23, 59, 59).getTime();\n    } else {\n      this.min = new Date(minimum.getFullYear(), month + -interval, 1, 0, 0, 0).getTime();\n      this.max = new Date(maximum.getFullYear(), endMonth + interval, endMonth === 2 ? 28 : 30, 0, 0, 0).getTime();\n    }\n  };\n  /**\n   * Determines the day values within the specified date range with consideration for range padding and interval.\n   *\n   * @param {Date} minimum - The minimum date of the range.\n   * @param {Date} maximum - The maximum date of the range.\n   * @param {ChartRangePadding} rangePadding - The type of range padding to apply.\n   * @param {number} interval - The desired interval between days.\n   * @returns {void}\n   */\n  DateTime3D.prototype.getDay = function (minimum, maximum, rangePadding, interval) {\n    var day = minimum.getDate();\n    var endDay = maximum.getDate();\n    if (rangePadding === 'Round') {\n      this.min = new Date(minimum.getFullYear(), minimum.getMonth(), day, 0, 0, 0).getTime();\n      this.max = new Date(maximum.getFullYear(), maximum.getMonth(), endDay, 23, 59, 59).getTime();\n    } else {\n      this.min = new Date(minimum.getFullYear(), minimum.getMonth(), day + -interval, 0, 0, 0).getTime();\n      this.max = new Date(maximum.getFullYear(), maximum.getMonth(), endDay + interval, 0, 0, 0).getTime();\n    }\n  };\n  /**\n   * Determines the hour values within the specified date range with consideration for range padding and interval.\n   *\n   * @param {Date} minimum - The minimum date of the range.\n   * @param {Date} maximum - The maximum date of the range.\n   * @param {ChartRangePadding} rangePadding - The type of range padding to apply.\n   * @param {number} interval - The desired interval between hours.\n   * @returns {void}\n   */\n  DateTime3D.prototype.getHour = function (minimum, maximum, rangePadding, interval) {\n    var hour = minimum.getHours() / interval * interval;\n    var endHour = maximum.getHours() + (minimum.getHours() - hour);\n    if (rangePadding === 'Round') {\n      this.min = new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), hour, 0, 0).getTime();\n      this.max = new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), endHour, 59, 59).getTime();\n    } else {\n      this.min = new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), hour + -interval, 0, 0).getTime();\n      this.max = new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), endHour + interval, 0, 0).getTime();\n    }\n  };\n  /**\n   * Calculates the visible range for the specified axis based on the provided size.\n   *\n   * @param {Size} size - The size of the chart area used in the visible range calculation.\n   * @param {Chart3DAxis} axis - The axis for which the visible range is calculated.\n   * @returns {void}\n   */\n  DateTime3D.prototype.calculateVisibleRange = function (size, axis) {\n    axis.visibleRange = {\n      min: axis.actualRange.min,\n      max: axis.actualRange.max,\n      interval: axis.actualRange.interval,\n      delta: axis.actualRange.delta\n    };\n    axis.dateTimeInterval = this.increaseDateTimeInterval(axis, axis.visibleRange.min, axis.visibleRange.interval).getTime() - axis.visibleRange.min;\n    axis.triggerRangeRender(this.chart, axis.visibleRange.min, axis.visibleRange.max, axis.visibleRange.interval);\n  };\n  /**\n   * Calculate visible labels for the axis.\n   *\n   * @param {Chart3DAxis} axis -  The axis for which the labels are calculated.\n   * @param {Chart3D} chart chart\n   * @returns {void}\n   * @private\n   */\n  DateTime3D.prototype.calculateVisibleLabels = function (axis, chart) {\n    axis.visibleLabels = [];\n    var tempInterval = axis.visibleRange.min;\n    var labelStyle;\n    if (!setRange(axis)) {\n      tempInterval = this.alignRangeStart(axis, tempInterval, axis.visibleRange.interval).getTime();\n    }\n    while (tempInterval <= axis.visibleRange.max) {\n      labelStyle = extend({}, getValue('properties', axis.labelStyle), null, true);\n      axis.format = chart.intl.getDateFormat({\n        format: this.findCustomFormats(axis) || '',\n        type: firstToLowerCase(axis.skeletonType),\n        skeleton: this.getSkeleton(axis)\n      });\n      axis.startLabel = axis.format(new Date(axis.visibleRange.min));\n      axis.endLabel = axis.format(new Date(axis.visibleRange.max));\n      if (withIn(tempInterval, axis.visibleRange)) {\n        var interval = this.increaseDateTimeInterval(axis, tempInterval, axis.visibleRange.interval).getTime();\n        if (interval > axis.visibleRange.max) {\n          axis.endLabel = axis.format(new Date(tempInterval));\n        }\n        triggerLabelRender(chart, tempInterval, axis.format(new Date(tempInterval)), labelStyle, axis);\n      }\n      var actualInterval = tempInterval;\n      tempInterval = this.increaseDateTimeInterval(axis, tempInterval, axis.visibleRange.interval).getTime();\n      if (actualInterval === tempInterval) {\n        break;\n      }\n    }\n    if (axis.actualIntervalType === 'Months' || axis.actualIntervalType === 'Days') {\n      axis.format = chart.intl.getDateFormat({\n        format: axis.labelFormat || (axis.actualIntervalType === 'Months' && !axis.skeleton ? 'y MMM' : ''),\n        type: firstToLowerCase(axis.skeletonType),\n        skeleton: axis.skeleton || (axis.actualIntervalType === 'Days' ? 'MMMd' : '')\n      });\n    }\n    if (axis.getMaxLabelWidth) {\n      axis.getMaxLabelWidth(this.chart);\n    }\n  };\n  /**\n   * Increases a date-time interval by the specified value for the given axis.\n   *\n   * @param {Chart3DAxis} axis - The axis for which the date-time interval is increased.\n   * @param {number} value - The value by which to increase the interval.\n   * @param {number} interval - The original interval to be adjusted.\n   * @returns {Date} - The adjusted date-time interval.\n   * @private\n   */\n  DateTime3D.prototype.increaseDateTimeInterval = function (axis, value, interval) {\n    var result = new Date(value);\n    if (axis.interval) {\n      axis.isIntervalInDecimal = interval % 1 === 0;\n      axis.visibleRange.interval = interval;\n    } else {\n      interval = Math.ceil(interval);\n      axis.visibleRange.interval = interval;\n    }\n    var intervalType = axis.actualIntervalType;\n    if (axis.isIntervalInDecimal) {\n      switch (intervalType) {\n        case 'Years':\n          result.setFullYear(result.getFullYear() + interval);\n          return result;\n        case 'Months':\n          result.setMonth(result.getMonth() + interval);\n          return result;\n        case 'Days':\n          result.setDate(result.getDate() + interval);\n          return result;\n        case 'Hours':\n          result.setHours(result.getHours() + interval);\n          return result;\n        case 'Minutes':\n          result.setMinutes(result.getMinutes() + interval);\n          return result;\n        case 'Seconds':\n          result.setSeconds(result.getSeconds() + interval);\n          return result;\n      }\n    }\n    return result;\n  };\n  /**\n   * Aligns the starting date of the range for the specified axis based on the provided date and interval size.\n   *\n   * @param {Chart3DAxis} axis - The axis for which the range start is aligned.\n   * @param {number} sDate - The date in numerical format to be aligned.\n   * @param {number} intervalSize - The size of the interval used for alignment.\n   * @returns {Date} - The aligned date for the range start.\n   * @private\n   */\n  DateTime3D.prototype.alignRangeStart = function (axis, sDate, intervalSize) {\n    var sResult = new Date(sDate);\n    switch (axis.actualIntervalType) {\n      case 'Years':\n        {\n          var year = Math.floor(Math.floor(sResult.getFullYear() / intervalSize) * intervalSize);\n          sResult = new Date(year, sResult.getMonth(), sResult.getDate(), 0, 0, 0);\n          return sResult;\n        }\n      case 'Months':\n        {\n          var month = Math.floor(Math.floor(sResult.getMonth() / intervalSize) * intervalSize);\n          sResult = new Date(sResult.getFullYear(), month, sResult.getDate(), 0, 0, 0);\n          return sResult;\n        }\n      case 'Days':\n        {\n          var day = Math.floor(Math.floor(sResult.getDate() / intervalSize) * intervalSize);\n          sResult = new Date(sResult.getFullYear(), sResult.getMonth(), day, 0, 0, 0);\n          return sResult;\n        }\n      case 'Hours':\n        {\n          var hour = Math.floor(Math.floor(sResult.getHours() / intervalSize) * intervalSize);\n          sResult = new Date(sResult.getFullYear(), sResult.getMonth(), sResult.getDate(), hour, 0, 0);\n          return sResult;\n        }\n      case 'Minutes':\n        {\n          var minutes = Math.floor(Math.floor(sResult.getMinutes() / intervalSize) * intervalSize);\n          sResult = new Date(sResult.getFullYear(), sResult.getMonth(), sResult.getDate(), sResult.getHours(), minutes, 0, 0);\n          return sResult;\n        }\n      case 'Seconds':\n        {\n          var seconds = Math.floor(Math.floor(sResult.getSeconds() / intervalSize) * intervalSize);\n          sResult = new Date(sResult.getFullYear(), sResult.getMonth(), sResult.getDate(), sResult.getHours(), sResult.getMinutes(), seconds, 0);\n          return sResult;\n        }\n    }\n    return sResult;\n  };\n  /**\n   * Get module name.\n   *\n   * @returns {string} - Returns the module name.\n   */\n  DateTime3D.prototype.getModuleName = function () {\n    /**\n     * Returns the module name\n     */\n    return 'DateTime3D';\n  };\n  /**\n   * To destroy the date time axis.\n   *\n   * @returns {void}\n   * @private\n   */\n  DateTime3D.prototype.destroy = function () {\n    /**\n     * Destroy method performed here\n     */\n  };\n  return DateTime3D;\n}(NiceIntervals);\nexport { DateTime3D };","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","setRange","triggerLabelRender","DoubleRange","withIn","firstToLowerCase","DataUtil","NiceIntervals","extend","getValue","DateTime3D","_super","chart","call","calculateRangeAndInterval","size","axis","calculateRange","getActualRange","applyRangePadding","calculateVisibleLabels","option","skeleton","type","dateParser","intl","getDateParser","dateFormatter","getDateFormat","minimum","min","Date","parse","parseJson","val","Number","POSITIVE_INFINITY","maximum","max","NEGATIVE_INFINITY","actualRange","doubleRange","datetimeInterval","calculateDateTimeNiceInterval","start","end","interval","rangePadding","getRangePadding","intervalType","actualIntervalType","getTime","getYear","getMonth","getDay","getHour","minute","getMinutes","endMinute","getFullYear","getDate","getHours","second","getSeconds","endSecond","delta","calculateVisibleRange","startYear","endYear","month","endMonth","day","endDay","hour","endHour","visibleRange","dateTimeInterval","increaseDateTimeInterval","triggerRangeRender","visibleLabels","tempInterval","labelStyle","alignRangeStart","format","findCustomFormats","skeletonType","getSkeleton","startLabel","endLabel","actualInterval","labelFormat","getMaxLabelWidth","value","result","isIntervalInDecimal","Math","ceil","setFullYear","setMonth","setDate","setHours","setMinutes","setSeconds","sDate","intervalSize","sResult","year","floor","minutes","seconds","getModuleName","destroy"],"sources":["C:/Users/mkfun/Desktop/ct assignment/admin/node_modules/@syncfusion/ej2-charts/src/chart3d/axis/date-time-axis.js"],"sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { setRange, triggerLabelRender } from '../../common/utils/helper';\nimport { DoubleRange } from '../utils/doubleRange';\nimport { withIn, firstToLowerCase } from '../../common/utils/helper';\nimport { DataUtil } from '@syncfusion/ej2-data';\nimport { NiceIntervals } from '../axis/axis-helper';\nimport { extend, getValue } from '@syncfusion/ej2-base';\n/**\n * The `DateTime` module is used to render datetime axis.\n */\nvar DateTime3D = /** @class */ (function (_super) {\n    __extends(DateTime3D, _super);\n    /**\n     * Constructor for the dateTime module.\n     *\n     * @param {Chart3D} chart - Chart3D instance.\n     * @private\n     */\n    function DateTime3D(chart) {\n        return _super.call(this, chart) || this;\n    }\n    /**\n     * Calculates the range and interval for the specified axis based on the provided size.\n     *\n     * @param {Size} size - The size of the chart area used for range and interval calculation.\n     * @param {Chart3DAxis} axis - The axis for which the range and interval are calculated.\n     * @returns {void}\n     */\n    DateTime3D.prototype.calculateRangeAndInterval = function (size, axis) {\n        this.calculateRange(axis);\n        this.getActualRange(axis, size);\n        this.applyRangePadding(axis, size);\n        this.calculateVisibleLabels(axis, this.chart);\n    };\n    /**\n     * Retrieves the actual range for the specified axis based on the provided size.\n     *\n     * @param {Chart3DAxis} axis - The axis for which the actual range is calculated.\n     * @param {Size} size - The size of the chart area used in the range calculation.\n     * @returns {void}\n     */\n    DateTime3D.prototype.getActualRange = function (axis, size) {\n        var option = {\n            skeleton: 'full',\n            type: 'dateTime'\n        };\n        var dateParser = this.chart.intl.getDateParser(option);\n        var dateFormatter = this.chart.intl.getDateFormat(option);\n        // Axis min\n        if ((axis.minimum) !== null) {\n            this.min = Date.parse(dateParser(dateFormatter(new Date(DataUtil.parse.parseJson({ val: axis.minimum }).val))));\n        }\n        else if (this.min === null || this.min === Number.POSITIVE_INFINITY) {\n            this.min = Date.parse(dateParser(dateFormatter(new Date(1970, 1, 1))));\n        }\n        // Axis Max\n        if ((axis.maximum) !== null) {\n            this.max = Date.parse(dateParser(dateFormatter(new Date(DataUtil.parse.parseJson({ val: axis.maximum }).val))));\n        }\n        else if (this.max === null || this.max === Number.NEGATIVE_INFINITY) {\n            this.max = Date.parse(dateParser(dateFormatter(new Date(1970, 5, 1))));\n        }\n        if (this.min === this.max) {\n            this.max = this.max + 2592000000;\n            this.min = this.min - 2592000000;\n        }\n        axis.actualRange = {};\n        axis.doubleRange = new DoubleRange(this.min, this.max);\n        var datetimeInterval = this.calculateDateTimeNiceInterval(axis, size, axis.doubleRange.start, axis.doubleRange.end);\n        if (!axis.interval) {\n            axis.actualRange.interval = datetimeInterval;\n        }\n        else {\n            axis.actualRange.interval = axis.interval;\n        }\n        axis.actualRange.min = axis.doubleRange.start;\n        axis.actualRange.max = axis.doubleRange.end;\n    };\n    /**\n     * Applies range padding to the specified axis based on the provided size.\n     *\n     * @param {Chart3DAxis} axis - The axis to which range padding is applied.\n     * @param {Size} size - The size of the chart area used in the padding calculation.\n     * @returns {void}\n     */\n    DateTime3D.prototype.applyRangePadding = function (axis, size) {\n        this.min = (axis.actualRange.min);\n        this.max = (axis.actualRange.max);\n        var minimum;\n        var maximum;\n        var interval = axis.actualRange.interval;\n        if (!setRange(axis)) {\n            var rangePadding = axis.getRangePadding(this.chart);\n            minimum = new Date(this.min);\n            maximum = new Date(this.max);\n            var intervalType = axis.actualIntervalType;\n            if (rangePadding === 'None') {\n                this.min = minimum.getTime();\n                this.max = maximum.getTime();\n            }\n            else if (rangePadding === 'Additional' || rangePadding === 'Round') {\n                switch (intervalType) {\n                    case 'Years':\n                        this.getYear(minimum, maximum, rangePadding, interval);\n                        break;\n                    case 'Months':\n                        this.getMonth(minimum, maximum, rangePadding, interval);\n                        break;\n                    case 'Days':\n                        this.getDay(minimum, maximum, rangePadding, interval);\n                        break;\n                    case 'Hours':\n                        this.getHour(minimum, maximum, rangePadding, interval);\n                        break;\n                    case 'Minutes': {\n                        var minute = (minimum.getMinutes() / interval) * interval;\n                        var endMinute = maximum.getMinutes() + (minimum.getMinutes() - minute);\n                        if (rangePadding === 'Round') {\n                            this.min = (new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), minimum.getHours(), minute, 0)).getTime();\n                            this.max = (new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), maximum.getHours(), endMinute, 59)).getTime();\n                        }\n                        else {\n                            this.min = (new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), minimum.getHours(), minute + (-interval), 0)).getTime();\n                            this.max = (new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), maximum.getHours(), endMinute + (interval), 0)).getTime();\n                        }\n                        break;\n                    }\n                    case 'Seconds': {\n                        var second = (minimum.getSeconds() / interval) * interval;\n                        var endSecond = maximum.getSeconds() + (minimum.getSeconds() - second);\n                        if (rangePadding === 'Round') {\n                            this.min = (new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), minimum.getHours(), minimum.getMinutes(), second, 0)).getTime();\n                            this.max = (new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), maximum.getHours(), maximum.getMinutes(), endSecond, 0)).getTime();\n                        }\n                        else {\n                            this.min = (new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), minimum.getHours(), minimum.getMinutes(), second + (-interval), 0)).getTime();\n                            this.max = (new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), maximum.getHours(), maximum.getMinutes(), endSecond + (interval), 0)).getTime();\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n        axis.actualRange.min = (axis.minimum != null) ? this.min : this.min;\n        axis.actualRange.max = (axis.maximum != null) ? this.max : this.max;\n        axis.actualRange.delta = (axis.actualRange.max - axis.actualRange.min);\n        axis.doubleRange = new DoubleRange(axis.actualRange.min, axis.actualRange.max);\n        this.calculateVisibleRange(size, axis);\n    };\n    /**\n     * Determines the year values within the specified date range with consideration for range padding and interval.\n     *\n     * @param {Date} minimum - The minimum date of the range.\n     * @param {Date} maximum - The maximum date of the range.\n     * @param {ChartRangePadding} rangePadding - The type of range padding to apply.\n     * @param {number} interval - The desired interval between years.\n     * @returns {void}\n     */\n    DateTime3D.prototype.getYear = function (minimum, maximum, rangePadding, interval) {\n        var startYear = minimum.getFullYear();\n        var endYear = maximum.getFullYear();\n        if (rangePadding === 'Additional') {\n            this.min = (new Date(startYear - interval, 1, 1, 0, 0, 0)).getTime();\n            this.max = (new Date(endYear + interval, 1, 1, 0, 0, 0)).getTime();\n        }\n        else {\n            this.min = new Date(startYear, 0, 0, 0, 0, 0).getTime();\n            this.max = new Date(endYear, 11, 30, 23, 59, 59).getTime();\n        }\n    };\n    /**\n     * Determines the month values within the specified date range with consideration for range padding and interval.\n     *\n     * @param {Date} minimum - The minimum date of the range.\n     * @param {Date} maximum - The maximum date of the range.\n     * @param {ChartRangePadding} rangePadding - The type of range padding to apply.\n     * @param {number} interval - The desired interval between months.\n     * @returns {void}\n     */\n    DateTime3D.prototype.getMonth = function (minimum, maximum, rangePadding, interval) {\n        var month = minimum.getMonth();\n        var endMonth = maximum.getMonth();\n        if (rangePadding === 'Round') {\n            this.min = (new Date(minimum.getFullYear(), month, 0, 0, 0, 0)).getTime();\n            this.max = (new Date(maximum.getFullYear(), endMonth, new Date(maximum.getFullYear(), maximum.getMonth(), 0).getDate(), 23, 59, 59)).getTime();\n        }\n        else {\n            this.min = (new Date(minimum.getFullYear(), month + (-interval), 1, 0, 0, 0)).getTime();\n            this.max = (new Date(maximum.getFullYear(), endMonth + (interval), endMonth === 2 ? 28 : 30, 0, 0, 0)).getTime();\n        }\n    };\n    /**\n     * Determines the day values within the specified date range with consideration for range padding and interval.\n     *\n     * @param {Date} minimum - The minimum date of the range.\n     * @param {Date} maximum - The maximum date of the range.\n     * @param {ChartRangePadding} rangePadding - The type of range padding to apply.\n     * @param {number} interval - The desired interval between days.\n     * @returns {void}\n     */\n    DateTime3D.prototype.getDay = function (minimum, maximum, rangePadding, interval) {\n        var day = minimum.getDate();\n        var endDay = maximum.getDate();\n        if (rangePadding === 'Round') {\n            this.min = (new Date(minimum.getFullYear(), minimum.getMonth(), day, 0, 0, 0)).getTime();\n            this.max = (new Date(maximum.getFullYear(), maximum.getMonth(), endDay, 23, 59, 59)).getTime();\n        }\n        else {\n            this.min = (new Date(minimum.getFullYear(), minimum.getMonth(), day + (-interval), 0, 0, 0)).getTime();\n            this.max = (new Date(maximum.getFullYear(), maximum.getMonth(), endDay + (interval), 0, 0, 0)).getTime();\n        }\n    };\n    /**\n     * Determines the hour values within the specified date range with consideration for range padding and interval.\n     *\n     * @param {Date} minimum - The minimum date of the range.\n     * @param {Date} maximum - The maximum date of the range.\n     * @param {ChartRangePadding} rangePadding - The type of range padding to apply.\n     * @param {number} interval - The desired interval between hours.\n     * @returns {void}\n     */\n    DateTime3D.prototype.getHour = function (minimum, maximum, rangePadding, interval) {\n        var hour = (minimum.getHours() / interval) * interval;\n        var endHour = maximum.getHours() + (minimum.getHours() - hour);\n        if (rangePadding === 'Round') {\n            this.min = (new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), hour, 0, 0)).getTime();\n            this.max = (new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), endHour, 59, 59)).getTime();\n        }\n        else {\n            this.min = (new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), hour + (-interval), 0, 0)).getTime();\n            this.max = (new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), endHour + (interval), 0, 0)).getTime();\n        }\n    };\n    /**\n     * Calculates the visible range for the specified axis based on the provided size.\n     *\n     * @param {Size} size - The size of the chart area used in the visible range calculation.\n     * @param {Chart3DAxis} axis - The axis for which the visible range is calculated.\n     * @returns {void}\n     */\n    DateTime3D.prototype.calculateVisibleRange = function (size, axis) {\n        axis.visibleRange = {\n            min: axis.actualRange.min,\n            max: axis.actualRange.max,\n            interval: axis.actualRange.interval,\n            delta: axis.actualRange.delta\n        };\n        axis.dateTimeInterval = this.increaseDateTimeInterval(axis, axis.visibleRange.min, axis.visibleRange.interval).getTime()\n            - axis.visibleRange.min;\n        axis.triggerRangeRender(this.chart, axis.visibleRange.min, axis.visibleRange.max, axis.visibleRange.interval);\n    };\n    /**\n     * Calculate visible labels for the axis.\n     *\n     * @param {Chart3DAxis} axis -  The axis for which the labels are calculated.\n     * @param {Chart3D} chart chart\n     * @returns {void}\n     * @private\n     */\n    DateTime3D.prototype.calculateVisibleLabels = function (axis, chart) {\n        axis.visibleLabels = [];\n        var tempInterval = axis.visibleRange.min;\n        var labelStyle;\n        if (!setRange(axis)) {\n            tempInterval = this.alignRangeStart(axis, tempInterval, axis.visibleRange.interval).getTime();\n        }\n        while (tempInterval <= axis.visibleRange.max) {\n            labelStyle = (extend({}, getValue('properties', axis.labelStyle), null, true));\n            axis.format = chart.intl.getDateFormat({\n                format: this.findCustomFormats(axis) || '',\n                type: firstToLowerCase(axis.skeletonType),\n                skeleton: this.getSkeleton(axis)\n            });\n            axis.startLabel = axis.format(new Date(axis.visibleRange.min));\n            axis.endLabel = axis.format(new Date(axis.visibleRange.max));\n            if (withIn(tempInterval, axis.visibleRange)) {\n                var interval = this.increaseDateTimeInterval(axis, tempInterval, axis.visibleRange.interval).getTime();\n                if (interval > axis.visibleRange.max) {\n                    axis.endLabel = axis.format(new Date(tempInterval));\n                }\n                triggerLabelRender(chart, tempInterval, axis.format(new Date(tempInterval)), labelStyle, axis);\n            }\n            var actualInterval = tempInterval;\n            tempInterval = this.increaseDateTimeInterval(axis, tempInterval, axis.visibleRange.interval).getTime();\n            if (actualInterval === tempInterval) {\n                break;\n            }\n        }\n        if ((axis.actualIntervalType === 'Months' || axis.actualIntervalType === 'Days')) {\n            axis.format = chart.intl.getDateFormat({\n                format: axis.labelFormat || (axis.actualIntervalType === 'Months' && !axis.skeleton ? 'y MMM' : ''),\n                type: firstToLowerCase(axis.skeletonType), skeleton: axis.skeleton || (axis.actualIntervalType === 'Days' ? 'MMMd' : '')\n            });\n        }\n        if (axis.getMaxLabelWidth) {\n            axis.getMaxLabelWidth(this.chart);\n        }\n    };\n    /**\n     * Increases a date-time interval by the specified value for the given axis.\n     *\n     * @param {Chart3DAxis} axis - The axis for which the date-time interval is increased.\n     * @param {number} value - The value by which to increase the interval.\n     * @param {number} interval - The original interval to be adjusted.\n     * @returns {Date} - The adjusted date-time interval.\n     * @private\n     */\n    DateTime3D.prototype.increaseDateTimeInterval = function (axis, value, interval) {\n        var result = new Date(value);\n        if (axis.interval) {\n            axis.isIntervalInDecimal = (interval % 1) === 0;\n            axis.visibleRange.interval = interval;\n        }\n        else {\n            interval = Math.ceil(interval);\n            axis.visibleRange.interval = interval;\n        }\n        var intervalType = axis.actualIntervalType;\n        if (axis.isIntervalInDecimal) {\n            switch (intervalType) {\n                case 'Years':\n                    result.setFullYear(result.getFullYear() + interval);\n                    return result;\n                case 'Months':\n                    result.setMonth(result.getMonth() + interval);\n                    return result;\n                case 'Days':\n                    result.setDate(result.getDate() + interval);\n                    return result;\n                case 'Hours':\n                    result.setHours(result.getHours() + interval);\n                    return result;\n                case 'Minutes':\n                    result.setMinutes(result.getMinutes() + interval);\n                    return result;\n                case 'Seconds':\n                    result.setSeconds(result.getSeconds() + interval);\n                    return result;\n            }\n        }\n        return result;\n    };\n    /**\n     * Aligns the starting date of the range for the specified axis based on the provided date and interval size.\n     *\n     * @param {Chart3DAxis} axis - The axis for which the range start is aligned.\n     * @param {number} sDate - The date in numerical format to be aligned.\n     * @param {number} intervalSize - The size of the interval used for alignment.\n     * @returns {Date} - The aligned date for the range start.\n     * @private\n     */\n    DateTime3D.prototype.alignRangeStart = function (axis, sDate, intervalSize) {\n        var sResult = new Date(sDate);\n        switch (axis.actualIntervalType) {\n            case 'Years': {\n                var year = Math.floor(Math.floor(sResult.getFullYear() / intervalSize) * intervalSize);\n                sResult = new Date(year, sResult.getMonth(), sResult.getDate(), 0, 0, 0);\n                return sResult;\n            }\n            case 'Months': {\n                var month = Math.floor(Math.floor((sResult.getMonth()) / intervalSize) * intervalSize);\n                sResult = new Date(sResult.getFullYear(), month, sResult.getDate(), 0, 0, 0);\n                return sResult;\n            }\n            case 'Days': {\n                var day = Math.floor(Math.floor((sResult.getDate()) / intervalSize) * intervalSize);\n                sResult = new Date(sResult.getFullYear(), sResult.getMonth(), day, 0, 0, 0);\n                return sResult;\n            }\n            case 'Hours': {\n                var hour = Math.floor(Math.floor((sResult.getHours()) / intervalSize) * intervalSize);\n                sResult = new Date(sResult.getFullYear(), sResult.getMonth(), sResult.getDate(), hour, 0, 0);\n                return sResult;\n            }\n            case 'Minutes': {\n                var minutes = Math.floor(Math.floor((sResult.getMinutes()) / intervalSize) * intervalSize);\n                sResult = new Date(sResult.getFullYear(), sResult.getMonth(), sResult.getDate(), sResult.getHours(), minutes, 0, 0);\n                return sResult;\n            }\n            case 'Seconds': {\n                var seconds = Math.floor(Math.floor((sResult.getSeconds()) / intervalSize) * intervalSize);\n                sResult = new Date(sResult.getFullYear(), sResult.getMonth(), sResult.getDate(), sResult.getHours(), sResult.getMinutes(), seconds, 0);\n                return sResult;\n            }\n        }\n        return sResult;\n    };\n    /**\n     * Get module name.\n     *\n     * @returns {string} - Returns the module name.\n     */\n    DateTime3D.prototype.getModuleName = function () {\n        /**\n         * Returns the module name\n         */\n        return 'DateTime3D';\n    };\n    /**\n     * To destroy the date time axis.\n     *\n     * @returns {void}\n     * @private\n     */\n    DateTime3D.prototype.destroy = function () {\n        /**\n         * Destroy method performed here\n         */\n    };\n    return DateTime3D;\n}(NiceIntervals));\nexport { DateTime3D };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}