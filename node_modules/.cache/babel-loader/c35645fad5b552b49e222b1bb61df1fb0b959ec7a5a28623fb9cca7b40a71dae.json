{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport { getPoint, withInRange, ChartLocation, animateAddPoints } from '../../common/utils/helper';\nimport { PathOption, Rect } from '@syncfusion/ej2-svg-base';\nimport { LineBase } from './line-base';\n/**\n * The `RangeStepAreaSeries` module is used to render the range step area series.\n */\nvar RangeStepAreaSeries = /** @class */function (_super) {\n  __extends(RangeStepAreaSeries, _super);\n  function RangeStepAreaSeries() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.borderDirection = '';\n    _this.prevPoint = null;\n    return _this;\n  }\n  /**\n   * Renders the Range Step Area series on the chart.\n   *\n   * @param {Series} series - The series to be rendered.\n   * @param {Axis} xAxis - The x-axis associated with the series.\n   * @param {Axis} yAxis - The y-axis associated with the series.\n   * @param {boolean} isInverted - Specifies whether the series is inverted.\n   * @param {boolean} pointAnimate - Specifies whether to animate the series point.\n   * @param {boolean} pointUpdate - Specifies whether to update the previous point.\n   * @returns {void}\n   * @private\n   */\n  RangeStepAreaSeries.prototype.render = function (series, xAxis, yAxis, isInverted, pointAnimate, pointUpdate) {\n    this.prevPoint = null;\n    var point;\n    var currentPoint;\n    var secondPoint;\n    var start = null;\n    var direction = '';\n    var lineLength = 0;\n    var command = 'M';\n    var closed = undefined;\n    var low;\n    var high;\n    var borderWidth = series.border.width ? series.border.width : 0;\n    var borderColor = series.border.color ? series.border.color : series.interior;\n    var origin = Math.max(series.yAxis.visibleRange.min, 0);\n    var visiblePoints = this.enableComplexProperty(series);\n    if (xAxis.valueType === 'Category' && xAxis.labelPlacement === 'BetweenTicks') {\n      lineLength = 0.5;\n    }\n    for (var i = 0, length_1 = visiblePoints.length; i < length_1; i++) {\n      point = visiblePoints[i];\n      point.symbolLocations = [];\n      point.regions = [];\n      low = Math.min(point.low, point.high);\n      high = Math.max(point.low, point.high);\n      if (yAxis.isAxisInverse) {\n        var temp = low;\n        low = high;\n        high = temp;\n      }\n      var lowPoint = getPoint(point.xValue, low, xAxis, yAxis, isInverted);\n      var highPoint = getPoint(point.xValue, high, xAxis, yAxis, isInverted);\n      point.symbolLocations.push(highPoint);\n      point.symbolLocations.push(lowPoint);\n      var rect = new Rect(Math.min(lowPoint.x, highPoint.x), Math.min(lowPoint.y, highPoint.y), Math.max(Math.abs(highPoint.x - lowPoint.x), series.marker.width), Math.max(Math.abs(highPoint.y - lowPoint.y), series.marker.width));\n      point.regions.push(rect);\n      //Path to connect the high points.\n      if (point.visible && withInRange(visiblePoints[point.index - 1], point, visiblePoints[point.index + 1], series)) {\n        if (start === null) {\n          start = new ChartLocation(point.xValue, 0);\n          // Start point for the current path.\n          currentPoint = getPoint(point.xValue - lineLength, origin, xAxis, yAxis, isInverted);\n          direction += command + ' ' + currentPoint.x + ' ' + currentPoint.y + ' ';\n          currentPoint = getPoint(point.xValue - lineLength, point.high > point.low ? point.high : point.low, xAxis, yAxis, isInverted);\n          direction += 'L' + ' ' + currentPoint.x + ' ' + currentPoint.y + ' ';\n          this.borderDirection += command + ' ' + currentPoint.x + ' ' + currentPoint.y + ' ';\n        }\n        // First Point to draw the RangeStepArea path.\n        if (this.prevPoint != null) {\n          currentPoint = getPoint(point.xValue, point.high > point.low ? point.high : point.low, xAxis, yAxis, isInverted);\n          secondPoint = getPoint(this.prevPoint.xValue, this.prevPoint.high > this.prevPoint.low ? this.prevPoint.high : this.prevPoint.low, xAxis, yAxis, isInverted);\n          direction += this.GetStepLineDirection(currentPoint, secondPoint, series.step, command, series, false);\n          this.borderDirection += this.GetStepLineDirection(currentPoint, secondPoint, series.step, command, series, true);\n        } else if (series.emptyPointSettings.mode === 'Gap') {\n          currentPoint = getPoint(point.xValue, point.high > point.low ? point.high : point.low, xAxis, yAxis, isInverted);\n          direction += command + ' ' + currentPoint.x + ' ' + currentPoint.y + ' ';\n          this.borderDirection += command + ' ' + currentPoint.x + ' ' + currentPoint.y + ' ';\n        }\n        closed = false;\n        command = ' L';\n        this.prevPoint = point;\n        if (i + 1 < visiblePoints.length && !visiblePoints[i + 1].visible || i === visiblePoints.length - 1) {\n          // Path to connect the low points.\n          direction = this.closeRangeStepAreaPath(visiblePoints, point, series, direction, i, xAxis, yAxis, isInverted);\n          command = 'M';\n          direction = direction.concat(' ' + 'Z ');\n          closed = true;\n          this.prevPoint = null;\n          start = null;\n        }\n      } else {\n        if (closed === false && i !== 0) {\n          direction = this.closeRangeStepAreaPath(visiblePoints, point, series, direction, i, xAxis, yAxis, isInverted);\n          closed = true;\n        }\n        command = 'M';\n        point.symbolLocations = [];\n      }\n    }\n    var options = new PathOption(series.chart.element.id + '_Series_' + series.index, series.interior, 0, 'transparent', series.opacity, series.dashArray, direction);\n    this[pointAnimate ? 'addPath' : 'appendLinePath'](options, series, '');\n    /**\n     * To draw border for the range step area chart.\n     */\n    if (series.border.width !== 0) {\n      this[pointAnimate ? 'addPath' : 'appendLinePath'](new PathOption(series.chart.element.id + '_Series_border_' + series.index, 'transparent', borderWidth, borderColor, 1, series.border.dashArray, this.borderDirection), series, '');\n      this.borderDirection = '';\n    }\n    if (!pointUpdate) {\n      this.renderMarker(series);\n    }\n  };\n  /**\n   * Calculating path direction for rendering the low points.\n   *\n   * @param {Points[]} visiblePoints - The visible data points.\n   * @param {Points} point - The current data point.\n   * @param {Series} series - The series to which the data point belongs.\n   * @param {string} direction - The direction of the series.\n   * @param {number} i - The index of the current data point.\n   * @param {Axis} xAxis - The x-axis associated with the series.\n   * @param {Axis} yAxis - The y-axis associated with the series.\n   * @param {boolean} isInverted - Specifies whether the series is inverted.\n   * @returns {string} - Returns the path direction for low direction.\n   * @private\n   */\n  RangeStepAreaSeries.prototype.closeRangeStepAreaPath = function (visiblePoints, point, series, direction, i, xAxis, yAxis, isInverted) {\n    var currentPoint;\n    var secondPoint;\n    var low;\n    var high;\n    for (var j = i; j >= 0; j--) {\n      if (visiblePoints[j].visible) {\n        point = visiblePoints[j];\n        low = Math.min(point.low, point.high);\n        high = Math.max(point.low, point.high);\n        if (yAxis.isAxisInverse) {\n          var temp = low;\n          low = high;\n          high = temp;\n        }\n        // Lowpoint for RangeStepArea path.\n        if (this.prevPoint != null) {\n          currentPoint = getPoint(point.xValue, point.low < point.high ? point.low : point.high, xAxis, yAxis, isInverted);\n          secondPoint = getPoint(this.prevPoint.xValue, this.prevPoint.low < this.prevPoint.high ? this.prevPoint.low : this.prevPoint.high, xAxis, yAxis, isInverted);\n          direction += this.GetStepLineDirection(currentPoint, secondPoint, series.step === 'Right' ? 'Left' : series.step === 'Left' ? 'Right' : series.step, 'L', series, false);\n          if (j === i) {\n            this.borderDirection += this.GetStepLineDirection(currentPoint, secondPoint, series.step === 'Right' ? 'Left' : series.step === 'Left' ? 'Right' : series.step, 'M', series, true);\n          } else {\n            this.borderDirection += this.GetStepLineDirection(currentPoint, secondPoint, series.step === 'Right' ? 'Left' : series.step === 'Left' ? 'Right' : series.step, 'L', series, true);\n          }\n        }\n      } else {\n        break;\n      }\n      this.prevPoint = point;\n    }\n    return direction;\n  };\n  /**\n   * To animate point for range step area series.\n   *\n   * @param {Series} series - Specifies the series.\n   * @param {number} point - Specifies the point.\n   * @returns {void}\n   * @private\n   */\n  RangeStepAreaSeries.prototype.updateDirection = function (series, point) {\n    this.render(series, series.xAxis, series.yAxis, series.chart.requireInvertedAxis, false, true);\n    var _loop_1 = function (i) {\n      if (series.marker && series.marker.visible) {\n        series.points[point[i]].symbolLocations.map(function (location, index) {\n          series.chart.markerRender.renderMarker(series, series.points[point[i]], location, index, true);\n        });\n      }\n      if (series.marker.dataLabel.visible && series.chart.dataLabelModule) {\n        series.chart.dataLabelModule.commonId = series.chart.element.id + '_Series_' + series.index + '_Point_';\n        series.chart.dataLabelModule.renderDataLabel(series, series.points[point[i]], null, series.marker.dataLabel);\n      }\n    };\n    for (var i = 0; i < point.length; i++) {\n      _loop_1(i);\n    }\n  };\n  RangeStepAreaSeries.prototype.addPath = function (options, series, clipRect) {\n    var points = this.appendPathElement(options, series, clipRect);\n    if (points.previousDirection !== '' && options.d !== '') {\n      var startPathCommands = points.previousDirection.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);\n      var endPathCommands = options.d.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);\n      var maxLength = Math.max(startPathCommands.length, endPathCommands.length);\n      var minLength = Math.min(startPathCommands.length, endPathCommands.length);\n      if (startPathCommands.length < endPathCommands.length) {\n        for (var i = startPathCommands.length; i < endPathCommands.length; i++) {\n          if (endPathCommands.length !== startPathCommands.length) {\n            startPathCommands.splice(Math.floor(startPathCommands.length / 2) - 1, 0, startPathCommands[Math.floor(startPathCommands.length / 2) - 1], startPathCommands[Math.floor(startPathCommands.length / 2) - 1]);\n            startPathCommands.splice(Math.floor(startPathCommands.length / 2) + 2, 0, startPathCommands[Math.floor(startPathCommands.length / 2) + 2], startPathCommands[Math.floor(startPathCommands.length / 2) + 2]);\n          }\n        }\n        animateAddPoints(points.element, options.d, series.chart.redraw, startPathCommands.join(' '), this.chart.duration);\n      } else if (startPathCommands.length > endPathCommands.length) {\n        for (var i = minLength; i < maxLength; i++) {\n          if (endPathCommands.length !== startPathCommands.length) {\n            endPathCommands.splice(2, 0, endPathCommands[2]);\n            endPathCommands.splice(endPathCommands.length - 3, 0, endPathCommands[endPathCommands.length - 3]);\n          }\n        }\n        animateAddPoints(points.element, endPathCommands.join(''), series.chart.redraw, points.previousDirection, this.chart.duration, options.d);\n      } else {\n        animateAddPoints(points.element, options.d, series.chart.redraw, points.previousDirection, this.chart.duration);\n      }\n    }\n  };\n  /**\n   * Animates the series.\n   *\n   * @param  {Series} series - Defines the series to animate.\n   * @returns {void}\n   * @private\n   */\n  RangeStepAreaSeries.prototype.doAnimation = function (series) {\n    var option = series.animation;\n    this.doLinearAnimation(series, option);\n  };\n  /**\n   * Get module name.\n   *\n   * @returns {string} - Returns the module name.\n   */\n  RangeStepAreaSeries.prototype.getModuleName = function () {\n    /**\n     * Returns the module name of the series.\n     */\n    return 'RangeStepAreaSeries';\n  };\n  /**\n   * To destroy the range step area series.\n   *\n   * @returns {void}\n   * @private\n   */\n  RangeStepAreaSeries.prototype.destroy = function () {\n    /**\n     * Destroys range step area series.\n     */\n  };\n  return RangeStepAreaSeries;\n}(LineBase);\nexport { RangeStepAreaSeries };","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","getPoint","withInRange","ChartLocation","animateAddPoints","PathOption","Rect","LineBase","RangeStepAreaSeries","_super","_this","apply","arguments","borderDirection","prevPoint","render","series","xAxis","yAxis","isInverted","pointAnimate","pointUpdate","point","currentPoint","secondPoint","start","direction","lineLength","command","closed","undefined","low","high","borderWidth","border","width","borderColor","color","interior","origin","Math","max","visibleRange","min","visiblePoints","enableComplexProperty","valueType","labelPlacement","i","length_1","length","symbolLocations","regions","isAxisInverse","temp","lowPoint","xValue","highPoint","push","rect","x","y","abs","marker","visible","index","GetStepLineDirection","step","emptyPointSettings","mode","closeRangeStepAreaPath","concat","options","chart","element","id","opacity","dashArray","renderMarker","j","updateDirection","requireInvertedAxis","_loop_1","points","map","location","markerRender","dataLabel","dataLabelModule","commonId","renderDataLabel","addPath","clipRect","appendPathElement","previousDirection","startPathCommands","match","endPathCommands","maxLength","minLength","splice","floor","redraw","join","duration","doAnimation","option","animation","doLinearAnimation","getModuleName","destroy"],"sources":["C:/Users/mkfun/Desktop/ct assignment/admin/node_modules/@syncfusion/ej2-charts/src/chart/series/range-step-area-series.js"],"sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { getPoint, withInRange, ChartLocation, animateAddPoints } from '../../common/utils/helper';\nimport { PathOption, Rect } from '@syncfusion/ej2-svg-base';\nimport { LineBase } from './line-base';\n/**\n * The `RangeStepAreaSeries` module is used to render the range step area series.\n */\nvar RangeStepAreaSeries = /** @class */ (function (_super) {\n    __extends(RangeStepAreaSeries, _super);\n    function RangeStepAreaSeries() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.borderDirection = '';\n        _this.prevPoint = null;\n        return _this;\n    }\n    /**\n     * Renders the Range Step Area series on the chart.\n     *\n     * @param {Series} series - The series to be rendered.\n     * @param {Axis} xAxis - The x-axis associated with the series.\n     * @param {Axis} yAxis - The y-axis associated with the series.\n     * @param {boolean} isInverted - Specifies whether the series is inverted.\n     * @param {boolean} pointAnimate - Specifies whether to animate the series point.\n     * @param {boolean} pointUpdate - Specifies whether to update the previous point.\n     * @returns {void}\n     * @private\n     */\n    RangeStepAreaSeries.prototype.render = function (series, xAxis, yAxis, isInverted, pointAnimate, pointUpdate) {\n        this.prevPoint = null;\n        var point;\n        var currentPoint;\n        var secondPoint;\n        var start = null;\n        var direction = '';\n        var lineLength = 0;\n        var command = 'M';\n        var closed = undefined;\n        var low;\n        var high;\n        var borderWidth = series.border.width ? series.border.width : 0;\n        var borderColor = series.border.color ? series.border.color : series.interior;\n        var origin = Math.max(series.yAxis.visibleRange.min, 0);\n        var visiblePoints = this.enableComplexProperty(series);\n        if (xAxis.valueType === 'Category' && xAxis.labelPlacement === 'BetweenTicks') {\n            lineLength = 0.5;\n        }\n        for (var i = 0, length_1 = visiblePoints.length; i < length_1; i++) {\n            point = visiblePoints[i];\n            point.symbolLocations = [];\n            point.regions = [];\n            low = Math.min(point.low, point.high);\n            high = Math.max(point.low, point.high);\n            if (yAxis.isAxisInverse) {\n                var temp = low;\n                low = high;\n                high = temp;\n            }\n            var lowPoint = getPoint(point.xValue, low, xAxis, yAxis, isInverted);\n            var highPoint = getPoint(point.xValue, high, xAxis, yAxis, isInverted);\n            point.symbolLocations.push(highPoint);\n            point.symbolLocations.push(lowPoint);\n            var rect = new Rect(Math.min(lowPoint.x, highPoint.x), Math.min(lowPoint.y, highPoint.y), Math.max(Math.abs(highPoint.x - lowPoint.x), series.marker.width), Math.max(Math.abs(highPoint.y - lowPoint.y), series.marker.width));\n            point.regions.push(rect);\n            //Path to connect the high points.\n            if (point.visible && withInRange(visiblePoints[point.index - 1], point, visiblePoints[point.index + 1], series)) {\n                if (start === null) {\n                    start = new ChartLocation(point.xValue, 0);\n                    // Start point for the current path.\n                    currentPoint = getPoint(point.xValue - lineLength, origin, xAxis, yAxis, isInverted);\n                    direction += (command + ' ' + (currentPoint.x) + ' ' + (currentPoint.y) + ' ');\n                    currentPoint = getPoint(point.xValue - lineLength, point.high > point.low ? point.high\n                        : point.low, xAxis, yAxis, isInverted);\n                    direction += ('L' + ' ' + (currentPoint.x) + ' ' + (currentPoint.y) + ' ');\n                    this.borderDirection += (command + ' ' + (currentPoint.x) + ' ' + (currentPoint.y) + ' ');\n                }\n                // First Point to draw the RangeStepArea path.\n                if (this.prevPoint != null) {\n                    currentPoint = getPoint(point.xValue, point.high > point.low ? point.high\n                        : point.low, xAxis, yAxis, isInverted);\n                    secondPoint = getPoint(this.prevPoint.xValue, this.prevPoint.high > this.prevPoint.low ? this.prevPoint.high\n                        : this.prevPoint.low, xAxis, yAxis, isInverted);\n                    direction += (this.GetStepLineDirection(currentPoint, secondPoint, series.step, command, series, false));\n                    this.borderDirection += (this.GetStepLineDirection(currentPoint, secondPoint, series.step, command, series, true));\n                }\n                else if (series.emptyPointSettings.mode === 'Gap') {\n                    currentPoint = getPoint(point.xValue, point.high > point.low ? point.high\n                        : point.low, xAxis, yAxis, isInverted);\n                    direction += command + ' ' + (currentPoint.x) + ' ' + (currentPoint.y) + ' ';\n                    this.borderDirection += command + ' ' + (currentPoint.x) + ' ' + (currentPoint.y) + ' ';\n                }\n                closed = false;\n                command = ' L';\n                this.prevPoint = point;\n                if ((i + 1 < visiblePoints.length && !visiblePoints[i + 1].visible)\n                    || i === visiblePoints.length - 1) {\n                    // Path to connect the low points.\n                    direction = this.closeRangeStepAreaPath(visiblePoints, point, series, direction, i, xAxis, yAxis, isInverted);\n                    command = 'M';\n                    direction = direction.concat(' ' + 'Z ');\n                    closed = true;\n                    this.prevPoint = null;\n                    start = null;\n                }\n            }\n            else {\n                if (closed === false && i !== 0) {\n                    direction = this.closeRangeStepAreaPath(visiblePoints, point, series, direction, i, xAxis, yAxis, isInverted);\n                    closed = true;\n                }\n                command = 'M';\n                point.symbolLocations = [];\n            }\n        }\n        var options = new PathOption(series.chart.element.id + '_Series_' + series.index, series.interior, 0, 'transparent', series.opacity, series.dashArray, direction);\n        this[pointAnimate ? 'addPath' : 'appendLinePath'](options, series, '');\n        /**\n         * To draw border for the range step area chart.\n         */\n        if (series.border.width !== 0) {\n            this[pointAnimate ? 'addPath' : 'appendLinePath'](new PathOption(series.chart.element.id + '_Series_border_' + series.index, 'transparent', borderWidth, borderColor, 1, series.border.dashArray, this.borderDirection), series, '');\n            this.borderDirection = '';\n        }\n        if (!pointUpdate) {\n            this.renderMarker(series);\n        }\n    };\n    /**\n     * Calculating path direction for rendering the low points.\n     *\n     * @param {Points[]} visiblePoints - The visible data points.\n     * @param {Points} point - The current data point.\n     * @param {Series} series - The series to which the data point belongs.\n     * @param {string} direction - The direction of the series.\n     * @param {number} i - The index of the current data point.\n     * @param {Axis} xAxis - The x-axis associated with the series.\n     * @param {Axis} yAxis - The y-axis associated with the series.\n     * @param {boolean} isInverted - Specifies whether the series is inverted.\n     * @returns {string} - Returns the path direction for low direction.\n     * @private\n     */\n    RangeStepAreaSeries.prototype.closeRangeStepAreaPath = function (visiblePoints, point, series, direction, i, xAxis, yAxis, isInverted) {\n        var currentPoint;\n        var secondPoint;\n        var low;\n        var high;\n        for (var j = i; j >= 0; j--) {\n            if (visiblePoints[j].visible) {\n                point = visiblePoints[j];\n                low = Math.min(point.low, point.high);\n                high = Math.max(point.low, point.high);\n                if (yAxis.isAxisInverse) {\n                    var temp = low;\n                    low = high;\n                    high = temp;\n                }\n                // Lowpoint for RangeStepArea path.\n                if (this.prevPoint != null) {\n                    currentPoint = getPoint(point.xValue, point.low < point.high ? point.low\n                        : point.high, xAxis, yAxis, isInverted);\n                    secondPoint = getPoint(this.prevPoint.xValue, this.prevPoint.low < this.prevPoint.high ? this.prevPoint.low\n                        : this.prevPoint.high, xAxis, yAxis, isInverted);\n                    direction += (this.GetStepLineDirection(currentPoint, secondPoint, series.step === 'Right' ? 'Left' : (series.step === 'Left' ? 'Right' : series.step), 'L', series, false));\n                    if (j === i) {\n                        this.borderDirection += (this.GetStepLineDirection(currentPoint, secondPoint, series.step === 'Right' ? 'Left' : (series.step === 'Left' ? 'Right' : series.step), 'M', series, true));\n                    }\n                    else {\n                        this.borderDirection += (this.GetStepLineDirection(currentPoint, secondPoint, series.step === 'Right' ? 'Left' : (series.step === 'Left' ? 'Right' : series.step), 'L', series, true));\n                    }\n                }\n            }\n            else {\n                break;\n            }\n            this.prevPoint = point;\n        }\n        return direction;\n    };\n    /**\n     * To animate point for range step area series.\n     *\n     * @param {Series} series - Specifies the series.\n     * @param {number} point - Specifies the point.\n     * @returns {void}\n     * @private\n     */\n    RangeStepAreaSeries.prototype.updateDirection = function (series, point) {\n        this.render(series, series.xAxis, series.yAxis, series.chart.requireInvertedAxis, false, true);\n        var _loop_1 = function (i) {\n            if (series.marker && series.marker.visible) {\n                series.points[point[i]].symbolLocations.map(function (location, index) {\n                    series.chart.markerRender.renderMarker(series, series.points[point[i]], location, index, true);\n                });\n            }\n            if (series.marker.dataLabel.visible && series.chart.dataLabelModule) {\n                series.chart.dataLabelModule.commonId = series.chart.element.id + '_Series_' + series.index + '_Point_';\n                series.chart.dataLabelModule.renderDataLabel(series, series.points[point[i]], null, series.marker.dataLabel);\n            }\n        };\n        for (var i = 0; i < point.length; i++) {\n            _loop_1(i);\n        }\n    };\n    RangeStepAreaSeries.prototype.addPath = function (options, series, clipRect) {\n        var points = this.appendPathElement(options, series, clipRect);\n        if (points.previousDirection !== '' && options.d !== '') {\n            var startPathCommands = points.previousDirection.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);\n            var endPathCommands = (options.d).match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);\n            var maxLength = Math.max(startPathCommands.length, endPathCommands.length);\n            var minLength = Math.min(startPathCommands.length, endPathCommands.length);\n            if (startPathCommands.length < endPathCommands.length) {\n                for (var i = startPathCommands.length; i < endPathCommands.length; i++) {\n                    if (endPathCommands.length !== startPathCommands.length) {\n                        startPathCommands.splice((Math.floor((startPathCommands.length / 2)) - 1), 0, startPathCommands[Math.floor((startPathCommands.length / 2)) - 1], startPathCommands[Math.floor((startPathCommands.length / 2)) - 1]);\n                        startPathCommands.splice((Math.floor((startPathCommands.length / 2)) + 2), 0, startPathCommands[Math.floor((startPathCommands.length / 2)) + 2], startPathCommands[Math.floor((startPathCommands.length / 2)) + 2]);\n                    }\n                }\n                animateAddPoints(points.element, options.d, series.chart.redraw, startPathCommands.join(' '), this.chart.duration);\n            }\n            else if (startPathCommands.length > endPathCommands.length) {\n                for (var i = minLength; i < maxLength; i++) {\n                    if (endPathCommands.length !== startPathCommands.length) {\n                        endPathCommands.splice(2, 0, endPathCommands[2]);\n                        endPathCommands.splice(endPathCommands.length - 3, 0, endPathCommands[endPathCommands.length - 3]);\n                    }\n                }\n                animateAddPoints(points.element, endPathCommands.join(''), series.chart.redraw, points.previousDirection, this.chart.duration, options.d);\n            }\n            else {\n                animateAddPoints(points.element, options.d, series.chart.redraw, points.previousDirection, this.chart.duration);\n            }\n        }\n    };\n    /**\n     * Animates the series.\n     *\n     * @param  {Series} series - Defines the series to animate.\n     * @returns {void}\n     * @private\n     */\n    RangeStepAreaSeries.prototype.doAnimation = function (series) {\n        var option = series.animation;\n        this.doLinearAnimation(series, option);\n    };\n    /**\n     * Get module name.\n     *\n     * @returns {string} - Returns the module name.\n     */\n    RangeStepAreaSeries.prototype.getModuleName = function () {\n        /**\n         * Returns the module name of the series.\n         */\n        return 'RangeStepAreaSeries';\n    };\n    /**\n     * To destroy the range step area series.\n     *\n     * @returns {void}\n     * @private\n     */\n    RangeStepAreaSeries.prototype.destroy = function () {\n        /**\n         * Destroys range step area series.\n         */\n    };\n    return RangeStepAreaSeries;\n}(LineBase));\nexport { RangeStepAreaSeries };\n"],"mappings":"AAAA,IAAIA,SAAS,GAAI,IAAI,IAAI,IAAI,CAACA,SAAS,IAAM,YAAY;EACrD,IAAIC,aAAa,GAAG,SAAAA,CAAUC,CAAC,EAAEC,CAAC,EAAE;IAChCF,aAAa,GAAGG,MAAM,CAACC,cAAc,IAChC;MAAEC,SAAS,EAAE;IAAG,CAAC,YAAYC,KAAK,IAAI,UAAUL,CAAC,EAAEC,CAAC,EAAE;MAAED,CAAC,CAACI,SAAS,GAAGH,CAAC;IAAE,CAAE,IAC5E,UAAUD,CAAC,EAAEC,CAAC,EAAE;MAAE,KAAK,IAAIK,CAAC,IAAIL,CAAC,EAAE,IAAIA,CAAC,CAACM,cAAc,CAACD,CAAC,CAAC,EAAEN,CAAC,CAACM,CAAC,CAAC,GAAGL,CAAC,CAACK,CAAC,CAAC;IAAE,CAAC;IAC9E,OAAOP,aAAa,CAACC,CAAC,EAAEC,CAAC,CAAC;EAC9B,CAAC;EACD,OAAO,UAAUD,CAAC,EAAEC,CAAC,EAAE;IACnBF,aAAa,CAACC,CAAC,EAAEC,CAAC,CAAC;IACnB,SAASO,EAAEA,CAAA,EAAG;MAAE,IAAI,CAACC,WAAW,GAAGT,CAAC;IAAE;IACtCA,CAAC,CAACU,SAAS,GAAGT,CAAC,KAAK,IAAI,GAAGC,MAAM,CAACS,MAAM,CAACV,CAAC,CAAC,IAAIO,EAAE,CAACE,SAAS,GAAGT,CAAC,CAACS,SAAS,EAAE,IAAIF,EAAE,CAAC,CAAC,CAAC;EACxF,CAAC;AACL,CAAC,CAAE,CAAC;AACJ,SAASI,QAAQ,EAAEC,WAAW,EAAEC,aAAa,EAAEC,gBAAgB,QAAQ,2BAA2B;AAClG,SAASC,UAAU,EAAEC,IAAI,QAAQ,0BAA0B;AAC3D,SAASC,QAAQ,QAAQ,aAAa;AACtC;AACA;AACA;AACA,IAAIC,mBAAmB,GAAG,aAAe,UAAUC,MAAM,EAAE;EACvDtB,SAAS,CAACqB,mBAAmB,EAAEC,MAAM,CAAC;EACtC,SAASD,mBAAmBA,CAAA,EAAG;IAC3B,IAAIE,KAAK,GAAGD,MAAM,KAAK,IAAI,IAAIA,MAAM,CAACE,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC,IAAI,IAAI;IACpEF,KAAK,CAACG,eAAe,GAAG,EAAE;IAC1BH,KAAK,CAACI,SAAS,GAAG,IAAI;IACtB,OAAOJ,KAAK;EAChB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIF,mBAAmB,CAACT,SAAS,CAACgB,MAAM,GAAG,UAAUC,MAAM,EAAEC,KAAK,EAAEC,KAAK,EAAEC,UAAU,EAAEC,YAAY,EAAEC,WAAW,EAAE;IAC1G,IAAI,CAACP,SAAS,GAAG,IAAI;IACrB,IAAIQ,KAAK;IACT,IAAIC,YAAY;IAChB,IAAIC,WAAW;IACf,IAAIC,KAAK,GAAG,IAAI;IAChB,IAAIC,SAAS,GAAG,EAAE;IAClB,IAAIC,UAAU,GAAG,CAAC;IAClB,IAAIC,OAAO,GAAG,GAAG;IACjB,IAAIC,MAAM,GAAGC,SAAS;IACtB,IAAIC,GAAG;IACP,IAAIC,IAAI;IACR,IAAIC,WAAW,GAAGjB,MAAM,CAACkB,MAAM,CAACC,KAAK,GAAGnB,MAAM,CAACkB,MAAM,CAACC,KAAK,GAAG,CAAC;IAC/D,IAAIC,WAAW,GAAGpB,MAAM,CAACkB,MAAM,CAACG,KAAK,GAAGrB,MAAM,CAACkB,MAAM,CAACG,KAAK,GAAGrB,MAAM,CAACsB,QAAQ;IAC7E,IAAIC,MAAM,GAAGC,IAAI,CAACC,GAAG,CAACzB,MAAM,CAACE,KAAK,CAACwB,YAAY,CAACC,GAAG,EAAE,CAAC,CAAC;IACvD,IAAIC,aAAa,GAAG,IAAI,CAACC,qBAAqB,CAAC7B,MAAM,CAAC;IACtD,IAAIC,KAAK,CAAC6B,SAAS,KAAK,UAAU,IAAI7B,KAAK,CAAC8B,cAAc,KAAK,cAAc,EAAE;MAC3EpB,UAAU,GAAG,GAAG;IACpB;IACA,KAAK,IAAIqB,CAAC,GAAG,CAAC,EAAEC,QAAQ,GAAGL,aAAa,CAACM,MAAM,EAAEF,CAAC,GAAGC,QAAQ,EAAED,CAAC,EAAE,EAAE;MAChE1B,KAAK,GAAGsB,aAAa,CAACI,CAAC,CAAC;MACxB1B,KAAK,CAAC6B,eAAe,GAAG,EAAE;MAC1B7B,KAAK,CAAC8B,OAAO,GAAG,EAAE;MAClBrB,GAAG,GAAGS,IAAI,CAACG,GAAG,CAACrB,KAAK,CAACS,GAAG,EAAET,KAAK,CAACU,IAAI,CAAC;MACrCA,IAAI,GAAGQ,IAAI,CAACC,GAAG,CAACnB,KAAK,CAACS,GAAG,EAAET,KAAK,CAACU,IAAI,CAAC;MACtC,IAAId,KAAK,CAACmC,aAAa,EAAE;QACrB,IAAIC,IAAI,GAAGvB,GAAG;QACdA,GAAG,GAAGC,IAAI;QACVA,IAAI,GAAGsB,IAAI;MACf;MACA,IAAIC,QAAQ,GAAGtD,QAAQ,CAACqB,KAAK,CAACkC,MAAM,EAAEzB,GAAG,EAAEd,KAAK,EAAEC,KAAK,EAAEC,UAAU,CAAC;MACpE,IAAIsC,SAAS,GAAGxD,QAAQ,CAACqB,KAAK,CAACkC,MAAM,EAAExB,IAAI,EAAEf,KAAK,EAAEC,KAAK,EAAEC,UAAU,CAAC;MACtEG,KAAK,CAAC6B,eAAe,CAACO,IAAI,CAACD,SAAS,CAAC;MACrCnC,KAAK,CAAC6B,eAAe,CAACO,IAAI,CAACH,QAAQ,CAAC;MACpC,IAAII,IAAI,GAAG,IAAIrD,IAAI,CAACkC,IAAI,CAACG,GAAG,CAACY,QAAQ,CAACK,CAAC,EAAEH,SAAS,CAACG,CAAC,CAAC,EAAEpB,IAAI,CAACG,GAAG,CAACY,QAAQ,CAACM,CAAC,EAAEJ,SAAS,CAACI,CAAC,CAAC,EAAErB,IAAI,CAACC,GAAG,CAACD,IAAI,CAACsB,GAAG,CAACL,SAAS,CAACG,CAAC,GAAGL,QAAQ,CAACK,CAAC,CAAC,EAAE5C,MAAM,CAAC+C,MAAM,CAAC5B,KAAK,CAAC,EAAEK,IAAI,CAACC,GAAG,CAACD,IAAI,CAACsB,GAAG,CAACL,SAAS,CAACI,CAAC,GAAGN,QAAQ,CAACM,CAAC,CAAC,EAAE7C,MAAM,CAAC+C,MAAM,CAAC5B,KAAK,CAAC,CAAC;MAC/Nb,KAAK,CAAC8B,OAAO,CAACM,IAAI,CAACC,IAAI,CAAC;MACxB;MACA,IAAIrC,KAAK,CAAC0C,OAAO,IAAI9D,WAAW,CAAC0C,aAAa,CAACtB,KAAK,CAAC2C,KAAK,GAAG,CAAC,CAAC,EAAE3C,KAAK,EAAEsB,aAAa,CAACtB,KAAK,CAAC2C,KAAK,GAAG,CAAC,CAAC,EAAEjD,MAAM,CAAC,EAAE;QAC7G,IAAIS,KAAK,KAAK,IAAI,EAAE;UAChBA,KAAK,GAAG,IAAItB,aAAa,CAACmB,KAAK,CAACkC,MAAM,EAAE,CAAC,CAAC;UAC1C;UACAjC,YAAY,GAAGtB,QAAQ,CAACqB,KAAK,CAACkC,MAAM,GAAG7B,UAAU,EAAEY,MAAM,EAAEtB,KAAK,EAAEC,KAAK,EAAEC,UAAU,CAAC;UACpFO,SAAS,IAAKE,OAAO,GAAG,GAAG,GAAIL,YAAY,CAACqC,CAAE,GAAG,GAAG,GAAIrC,YAAY,CAACsC,CAAE,GAAG,GAAI;UAC9EtC,YAAY,GAAGtB,QAAQ,CAACqB,KAAK,CAACkC,MAAM,GAAG7B,UAAU,EAAEL,KAAK,CAACU,IAAI,GAAGV,KAAK,CAACS,GAAG,GAAGT,KAAK,CAACU,IAAI,GAChFV,KAAK,CAACS,GAAG,EAAEd,KAAK,EAAEC,KAAK,EAAEC,UAAU,CAAC;UAC1CO,SAAS,IAAK,GAAG,GAAG,GAAG,GAAIH,YAAY,CAACqC,CAAE,GAAG,GAAG,GAAIrC,YAAY,CAACsC,CAAE,GAAG,GAAI;UAC1E,IAAI,CAAChD,eAAe,IAAKe,OAAO,GAAG,GAAG,GAAIL,YAAY,CAACqC,CAAE,GAAG,GAAG,GAAIrC,YAAY,CAACsC,CAAE,GAAG,GAAI;QAC7F;QACA;QACA,IAAI,IAAI,CAAC/C,SAAS,IAAI,IAAI,EAAE;UACxBS,YAAY,GAAGtB,QAAQ,CAACqB,KAAK,CAACkC,MAAM,EAAElC,KAAK,CAACU,IAAI,GAAGV,KAAK,CAACS,GAAG,GAAGT,KAAK,CAACU,IAAI,GACnEV,KAAK,CAACS,GAAG,EAAEd,KAAK,EAAEC,KAAK,EAAEC,UAAU,CAAC;UAC1CK,WAAW,GAAGvB,QAAQ,CAAC,IAAI,CAACa,SAAS,CAAC0C,MAAM,EAAE,IAAI,CAAC1C,SAAS,CAACkB,IAAI,GAAG,IAAI,CAAClB,SAAS,CAACiB,GAAG,GAAG,IAAI,CAACjB,SAAS,CAACkB,IAAI,GACtG,IAAI,CAAClB,SAAS,CAACiB,GAAG,EAAEd,KAAK,EAAEC,KAAK,EAAEC,UAAU,CAAC;UACnDO,SAAS,IAAK,IAAI,CAACwC,oBAAoB,CAAC3C,YAAY,EAAEC,WAAW,EAAER,MAAM,CAACmD,IAAI,EAAEvC,OAAO,EAAEZ,MAAM,EAAE,KAAK,CAAE;UACxG,IAAI,CAACH,eAAe,IAAK,IAAI,CAACqD,oBAAoB,CAAC3C,YAAY,EAAEC,WAAW,EAAER,MAAM,CAACmD,IAAI,EAAEvC,OAAO,EAAEZ,MAAM,EAAE,IAAI,CAAE;QACtH,CAAC,MACI,IAAIA,MAAM,CAACoD,kBAAkB,CAACC,IAAI,KAAK,KAAK,EAAE;UAC/C9C,YAAY,GAAGtB,QAAQ,CAACqB,KAAK,CAACkC,MAAM,EAAElC,KAAK,CAACU,IAAI,GAAGV,KAAK,CAACS,GAAG,GAAGT,KAAK,CAACU,IAAI,GACnEV,KAAK,CAACS,GAAG,EAAEd,KAAK,EAAEC,KAAK,EAAEC,UAAU,CAAC;UAC1CO,SAAS,IAAIE,OAAO,GAAG,GAAG,GAAIL,YAAY,CAACqC,CAAE,GAAG,GAAG,GAAIrC,YAAY,CAACsC,CAAE,GAAG,GAAG;UAC5E,IAAI,CAAChD,eAAe,IAAIe,OAAO,GAAG,GAAG,GAAIL,YAAY,CAACqC,CAAE,GAAG,GAAG,GAAIrC,YAAY,CAACsC,CAAE,GAAG,GAAG;QAC3F;QACAhC,MAAM,GAAG,KAAK;QACdD,OAAO,GAAG,IAAI;QACd,IAAI,CAACd,SAAS,GAAGQ,KAAK;QACtB,IAAK0B,CAAC,GAAG,CAAC,GAAGJ,aAAa,CAACM,MAAM,IAAI,CAACN,aAAa,CAACI,CAAC,GAAG,CAAC,CAAC,CAACgB,OAAO,IAC3DhB,CAAC,KAAKJ,aAAa,CAACM,MAAM,GAAG,CAAC,EAAE;UACnC;UACAxB,SAAS,GAAG,IAAI,CAAC4C,sBAAsB,CAAC1B,aAAa,EAAEtB,KAAK,EAAEN,MAAM,EAAEU,SAAS,EAAEsB,CAAC,EAAE/B,KAAK,EAAEC,KAAK,EAAEC,UAAU,CAAC;UAC7GS,OAAO,GAAG,GAAG;UACbF,SAAS,GAAGA,SAAS,CAAC6C,MAAM,CAAC,GAAG,GAAG,IAAI,CAAC;UACxC1C,MAAM,GAAG,IAAI;UACb,IAAI,CAACf,SAAS,GAAG,IAAI;UACrBW,KAAK,GAAG,IAAI;QAChB;MACJ,CAAC,MACI;QACD,IAAII,MAAM,KAAK,KAAK,IAAImB,CAAC,KAAK,CAAC,EAAE;UAC7BtB,SAAS,GAAG,IAAI,CAAC4C,sBAAsB,CAAC1B,aAAa,EAAEtB,KAAK,EAAEN,MAAM,EAAEU,SAAS,EAAEsB,CAAC,EAAE/B,KAAK,EAAEC,KAAK,EAAEC,UAAU,CAAC;UAC7GU,MAAM,GAAG,IAAI;QACjB;QACAD,OAAO,GAAG,GAAG;QACbN,KAAK,CAAC6B,eAAe,GAAG,EAAE;MAC9B;IACJ;IACA,IAAIqB,OAAO,GAAG,IAAInE,UAAU,CAACW,MAAM,CAACyD,KAAK,CAACC,OAAO,CAACC,EAAE,GAAG,UAAU,GAAG3D,MAAM,CAACiD,KAAK,EAAEjD,MAAM,CAACsB,QAAQ,EAAE,CAAC,EAAE,aAAa,EAAEtB,MAAM,CAAC4D,OAAO,EAAE5D,MAAM,CAAC6D,SAAS,EAAEnD,SAAS,CAAC;IACjK,IAAI,CAACN,YAAY,GAAG,SAAS,GAAG,gBAAgB,CAAC,CAACoD,OAAO,EAAExD,MAAM,EAAE,EAAE,CAAC;IACtE;AACR;AACA;IACQ,IAAIA,MAAM,CAACkB,MAAM,CAACC,KAAK,KAAK,CAAC,EAAE;MAC3B,IAAI,CAACf,YAAY,GAAG,SAAS,GAAG,gBAAgB,CAAC,CAAC,IAAIf,UAAU,CAACW,MAAM,CAACyD,KAAK,CAACC,OAAO,CAACC,EAAE,GAAG,iBAAiB,GAAG3D,MAAM,CAACiD,KAAK,EAAE,aAAa,EAAEhC,WAAW,EAAEG,WAAW,EAAE,CAAC,EAAEpB,MAAM,CAACkB,MAAM,CAAC2C,SAAS,EAAE,IAAI,CAAChE,eAAe,CAAC,EAAEG,MAAM,EAAE,EAAE,CAAC;MACpO,IAAI,CAACH,eAAe,GAAG,EAAE;IAC7B;IACA,IAAI,CAACQ,WAAW,EAAE;MACd,IAAI,CAACyD,YAAY,CAAC9D,MAAM,CAAC;IAC7B;EACJ,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIR,mBAAmB,CAACT,SAAS,CAACuE,sBAAsB,GAAG,UAAU1B,aAAa,EAAEtB,KAAK,EAAEN,MAAM,EAAEU,SAAS,EAAEsB,CAAC,EAAE/B,KAAK,EAAEC,KAAK,EAAEC,UAAU,EAAE;IACnI,IAAII,YAAY;IAChB,IAAIC,WAAW;IACf,IAAIO,GAAG;IACP,IAAIC,IAAI;IACR,KAAK,IAAI+C,CAAC,GAAG/B,CAAC,EAAE+B,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MACzB,IAAInC,aAAa,CAACmC,CAAC,CAAC,CAACf,OAAO,EAAE;QAC1B1C,KAAK,GAAGsB,aAAa,CAACmC,CAAC,CAAC;QACxBhD,GAAG,GAAGS,IAAI,CAACG,GAAG,CAACrB,KAAK,CAACS,GAAG,EAAET,KAAK,CAACU,IAAI,CAAC;QACrCA,IAAI,GAAGQ,IAAI,CAACC,GAAG,CAACnB,KAAK,CAACS,GAAG,EAAET,KAAK,CAACU,IAAI,CAAC;QACtC,IAAId,KAAK,CAACmC,aAAa,EAAE;UACrB,IAAIC,IAAI,GAAGvB,GAAG;UACdA,GAAG,GAAGC,IAAI;UACVA,IAAI,GAAGsB,IAAI;QACf;QACA;QACA,IAAI,IAAI,CAACxC,SAAS,IAAI,IAAI,EAAE;UACxBS,YAAY,GAAGtB,QAAQ,CAACqB,KAAK,CAACkC,MAAM,EAAElC,KAAK,CAACS,GAAG,GAAGT,KAAK,CAACU,IAAI,GAAGV,KAAK,CAACS,GAAG,GAClET,KAAK,CAACU,IAAI,EAAEf,KAAK,EAAEC,KAAK,EAAEC,UAAU,CAAC;UAC3CK,WAAW,GAAGvB,QAAQ,CAAC,IAAI,CAACa,SAAS,CAAC0C,MAAM,EAAE,IAAI,CAAC1C,SAAS,CAACiB,GAAG,GAAG,IAAI,CAACjB,SAAS,CAACkB,IAAI,GAAG,IAAI,CAAClB,SAAS,CAACiB,GAAG,GACrG,IAAI,CAACjB,SAAS,CAACkB,IAAI,EAAEf,KAAK,EAAEC,KAAK,EAAEC,UAAU,CAAC;UACpDO,SAAS,IAAK,IAAI,CAACwC,oBAAoB,CAAC3C,YAAY,EAAEC,WAAW,EAAER,MAAM,CAACmD,IAAI,KAAK,OAAO,GAAG,MAAM,GAAInD,MAAM,CAACmD,IAAI,KAAK,MAAM,GAAG,OAAO,GAAGnD,MAAM,CAACmD,IAAK,EAAE,GAAG,EAAEnD,MAAM,EAAE,KAAK,CAAE;UAC5K,IAAI+D,CAAC,KAAK/B,CAAC,EAAE;YACT,IAAI,CAACnC,eAAe,IAAK,IAAI,CAACqD,oBAAoB,CAAC3C,YAAY,EAAEC,WAAW,EAAER,MAAM,CAACmD,IAAI,KAAK,OAAO,GAAG,MAAM,GAAInD,MAAM,CAACmD,IAAI,KAAK,MAAM,GAAG,OAAO,GAAGnD,MAAM,CAACmD,IAAK,EAAE,GAAG,EAAEnD,MAAM,EAAE,IAAI,CAAE;UAC1L,CAAC,MACI;YACD,IAAI,CAACH,eAAe,IAAK,IAAI,CAACqD,oBAAoB,CAAC3C,YAAY,EAAEC,WAAW,EAAER,MAAM,CAACmD,IAAI,KAAK,OAAO,GAAG,MAAM,GAAInD,MAAM,CAACmD,IAAI,KAAK,MAAM,GAAG,OAAO,GAAGnD,MAAM,CAACmD,IAAK,EAAE,GAAG,EAAEnD,MAAM,EAAE,IAAI,CAAE;UAC1L;QACJ;MACJ,CAAC,MACI;QACD;MACJ;MACA,IAAI,CAACF,SAAS,GAAGQ,KAAK;IAC1B;IACA,OAAOI,SAAS;EACpB,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIlB,mBAAmB,CAACT,SAAS,CAACiF,eAAe,GAAG,UAAUhE,MAAM,EAAEM,KAAK,EAAE;IACrE,IAAI,CAACP,MAAM,CAACC,MAAM,EAAEA,MAAM,CAACC,KAAK,EAAED,MAAM,CAACE,KAAK,EAAEF,MAAM,CAACyD,KAAK,CAACQ,mBAAmB,EAAE,KAAK,EAAE,IAAI,CAAC;IAC9F,IAAIC,OAAO,GAAG,SAAAA,CAAUlC,CAAC,EAAE;MACvB,IAAIhC,MAAM,CAAC+C,MAAM,IAAI/C,MAAM,CAAC+C,MAAM,CAACC,OAAO,EAAE;QACxChD,MAAM,CAACmE,MAAM,CAAC7D,KAAK,CAAC0B,CAAC,CAAC,CAAC,CAACG,eAAe,CAACiC,GAAG,CAAC,UAAUC,QAAQ,EAAEpB,KAAK,EAAE;UACnEjD,MAAM,CAACyD,KAAK,CAACa,YAAY,CAACR,YAAY,CAAC9D,MAAM,EAAEA,MAAM,CAACmE,MAAM,CAAC7D,KAAK,CAAC0B,CAAC,CAAC,CAAC,EAAEqC,QAAQ,EAAEpB,KAAK,EAAE,IAAI,CAAC;QAClG,CAAC,CAAC;MACN;MACA,IAAIjD,MAAM,CAAC+C,MAAM,CAACwB,SAAS,CAACvB,OAAO,IAAIhD,MAAM,CAACyD,KAAK,CAACe,eAAe,EAAE;QACjExE,MAAM,CAACyD,KAAK,CAACe,eAAe,CAACC,QAAQ,GAAGzE,MAAM,CAACyD,KAAK,CAACC,OAAO,CAACC,EAAE,GAAG,UAAU,GAAG3D,MAAM,CAACiD,KAAK,GAAG,SAAS;QACvGjD,MAAM,CAACyD,KAAK,CAACe,eAAe,CAACE,eAAe,CAAC1E,MAAM,EAAEA,MAAM,CAACmE,MAAM,CAAC7D,KAAK,CAAC0B,CAAC,CAAC,CAAC,EAAE,IAAI,EAAEhC,MAAM,CAAC+C,MAAM,CAACwB,SAAS,CAAC;MAChH;IACJ,CAAC;IACD,KAAK,IAAIvC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG1B,KAAK,CAAC4B,MAAM,EAAEF,CAAC,EAAE,EAAE;MACnCkC,OAAO,CAAClC,CAAC,CAAC;IACd;EACJ,CAAC;EACDxC,mBAAmB,CAACT,SAAS,CAAC4F,OAAO,GAAG,UAAUnB,OAAO,EAAExD,MAAM,EAAE4E,QAAQ,EAAE;IACzE,IAAIT,MAAM,GAAG,IAAI,CAACU,iBAAiB,CAACrB,OAAO,EAAExD,MAAM,EAAE4E,QAAQ,CAAC;IAC9D,IAAIT,MAAM,CAACW,iBAAiB,KAAK,EAAE,IAAItB,OAAO,CAACnF,CAAC,KAAK,EAAE,EAAE;MACrD,IAAI0G,iBAAiB,GAAGZ,MAAM,CAACW,iBAAiB,CAACE,KAAK,CAAC,6BAA6B,CAAC;MACrF,IAAIC,eAAe,GAAIzB,OAAO,CAACnF,CAAC,CAAE2G,KAAK,CAAC,6BAA6B,CAAC;MACtE,IAAIE,SAAS,GAAG1D,IAAI,CAACC,GAAG,CAACsD,iBAAiB,CAAC7C,MAAM,EAAE+C,eAAe,CAAC/C,MAAM,CAAC;MAC1E,IAAIiD,SAAS,GAAG3D,IAAI,CAACG,GAAG,CAACoD,iBAAiB,CAAC7C,MAAM,EAAE+C,eAAe,CAAC/C,MAAM,CAAC;MAC1E,IAAI6C,iBAAiB,CAAC7C,MAAM,GAAG+C,eAAe,CAAC/C,MAAM,EAAE;QACnD,KAAK,IAAIF,CAAC,GAAG+C,iBAAiB,CAAC7C,MAAM,EAAEF,CAAC,GAAGiD,eAAe,CAAC/C,MAAM,EAAEF,CAAC,EAAE,EAAE;UACpE,IAAIiD,eAAe,CAAC/C,MAAM,KAAK6C,iBAAiB,CAAC7C,MAAM,EAAE;YACrD6C,iBAAiB,CAACK,MAAM,CAAE5D,IAAI,CAAC6D,KAAK,CAAEN,iBAAiB,CAAC7C,MAAM,GAAG,CAAE,CAAC,GAAG,CAAC,EAAG,CAAC,EAAE6C,iBAAiB,CAACvD,IAAI,CAAC6D,KAAK,CAAEN,iBAAiB,CAAC7C,MAAM,GAAG,CAAE,CAAC,GAAG,CAAC,CAAC,EAAE6C,iBAAiB,CAACvD,IAAI,CAAC6D,KAAK,CAAEN,iBAAiB,CAAC7C,MAAM,GAAG,CAAE,CAAC,GAAG,CAAC,CAAC,CAAC;YACnN6C,iBAAiB,CAACK,MAAM,CAAE5D,IAAI,CAAC6D,KAAK,CAAEN,iBAAiB,CAAC7C,MAAM,GAAG,CAAE,CAAC,GAAG,CAAC,EAAG,CAAC,EAAE6C,iBAAiB,CAACvD,IAAI,CAAC6D,KAAK,CAAEN,iBAAiB,CAAC7C,MAAM,GAAG,CAAE,CAAC,GAAG,CAAC,CAAC,EAAE6C,iBAAiB,CAACvD,IAAI,CAAC6D,KAAK,CAAEN,iBAAiB,CAAC7C,MAAM,GAAG,CAAE,CAAC,GAAG,CAAC,CAAC,CAAC;UACvN;QACJ;QACA9C,gBAAgB,CAAC+E,MAAM,CAACT,OAAO,EAAEF,OAAO,CAACnF,CAAC,EAAE2B,MAAM,CAACyD,KAAK,CAAC6B,MAAM,EAAEP,iBAAiB,CAACQ,IAAI,CAAC,GAAG,CAAC,EAAE,IAAI,CAAC9B,KAAK,CAAC+B,QAAQ,CAAC;MACtH,CAAC,MACI,IAAIT,iBAAiB,CAAC7C,MAAM,GAAG+C,eAAe,CAAC/C,MAAM,EAAE;QACxD,KAAK,IAAIF,CAAC,GAAGmD,SAAS,EAAEnD,CAAC,GAAGkD,SAAS,EAAElD,CAAC,EAAE,EAAE;UACxC,IAAIiD,eAAe,CAAC/C,MAAM,KAAK6C,iBAAiB,CAAC7C,MAAM,EAAE;YACrD+C,eAAe,CAACG,MAAM,CAAC,CAAC,EAAE,CAAC,EAAEH,eAAe,CAAC,CAAC,CAAC,CAAC;YAChDA,eAAe,CAACG,MAAM,CAACH,eAAe,CAAC/C,MAAM,GAAG,CAAC,EAAE,CAAC,EAAE+C,eAAe,CAACA,eAAe,CAAC/C,MAAM,GAAG,CAAC,CAAC,CAAC;UACtG;QACJ;QACA9C,gBAAgB,CAAC+E,MAAM,CAACT,OAAO,EAAEuB,eAAe,CAACM,IAAI,CAAC,EAAE,CAAC,EAAEvF,MAAM,CAACyD,KAAK,CAAC6B,MAAM,EAAEnB,MAAM,CAACW,iBAAiB,EAAE,IAAI,CAACrB,KAAK,CAAC+B,QAAQ,EAAEhC,OAAO,CAACnF,CAAC,CAAC;MAC7I,CAAC,MACI;QACDe,gBAAgB,CAAC+E,MAAM,CAACT,OAAO,EAAEF,OAAO,CAACnF,CAAC,EAAE2B,MAAM,CAACyD,KAAK,CAAC6B,MAAM,EAAEnB,MAAM,CAACW,iBAAiB,EAAE,IAAI,CAACrB,KAAK,CAAC+B,QAAQ,CAAC;MACnH;IACJ;EACJ,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;EACIhG,mBAAmB,CAACT,SAAS,CAAC0G,WAAW,GAAG,UAAUzF,MAAM,EAAE;IAC1D,IAAI0F,MAAM,GAAG1F,MAAM,CAAC2F,SAAS;IAC7B,IAAI,CAACC,iBAAiB,CAAC5F,MAAM,EAAE0F,MAAM,CAAC;EAC1C,CAAC;EACD;AACJ;AACA;AACA;AACA;EACIlG,mBAAmB,CAACT,SAAS,CAAC8G,aAAa,GAAG,YAAY;IACtD;AACR;AACA;IACQ,OAAO,qBAAqB;EAChC,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACIrG,mBAAmB,CAACT,SAAS,CAAC+G,OAAO,GAAG,YAAY;IAChD;AACR;AACA;EAFQ,CAGH;EACD,OAAOtG,mBAAmB;AAC9B,CAAC,CAACD,QAAQ,CAAE;AACZ,SAASC,mBAAmB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}