{"ast":null,"code":"import { getAnimationFunction, pathAnimation, getElement, animateAddPoints } from '../../common/utils/helper';\nimport { Rect } from '@syncfusion/ej2-svg-base';\nimport { Animation, animationMode, isNullOrUndefined } from '@syncfusion/ej2-base';\n/**\n * Base class for line-type series.\n * This class provides common properties and methods for line-type series in the chart.\n *\n * @private\n */\nvar LineBase = /** @class */function () {\n  /**\n   * Initializes the tooltip module for the chart.\n   *\n   * @param {Chart} [chartModule] - The chart instance to which the tooltip module is initialized.\n   */\n  function LineBase(chartModule) {\n    this.chart = chartModule;\n  }\n  /**\n   * Enhances the performance of the chart by enabling complex properties.\n   *\n   * @param {Series} series - The series for which complex properties are enabled.\n   * @returns {Points[]} An array of points.\n   * @private\n   */\n  LineBase.prototype.enableComplexProperty = function (series) {\n    var tempPoints = [];\n    var tempPoints2 = [];\n    var xVisibleRange = series.xAxis.visibleRange;\n    var yVisibleRange = series.yAxis.visibleRange;\n    var seriesPoints = series.points;\n    var areaBounds = series.clipRect;\n    var xTolerance = this.chart && this.chart.zoomRedraw && this.chart.redraw ? this.previousX : Math.abs(xVisibleRange.delta / areaBounds.width);\n    var yTolerance = this.chart && this.chart.zoomRedraw && this.chart.redraw ? this.previousY : Math.abs(yVisibleRange.delta / areaBounds.height);\n    var prevXValue = seriesPoints[0] && seriesPoints[0].xValue > xTolerance ? 0 : xTolerance;\n    var prevYValue = seriesPoints[0] && seriesPoints[0].y > yTolerance ? 0 : yTolerance;\n    this.previousX = xTolerance;\n    this.previousY = yTolerance;\n    var xVal = 0;\n    var yVal = 0;\n    for (var _i = 0, seriesPoints_1 = seriesPoints; _i < seriesPoints_1.length; _i++) {\n      var currentPoint = seriesPoints_1[_i];\n      currentPoint.symbolLocations = [];\n      xVal = !isNullOrUndefined(currentPoint.xValue) ? currentPoint.xValue : xVisibleRange.min;\n      yVal = !isNullOrUndefined(currentPoint.yValue) ? currentPoint.yValue : yVisibleRange.min;\n      if (Math.abs(prevXValue - xVal) >= xTolerance || Math.abs(prevYValue - yVal) >= yTolerance) {\n        tempPoints.push(currentPoint);\n        prevXValue = xVal;\n        prevYValue = yVal;\n      }\n    }\n    var tempPoint;\n    for (var i = 0; i < tempPoints.length; i++) {\n      tempPoint = tempPoints[i];\n      if (isNullOrUndefined(tempPoint.x) || series.category === 'Indicator' && (isNaN(tempPoint.xValue) || isNaN(tempPoint.yValue))) {\n        continue;\n      } else {\n        tempPoints2.push(tempPoint);\n      }\n    }\n    return tempPoints2;\n  };\n  /**\n   * To generate the line path direction.\n   *\n   * @param {Points} firstPoint firstPoint\n   * @param {Points} secondPoint secondPoint\n   * @param {Series} series series\n   * @param {boolean} isInverted isInverted\n   * @param {Function} getPointLocation getPointLocation\n   * @param {string} startPoint startPoint\n   * @returns {string} get line path direction\n   * @private\n   */\n  LineBase.prototype.getLineDirection = function (firstPoint, secondPoint, series, isInverted, getPointLocation, startPoint) {\n    var direction = '';\n    if (firstPoint != null) {\n      var point1 = getPointLocation(firstPoint.xValue, firstPoint.yValue, series.xAxis, series.yAxis, isInverted, series);\n      var point2 = getPointLocation(secondPoint.xValue, secondPoint.yValue, series.xAxis, series.yAxis, isInverted, series);\n      direction = startPoint + ' ' + point1.x + ' ' + point1.y + ' ' + 'L' + ' ' + point2.x + ' ' + point2.y + ' ';\n    }\n    return direction;\n  };\n  /**\n   * Appends a line path to the chart.\n   *\n   * @param {PathOption} options - The options for the path.\n   * @param {Series} series - The series to which the path belongs.\n   * @param {string} clipRect - The clipping rectangle for the path.\n   * @returns {void}\n   * @private\n   */\n  LineBase.prototype.appendLinePath = function (options, series, clipRect) {\n    var points = this.appendPathElement(options, series, clipRect);\n    pathAnimation(points.element, options.d, series.chart.redraw, points.previousDirection, points.chart.duration);\n  };\n  LineBase.prototype.appendPathElement = function (options, series, clipRect) {\n    var element = getElement(options.id);\n    var chart = series.chart;\n    var previousDirection = element ? element.getAttribute('d') : null;\n    var htmlObject = series.chart.renderer.drawPath(options, new Int32Array([series.clipRect.x, series.clipRect.y]));\n    if (htmlObject) {\n      htmlObject.setAttribute('clip-path', clipRect);\n    }\n    if (series.category === 'TrendLine' && htmlObject) {\n      var trendline = chart.series[series.sourceIndex].trendlines[series.index];\n      if (!trendline.marker.visible) {\n        htmlObject.setAttribute('tabindex', trendline.accessibility.focusable ? String(trendline.accessibility.tabIndex) : '-1');\n      }\n      htmlObject.setAttribute('role', trendline.accessibility.accessibilityRole ? trendline.accessibility.accessibilityRole : '');\n      htmlObject.setAttribute('aria-label', trendline.accessibility.accessibilityDescription ? trendline.accessibility.accessibilityDescription : '');\n    }\n    series.pathElement = htmlObject;\n    if (!series.chart.enableCanvas) {\n      series.seriesElement.appendChild(htmlObject);\n    }\n    series.isRectSeries = false;\n    return {\n      element: element,\n      previousDirection: previousDirection,\n      chart: chart\n    };\n  };\n  /**\n   * Adds a line path to equate the start and end paths.\n   *\n   * @param {PathOption} options - The options for the path.\n   * @param {Series} series - The series to which the path belongs.\n   * @param {string} clipRect - The clip rectangle for the path.\n   * @returns {void}\n   * @private\n   */\n  LineBase.prototype.addPath = function (options, series, clipRect) {\n    var points = this.appendPathElement(options, series, clipRect);\n    if (points.previousDirection !== '' && options.d !== '') {\n      var startPathCommands = points.previousDirection.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);\n      var endPathCommands = options.d.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);\n      var maxLength = Math.max(startPathCommands.length, endPathCommands.length);\n      var minLength = Math.min(startPathCommands.length, endPathCommands.length);\n      if (startPathCommands.length < endPathCommands.length) {\n        for (var i = minLength; i < maxLength; i++) {\n          if (endPathCommands.length !== startPathCommands.length) {\n            startPathCommands.push(startPathCommands[startPathCommands.length - 1].replace('M', 'L'));\n          }\n        }\n        animateAddPoints(points.element, options.d, series.chart.redraw, startPathCommands.join(' '), this.chart.duration);\n      } else if (startPathCommands.length > endPathCommands.length) {\n        for (var i = minLength; i < maxLength; i++) {\n          if (endPathCommands.length !== startPathCommands.length) {\n            if (series.removedPointIndex === series.points.length) {\n              endPathCommands.push(endPathCommands[endPathCommands.length - 1].replace('M', 'L'));\n            } else {\n              endPathCommands.splice(1, 0, endPathCommands[0].replace('M', 'L'));\n            }\n          }\n        }\n        animateAddPoints(points.element, endPathCommands.join(''), series.chart.redraw, points.previousDirection, this.chart.duration, options.d);\n      } else {\n        animateAddPoints(points.element, options.d, series.chart.redraw, points.previousDirection, this.chart.duration);\n      }\n    }\n  };\n  /**\n   * Adds a area path to equate the start and end paths.\n   *\n   * @param {PathOption} options - The options for the path.\n   * @param {Series} series - The series to which the path belongs.\n   * @param {string} clipRect - The clip rectangle for the path.\n   * @returns {void}\n   * @private\n   */\n  LineBase.prototype.addAreaPath = function (options, series, clipRect) {\n    var points = this.appendPathElement(options, series, clipRect);\n    if (points.previousDirection !== '' && options.d !== '') {\n      var startPathCommands = points.previousDirection.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);\n      var endPathCommands = options.d.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);\n      var maxLength = Math.max(startPathCommands.length, endPathCommands.length);\n      var minLength = Math.min(startPathCommands.length, endPathCommands.length);\n      if (minLength < endPathCommands.length) {\n        for (var i = minLength; i < maxLength; i++) {\n          if (endPathCommands.length !== startPathCommands.length) {\n            if (endPathCommands.length !== startPathCommands.length) {\n              if (startPathCommands.length === 1) {\n                startPathCommands.push(startPathCommands[startPathCommands.length - (options.id.indexOf('border') !== -1 ? 1 : 2)].replace('M', 'L'));\n              } else {\n                startPathCommands.splice(startPathCommands.length - 1, 0, startPathCommands[startPathCommands.length - (options.id.indexOf('border') !== -1 ? 1 : 2)]);\n              }\n            }\n          }\n        }\n        animateAddPoints(points.element, options.d, series.chart.redraw, startPathCommands.join(' '), this.chart.duration);\n      } else if (startPathCommands.length > endPathCommands.length) {\n        for (var i = minLength; i < maxLength; i++) {\n          if (endPathCommands.length !== startPathCommands.length) {\n            if (series.removedPointIndex === series.points.length) {\n              if (endPathCommands.length === 1) {\n                endPathCommands.push(endPathCommands[endPathCommands.length - (options.id.indexOf('border') !== -1 ? 1 : 2)].replace('M', 'L'));\n              } else {\n                endPathCommands.splice(endPathCommands.length - 1, 0, endPathCommands[endPathCommands.length - (options.id.indexOf('border') !== -1 ? 1 : 2)]);\n              }\n            } else {\n              endPathCommands.splice(1, 0, endPathCommands[1] ? endPathCommands[1] : endPathCommands[0]);\n            }\n          }\n        }\n        animateAddPoints(points.element, endPathCommands.join(''), series.chart.redraw, points.previousDirection, this.chart.duration, options.d);\n      } else {\n        animateAddPoints(points.element, options.d, series.chart.redraw, points.previousDirection, this.chart.duration);\n      }\n    }\n  };\n  /**\n   * To render the marker for the series.\n   *\n   * @param {Series} series - The series for which markers are rendered.\n   * @returns {void}\n   * @private\n   */\n  LineBase.prototype.renderMarker = function (series) {\n    if (series.marker && series.marker.visible) {\n      series.chart.markerRender.render(series);\n    }\n  };\n  /**\n   * Executes progressive animation for the series.\n   *\n   * @param {Series} series - The series for which progressive animation is executed.\n   * @param {AnimationModel} option - The animation option.\n   * @returns {void}\n   * @private\n   */\n  LineBase.prototype.doProgressiveAnimation = function (series, option) {\n    var animation = new Animation({});\n    var path = series.pathElement;\n    var strokeDashArray = path.getAttribute('stroke-dasharray');\n    var pathLength = series.pathElement.getTotalLength();\n    var currentTime;\n    path.style.visibility = 'hidden';\n    animation.animate(path, {\n      duration: option.duration === 0 && animationMode === 'Enable' ? 1000 : option.duration,\n      delay: option.delay,\n      progress: function (args) {\n        path.style.visibility = 'visible';\n        currentTime = Math.abs(Math.round(args.timeStamp * pathLength / args.duration));\n        path.setAttribute('stroke-dasharray', currentTime + ',' + pathLength);\n      },\n      end: function () {\n        var annotations = getElement(series.chart.element.id + '_Annotation_Collections');\n        if (annotations) {\n          annotations.style.visibility = 'visible';\n        }\n        path.setAttribute('stroke-dasharray', strokeDashArray);\n        path.style.visibility = '';\n        series.chart.trigger('animationComplete', {\n          series: series.chart.isBlazor ? {} : series\n        });\n      }\n    });\n  };\n  /**\n   * To store the symbol location and region.\n   *\n   * @param {Points} point point\n   * @param {Series} series series\n   * @param {boolean} isInverted isInverted\n   * @param {Function} getLocation getLocation\n   * @returns {void}\n   * @private\n   */\n  LineBase.prototype.storePointLocation = function (point, series, isInverted, getLocation) {\n    var markerWidth = series.marker && series.marker.width ? series.marker.width : 0;\n    var markerHeight = series.marker && series.marker.height ? series.marker.height : 0;\n    point.symbolLocations.push(getLocation(point.xValue, point.yValue, series.xAxis, series.yAxis, isInverted, series));\n    point.regions.push(new Rect(point.symbolLocations[0].x - markerWidth, point.symbolLocations[0].y - markerHeight, 2 * markerWidth, 2 * markerHeight));\n  };\n  /**\n   * Checks if the y-value of a point falls within the y-axis range.\n   *\n   * @param {Points} point - The point to be checked.\n   * @param {Axis} yAxis - The y-axis.\n   * @returns {boolean} - Returns true if the y-value falls within the y-axis range, otherwise false.\n   * @private\n   */\n  LineBase.prototype.withinYRange = function (point, yAxis) {\n    return point.yValue >= yAxis.visibleRange.min && point.yValue <= yAxis.visibleRange.max;\n  };\n  LineBase.prototype.GetStepLineDirection = function (currentPoint, previousPoint, stepLineType, command, series, isBorder) {\n    if (command === void 0) {\n      command = 'L';\n    }\n    var X = series.noRisers && isBorder ? ' M ' : ' L ';\n    if (stepLineType === 'Right') {\n      command = series.noRisers && isBorder ? 'M' : 'L';\n      return command + ' ' + previousPoint.x + ' ' + currentPoint.y + ' L ' + currentPoint.x + ' ' + currentPoint.y + ' ';\n    } else if (stepLineType === 'Center') {\n      var centerX = previousPoint.x + (currentPoint.x - previousPoint.x) / 2;\n      return command + ' ' + centerX + ' ' + previousPoint.y + X + centerX + ' ' + currentPoint.y + ' L ' + currentPoint.x + ' ' + currentPoint.y + ' ';\n    } else {\n      return command + ' ' + currentPoint.x + ' ' + previousPoint.y + X + currentPoint.x + ' ' + currentPoint.y + ' ';\n    }\n  };\n  /**\n   * Gets the first and last visible points from a collection of points.\n   *\n   * @param {Points[]} points - Collection of points.\n   * @returns {{ first: Points, last: Points }} - Returns an object containing the first and last visible points.\n   * @private\n   */\n  LineBase.prototype.getFirstLastVisiblePoint = function (points) {\n    var first = null;\n    var last = null;\n    for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {\n      var point = points_1[_i];\n      if (first === null && point.visible) {\n        first = last = point;\n      }\n      last = point.visible ? point : last;\n    }\n    return {\n      first: first ? first : points[0],\n      last: last ? last : points[points.length - 1]\n    };\n  };\n  /**\n   * Gets the border direction based on the provided direction.\n   *\n   * @param {string} direction - The direction string.\n   * @returns {string} - Returns the border direction.\n   * @private\n   */\n  LineBase.prototype.getBorderDirection = function (direction) {\n    var coordinates = direction.split(' ');\n    if (coordinates.length > 3 && !this.chart.stackingAreaSeriesModule && !this.chart.stackingStepAreaSeriesModule) {\n      coordinates.splice(coordinates.length - 4, 3);\n    } else if (this.chart.stackingAreaSeriesModule || this.chart.stackingStepAreaSeriesModule) {\n      coordinates.splice(coordinates.length / 2 + 1, coordinates.length / 2 + 1);\n      if (coordinates[coordinates.length - 1] === 'L' || coordinates[coordinates.length - 1] === 'M') {\n        coordinates.splice(coordinates.length - 1, 1);\n      }\n    }\n    return coordinates.join(' ');\n  };\n  /**\n   * Removes the border from the empty points based on the provided border direction.\n   *\n   * @param {string} borderDirection - The border direction.\n   * @returns {string} - Returns the updated border direction.\n   * @private\n   */\n  LineBase.prototype.removeEmptyPointsBorder = function (borderDirection) {\n    var startIndex = 0;\n    var coordinates = borderDirection.split(' ');\n    var point;\n    if (coordinates.length === 4) {\n      return coordinates.join(' ');\n    }\n    do {\n      point = coordinates.indexOf('M', startIndex);\n      if (point > -1) {\n        coordinates.splice(point + 1, 3);\n        startIndex = point + 1;\n        if (point - 6 > 0) {\n          coordinates.splice(point - 6, 6);\n          startIndex -= 6;\n        }\n      }\n    } while (point !== -1);\n    return coordinates.join(' ');\n  };\n  /**\n   * Performs linear animation for the series based on the provided animation model.\n   *\n   * @param {Series} series - The series to animate.\n   * @param {AnimationModel} animation - The animation model containing animation details.\n   * @returns {void}\n   * @private\n   */\n  LineBase.prototype.doLinearAnimation = function (series, animation) {\n    var clipRect = series.clipRectElement.childNodes[0].childNodes[0];\n    var duration = series.chart.animated ? series.chart.duration : animation.duration;\n    var effect = getAnimationFunction('Linear');\n    var elementHeight = +clipRect.getAttribute('height');\n    var elementWidth = +clipRect.getAttribute('width');\n    var xCenter = +clipRect.getAttribute('x');\n    var yCenter = series.chart.requireInvertedAxis ? +clipRect.getAttribute('height') + +clipRect.getAttribute('y') : +clipRect.getAttribute('y');\n    var value;\n    clipRect.style.visibility = 'hidden';\n    this.animateRect(series, animation, clipRect, duration, effect, elementHeight, elementWidth, xCenter, yCenter, value);\n    if (series.marker && series.marker.visible && series.symbolElement) {\n      var markerClipRect = series.symbolElement.childNodes[0].childNodes[0];\n      markerClipRect.style.visibility = 'hidden';\n      this.animateRect(series, animation, markerClipRect, duration, effect, elementHeight, elementWidth, xCenter, yCenter, value);\n    }\n  };\n  /**\n   * Animates the given clip rectangle with the specified animation parameters.\n   *\n   * @param {Series} series - The series to which the clip rectangle belongs.\n   * @param {AnimationModel} animation - The animation model containing animation details.\n   * @param {HTMLElement} clipRect - The clip rectangle to animate.\n   * @param {number} duration - The duration of the animation.\n   * @param {Function} effect - The animation function to use.\n   * @param {number} elementHeight - The height of the clip rectangle element.\n   * @param {number} elementWidth - The width of the clip rectangle element.\n   * @param {number} xCenter - The x-coordinate of the clip rectangle's center.\n   * @param {number} yCenter - The y-coordinate of the clip rectangle's center.\n   * @param {number} value - The animation value.\n   * @returns {void}\n   */\n  LineBase.prototype.animateRect = function (series, animation, clipRect, duration, effect, elementHeight, elementWidth, xCenter, yCenter, value) {\n    new Animation({}).animate(clipRect, {\n      duration: duration === 0 && animationMode === 'Enable' ? 1000 : duration,\n      delay: animation.delay,\n      progress: function (args) {\n        clipRect.style.visibility = 'visible';\n        if (series.chart.requireInvertedAxis) {\n          value = effect(args.timeStamp, 0, elementHeight, args.duration);\n          clipRect.setAttribute('transform', 'translate(' + xCenter + ' ' + yCenter + ') scale(1,' + value / elementHeight + ') translate(' + -xCenter + ' ' + -yCenter + ')');\n        } else {\n          value = effect(args.timeStamp, 0, elementWidth, args.duration);\n          clipRect.setAttribute('transform', 'translate(' + xCenter + ' ' + yCenter + ') scale(' + value / elementWidth + ', 1) translate(' + -xCenter + ' ' + -yCenter + ')');\n        }\n      },\n      end: function () {\n        var annotations = getElement(series.chart.element.id + '_Annotation_Collections');\n        if (annotations) {\n          annotations.style.visibility = 'visible';\n        }\n        var stackLabelGroup = document.getElementById(series.chart.element.id + '_StackLabelGroup');\n        if (stackLabelGroup) {\n          stackLabelGroup.setAttribute('visibility', 'visible');\n        }\n        clipRect.setAttribute('transform', 'translate(0,0)');\n        series.chart.trigger('animationComplete', {\n          series: series.chart.isBlazor ? {} : series\n        });\n      }\n    });\n  };\n  return LineBase;\n}();\nexport { LineBase };","map":{"version":3,"names":["getAnimationFunction","pathAnimation","getElement","animateAddPoints","Rect","Animation","animationMode","isNullOrUndefined","LineBase","chartModule","chart","prototype","enableComplexProperty","series","tempPoints","tempPoints2","xVisibleRange","xAxis","visibleRange","yVisibleRange","yAxis","seriesPoints","points","areaBounds","clipRect","xTolerance","zoomRedraw","redraw","previousX","Math","abs","delta","width","yTolerance","previousY","height","prevXValue","xValue","prevYValue","y","xVal","yVal","_i","seriesPoints_1","length","currentPoint","symbolLocations","min","yValue","push","tempPoint","i","x","category","isNaN","getLineDirection","firstPoint","secondPoint","isInverted","getPointLocation","startPoint","direction","point1","point2","appendLinePath","options","appendPathElement","element","d","previousDirection","duration","id","getAttribute","htmlObject","renderer","drawPath","Int32Array","setAttribute","trendline","sourceIndex","trendlines","index","marker","visible","accessibility","focusable","String","tabIndex","accessibilityRole","accessibilityDescription","pathElement","enableCanvas","seriesElement","appendChild","isRectSeries","addPath","startPathCommands","match","endPathCommands","maxLength","max","minLength","replace","join","removedPointIndex","splice","addAreaPath","indexOf","renderMarker","markerRender","render","doProgressiveAnimation","option","animation","path","strokeDashArray","pathLength","getTotalLength","currentTime","style","visibility","animate","delay","progress","args","round","timeStamp","end","annotations","trigger","isBlazor","storePointLocation","point","getLocation","markerWidth","markerHeight","regions","withinYRange","GetStepLineDirection","previousPoint","stepLineType","command","isBorder","X","noRisers","centerX","getFirstLastVisiblePoint","first","last","points_1","getBorderDirection","coordinates","split","stackingAreaSeriesModule","stackingStepAreaSeriesModule","removeEmptyPointsBorder","borderDirection","startIndex","doLinearAnimation","clipRectElement","childNodes","animated","effect","elementHeight","elementWidth","xCenter","yCenter","requireInvertedAxis","value","animateRect","symbolElement","markerClipRect","stackLabelGroup","document","getElementById"],"sources":["C:/Users/mkfun/Desktop/ct assignment/admin/node_modules/@syncfusion/ej2-charts/src/chart/series/line-base.js"],"sourcesContent":["import { getAnimationFunction, pathAnimation, getElement, animateAddPoints } from '../../common/utils/helper';\nimport { Rect } from '@syncfusion/ej2-svg-base';\nimport { Animation, animationMode, isNullOrUndefined } from '@syncfusion/ej2-base';\n/**\n * Base class for line-type series.\n * This class provides common properties and methods for line-type series in the chart.\n *\n * @private\n */\nvar LineBase = /** @class */ (function () {\n    /**\n     * Initializes the tooltip module for the chart.\n     *\n     * @param {Chart} [chartModule] - The chart instance to which the tooltip module is initialized.\n     */\n    function LineBase(chartModule) {\n        this.chart = chartModule;\n    }\n    /**\n     * Enhances the performance of the chart by enabling complex properties.\n     *\n     * @param {Series} series - The series for which complex properties are enabled.\n     * @returns {Points[]} An array of points.\n     * @private\n     */\n    LineBase.prototype.enableComplexProperty = function (series) {\n        var tempPoints = [];\n        var tempPoints2 = [];\n        var xVisibleRange = series.xAxis.visibleRange;\n        var yVisibleRange = series.yAxis.visibleRange;\n        var seriesPoints = series.points;\n        var areaBounds = series.clipRect;\n        var xTolerance = this.chart && this.chart.zoomRedraw && this.chart.redraw ? this.previousX :\n            Math.abs(xVisibleRange.delta / areaBounds.width);\n        var yTolerance = this.chart && this.chart.zoomRedraw && this.chart.redraw ? this.previousY :\n            Math.abs(yVisibleRange.delta / areaBounds.height);\n        var prevXValue = (seriesPoints[0] && seriesPoints[0].xValue > xTolerance) ? 0 : xTolerance;\n        var prevYValue = (seriesPoints[0] && seriesPoints[0].y > yTolerance) ? 0 : yTolerance;\n        this.previousX = xTolerance;\n        this.previousY = yTolerance;\n        var xVal = 0;\n        var yVal = 0;\n        for (var _i = 0, seriesPoints_1 = seriesPoints; _i < seriesPoints_1.length; _i++) {\n            var currentPoint = seriesPoints_1[_i];\n            currentPoint.symbolLocations = [];\n            xVal = !isNullOrUndefined(currentPoint.xValue) ? currentPoint.xValue : xVisibleRange.min;\n            yVal = !isNullOrUndefined(currentPoint.yValue) ? currentPoint.yValue : yVisibleRange.min;\n            if (Math.abs(prevXValue - xVal) >= xTolerance || Math.abs(prevYValue - yVal) >= yTolerance) {\n                tempPoints.push(currentPoint);\n                prevXValue = xVal;\n                prevYValue = yVal;\n            }\n        }\n        var tempPoint;\n        for (var i = 0; i < tempPoints.length; i++) {\n            tempPoint = tempPoints[i];\n            if (isNullOrUndefined(tempPoint.x) || (series.category === 'Indicator' && (isNaN(tempPoint.xValue) || isNaN(tempPoint.yValue)))) {\n                continue;\n            }\n            else {\n                tempPoints2.push(tempPoint);\n            }\n        }\n        return tempPoints2;\n    };\n    /**\n     * To generate the line path direction.\n     *\n     * @param {Points} firstPoint firstPoint\n     * @param {Points} secondPoint secondPoint\n     * @param {Series} series series\n     * @param {boolean} isInverted isInverted\n     * @param {Function} getPointLocation getPointLocation\n     * @param {string} startPoint startPoint\n     * @returns {string} get line path direction\n     * @private\n     */\n    LineBase.prototype.getLineDirection = function (firstPoint, secondPoint, series, isInverted, getPointLocation, startPoint) {\n        var direction = '';\n        if (firstPoint != null) {\n            var point1 = getPointLocation(firstPoint.xValue, firstPoint.yValue, series.xAxis, series.yAxis, isInverted, series);\n            var point2 = getPointLocation(secondPoint.xValue, secondPoint.yValue, series.xAxis, series.yAxis, isInverted, series);\n            direction = startPoint + ' ' + (point1.x) + ' ' + (point1.y) + ' ' +\n                'L' + ' ' + (point2.x) + ' ' + (point2.y) + ' ';\n        }\n        return direction;\n    };\n    /**\n     * Appends a line path to the chart.\n     *\n     * @param {PathOption} options - The options for the path.\n     * @param {Series} series - The series to which the path belongs.\n     * @param {string} clipRect - The clipping rectangle for the path.\n     * @returns {void}\n     * @private\n     */\n    LineBase.prototype.appendLinePath = function (options, series, clipRect) {\n        var points = this.appendPathElement(options, series, clipRect);\n        pathAnimation(points.element, options.d, series.chart.redraw, points.previousDirection, points.chart.duration);\n    };\n    LineBase.prototype.appendPathElement = function (options, series, clipRect) {\n        var element = getElement(options.id);\n        var chart = series.chart;\n        var previousDirection = element ? element.getAttribute('d') : null;\n        var htmlObject = series.chart.renderer.drawPath(options, new Int32Array([series.clipRect.x, series.clipRect.y]));\n        if (htmlObject) {\n            htmlObject.setAttribute('clip-path', clipRect);\n        }\n        if (series.category === 'TrendLine' && htmlObject) {\n            var trendline = chart.series[series.sourceIndex].trendlines[series.index];\n            if (!trendline.marker.visible) {\n                htmlObject.setAttribute('tabindex', trendline.accessibility.focusable ? String(trendline.accessibility.tabIndex) : '-1');\n            }\n            htmlObject.setAttribute('role', trendline.accessibility.accessibilityRole ? trendline.accessibility.accessibilityRole : '');\n            htmlObject.setAttribute('aria-label', trendline.accessibility.accessibilityDescription ? trendline.accessibility.accessibilityDescription : '');\n        }\n        series.pathElement = htmlObject;\n        if (!series.chart.enableCanvas) {\n            series.seriesElement.appendChild(htmlObject);\n        }\n        series.isRectSeries = false;\n        return { element: element, previousDirection: previousDirection, chart: chart };\n    };\n    /**\n     * Adds a line path to equate the start and end paths.\n     *\n     * @param {PathOption} options - The options for the path.\n     * @param {Series} series - The series to which the path belongs.\n     * @param {string} clipRect - The clip rectangle for the path.\n     * @returns {void}\n     * @private\n     */\n    LineBase.prototype.addPath = function (options, series, clipRect) {\n        var points = this.appendPathElement(options, series, clipRect);\n        if (points.previousDirection !== '' && options.d !== '') {\n            var startPathCommands = points.previousDirection.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);\n            var endPathCommands = (options.d).match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);\n            var maxLength = Math.max(startPathCommands.length, endPathCommands.length);\n            var minLength = Math.min(startPathCommands.length, endPathCommands.length);\n            if (startPathCommands.length < endPathCommands.length) {\n                for (var i = minLength; i < maxLength; i++) {\n                    if (endPathCommands.length !== startPathCommands.length) {\n                        startPathCommands.push((startPathCommands[startPathCommands.length - 1]).replace('M', 'L'));\n                    }\n                }\n                animateAddPoints(points.element, options.d, series.chart.redraw, startPathCommands.join(' '), this.chart.duration);\n            }\n            else if (startPathCommands.length > endPathCommands.length) {\n                for (var i = minLength; i < maxLength; i++) {\n                    if (endPathCommands.length !== startPathCommands.length) {\n                        if (series.removedPointIndex === series.points.length) {\n                            endPathCommands.push((endPathCommands[endPathCommands.length - 1]).replace('M', 'L'));\n                        }\n                        else {\n                            endPathCommands.splice(1, 0, endPathCommands[0].replace('M', 'L'));\n                        }\n                    }\n                }\n                animateAddPoints(points.element, endPathCommands.join(''), series.chart.redraw, points.previousDirection, this.chart.duration, options.d);\n            }\n            else {\n                animateAddPoints(points.element, options.d, series.chart.redraw, points.previousDirection, this.chart.duration);\n            }\n        }\n    };\n    /**\n     * Adds a area path to equate the start and end paths.\n     *\n     * @param {PathOption} options - The options for the path.\n     * @param {Series} series - The series to which the path belongs.\n     * @param {string} clipRect - The clip rectangle for the path.\n     * @returns {void}\n     * @private\n     */\n    LineBase.prototype.addAreaPath = function (options, series, clipRect) {\n        var points = this.appendPathElement(options, series, clipRect);\n        if (points.previousDirection !== '' && options.d !== '') {\n            var startPathCommands = points.previousDirection.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);\n            var endPathCommands = (options.d).match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);\n            var maxLength = Math.max(startPathCommands.length, endPathCommands.length);\n            var minLength = Math.min(startPathCommands.length, endPathCommands.length);\n            if (minLength < endPathCommands.length) {\n                for (var i = minLength; i < maxLength; i++) {\n                    if (endPathCommands.length !== startPathCommands.length) {\n                        if (endPathCommands.length !== startPathCommands.length) {\n                            if (startPathCommands.length === 1) {\n                                startPathCommands.push(startPathCommands[startPathCommands.length - (options.id.indexOf('border') !== -1 ? 1 : 2)].replace('M', 'L'));\n                            }\n                            else {\n                                startPathCommands.splice(startPathCommands.length - 1, 0, startPathCommands[startPathCommands.length - (options.id.indexOf('border') !== -1 ? 1 : 2)]);\n                            }\n                        }\n                    }\n                }\n                animateAddPoints(points.element, options.d, series.chart.redraw, startPathCommands.join(' '), this.chart.duration);\n            }\n            else if (startPathCommands.length > endPathCommands.length) {\n                for (var i = minLength; i < maxLength; i++) {\n                    if (endPathCommands.length !== startPathCommands.length) {\n                        if (series.removedPointIndex === series.points.length) {\n                            if (endPathCommands.length === 1) {\n                                endPathCommands.push(endPathCommands[endPathCommands.length - (options.id.indexOf('border') !== -1 ? 1 : 2)].replace('M', 'L'));\n                            }\n                            else {\n                                endPathCommands.splice(endPathCommands.length - 1, 0, endPathCommands[endPathCommands.length - (options.id.indexOf('border') !== -1 ? 1 : 2)]);\n                            }\n                        }\n                        else {\n                            endPathCommands.splice(1, 0, endPathCommands[1] ? endPathCommands[1] : endPathCommands[0]);\n                        }\n                    }\n                }\n                animateAddPoints(points.element, endPathCommands.join(''), series.chart.redraw, points.previousDirection, this.chart.duration, options.d);\n            }\n            else {\n                animateAddPoints(points.element, options.d, series.chart.redraw, points.previousDirection, this.chart.duration);\n            }\n        }\n    };\n    /**\n     * To render the marker for the series.\n     *\n     * @param {Series} series - The series for which markers are rendered.\n     * @returns {void}\n     * @private\n     */\n    LineBase.prototype.renderMarker = function (series) {\n        if (series.marker && series.marker.visible) {\n            series.chart.markerRender.render(series);\n        }\n    };\n    /**\n     * Executes progressive animation for the series.\n     *\n     * @param {Series} series - The series for which progressive animation is executed.\n     * @param {AnimationModel} option - The animation option.\n     * @returns {void}\n     * @private\n     */\n    LineBase.prototype.doProgressiveAnimation = function (series, option) {\n        var animation = new Animation({});\n        var path = series.pathElement;\n        var strokeDashArray = path.getAttribute('stroke-dasharray');\n        var pathLength = series.pathElement.getTotalLength();\n        var currentTime;\n        path.style.visibility = 'hidden';\n        animation.animate(path, {\n            duration: (option.duration === 0 && animationMode === 'Enable') ? 1000 : option.duration,\n            delay: option.delay,\n            progress: function (args) {\n                path.style.visibility = 'visible';\n                currentTime = Math.abs(Math.round(((args.timeStamp) * pathLength) / args.duration));\n                path.setAttribute('stroke-dasharray', currentTime + ',' + pathLength);\n            },\n            end: function () {\n                var annotations = getElement(series.chart.element.id + '_Annotation_Collections');\n                if (annotations) {\n                    annotations.style.visibility = 'visible';\n                }\n                path.setAttribute('stroke-dasharray', strokeDashArray);\n                path.style.visibility = '';\n                series.chart.trigger('animationComplete', { series: series.chart.isBlazor ? {} : series });\n            }\n        });\n    };\n    /**\n     * To store the symbol location and region.\n     *\n     * @param {Points} point point\n     * @param {Series} series series\n     * @param {boolean} isInverted isInverted\n     * @param {Function} getLocation getLocation\n     * @returns {void}\n     * @private\n     */\n    LineBase.prototype.storePointLocation = function (point, series, isInverted, getLocation) {\n        var markerWidth = (series.marker && series.marker.width) ? series.marker.width : 0;\n        var markerHeight = (series.marker && series.marker.height) ? series.marker.height : 0;\n        point.symbolLocations.push(getLocation(point.xValue, point.yValue, series.xAxis, series.yAxis, isInverted, series));\n        point.regions.push(new Rect(point.symbolLocations[0].x - markerWidth, point.symbolLocations[0].y - markerHeight, 2 * markerWidth, 2 * markerHeight));\n    };\n    /**\n     * Checks if the y-value of a point falls within the y-axis range.\n     *\n     * @param {Points} point - The point to be checked.\n     * @param {Axis} yAxis - The y-axis.\n     * @returns {boolean} - Returns true if the y-value falls within the y-axis range, otherwise false.\n     * @private\n     */\n    LineBase.prototype.withinYRange = function (point, yAxis) {\n        return point.yValue >= yAxis.visibleRange.min && point.yValue <= yAxis.visibleRange.max;\n    };\n    LineBase.prototype.GetStepLineDirection = function (currentPoint, previousPoint, stepLineType, command, series, isBorder) {\n        if (command === void 0) { command = 'L'; }\n        var X = (series.noRisers && isBorder) ? ' M ' : ' L ';\n        if (stepLineType === 'Right') {\n            command = (series.noRisers && isBorder) ? 'M' : 'L';\n            return (command + ' ' +\n                (previousPoint.x) + ' ' + (currentPoint.y) + ' L ' + (currentPoint.x) + ' ' + (currentPoint.y) + ' ');\n        }\n        else if (stepLineType === 'Center') {\n            var centerX = previousPoint.x + (currentPoint.x - previousPoint.x) / 2;\n            return (command + ' ' +\n                (centerX) + ' ' + (previousPoint.y) + X + (centerX) + ' ' + (currentPoint.y) + ' L ' + (currentPoint.x) + ' ' + (currentPoint.y) + ' ');\n        }\n        else {\n            return (command + ' ' +\n                (currentPoint.x) + ' ' + (previousPoint.y) + X + (currentPoint.x) + ' ' + (currentPoint.y) + ' ');\n        }\n    };\n    /**\n     * Gets the first and last visible points from a collection of points.\n     *\n     * @param {Points[]} points - Collection of points.\n     * @returns {{ first: Points, last: Points }} - Returns an object containing the first and last visible points.\n     * @private\n     */\n    LineBase.prototype.getFirstLastVisiblePoint = function (points) {\n        var first = null;\n        var last = null;\n        for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {\n            var point = points_1[_i];\n            if (first === null && point.visible) {\n                first = last = point;\n            }\n            last = point.visible ? point : last;\n        }\n        return { first: first ? first : points[0], last: last ? last : points[points.length - 1] };\n    };\n    /**\n     * Gets the border direction based on the provided direction.\n     *\n     * @param {string} direction - The direction string.\n     * @returns {string} - Returns the border direction.\n     * @private\n     */\n    LineBase.prototype.getBorderDirection = function (direction) {\n        var coordinates = direction.split(' ');\n        if (coordinates.length > 3 && !(this.chart.stackingAreaSeriesModule) && !(this.chart.stackingStepAreaSeriesModule)) {\n            coordinates.splice(coordinates.length - 4, 3);\n        }\n        else if (this.chart.stackingAreaSeriesModule || this.chart.stackingStepAreaSeriesModule) {\n            coordinates.splice(coordinates.length / 2 + 1, coordinates.length / 2 + 1);\n            if (coordinates[coordinates.length - 1] === 'L' || coordinates[coordinates.length - 1] === 'M') {\n                coordinates.splice(coordinates.length - 1, 1);\n            }\n        }\n        return coordinates.join(' ');\n    };\n    /**\n     * Removes the border from the empty points based on the provided border direction.\n     *\n     * @param {string} borderDirection - The border direction.\n     * @returns {string} - Returns the updated border direction.\n     * @private\n     */\n    LineBase.prototype.removeEmptyPointsBorder = function (borderDirection) {\n        var startIndex = 0;\n        var coordinates = borderDirection.split(' ');\n        var point;\n        if (coordinates.length === 4) {\n            return coordinates.join(' ');\n        }\n        do {\n            point = coordinates.indexOf('M', startIndex);\n            if (point > -1) {\n                coordinates.splice(point + 1, 3);\n                startIndex = point + 1;\n                if (point - 6 > 0) {\n                    coordinates.splice(point - 6, 6);\n                    startIndex -= 6;\n                }\n            }\n        } while (point !== -1);\n        return coordinates.join(' ');\n    };\n    /**\n     * Performs linear animation for the series based on the provided animation model.\n     *\n     * @param {Series} series - The series to animate.\n     * @param {AnimationModel} animation - The animation model containing animation details.\n     * @returns {void}\n     * @private\n     */\n    LineBase.prototype.doLinearAnimation = function (series, animation) {\n        var clipRect = series.clipRectElement.childNodes[0].childNodes[0];\n        var duration = series.chart.animated ? series.chart.duration : animation.duration;\n        var effect = getAnimationFunction('Linear');\n        var elementHeight = +clipRect.getAttribute('height');\n        var elementWidth = +clipRect.getAttribute('width');\n        var xCenter = +clipRect.getAttribute('x');\n        var yCenter = series.chart.requireInvertedAxis ? +clipRect.getAttribute('height') + +clipRect.getAttribute('y') :\n            +clipRect.getAttribute('y');\n        var value;\n        clipRect.style.visibility = 'hidden';\n        this.animateRect(series, animation, clipRect, duration, effect, elementHeight, elementWidth, xCenter, yCenter, value);\n        if (series.marker && series.marker.visible && series.symbolElement) {\n            var markerClipRect = series.symbolElement.childNodes[0].childNodes[0];\n            markerClipRect.style.visibility = 'hidden';\n            this.animateRect(series, animation, markerClipRect, duration, effect, elementHeight, elementWidth, xCenter, yCenter, value);\n        }\n    };\n    /**\n     * Animates the given clip rectangle with the specified animation parameters.\n     *\n     * @param {Series} series - The series to which the clip rectangle belongs.\n     * @param {AnimationModel} animation - The animation model containing animation details.\n     * @param {HTMLElement} clipRect - The clip rectangle to animate.\n     * @param {number} duration - The duration of the animation.\n     * @param {Function} effect - The animation function to use.\n     * @param {number} elementHeight - The height of the clip rectangle element.\n     * @param {number} elementWidth - The width of the clip rectangle element.\n     * @param {number} xCenter - The x-coordinate of the clip rectangle's center.\n     * @param {number} yCenter - The y-coordinate of the clip rectangle's center.\n     * @param {number} value - The animation value.\n     * @returns {void}\n     */\n    LineBase.prototype.animateRect = function (series, animation, clipRect, duration, effect, elementHeight, elementWidth, xCenter, yCenter, value) {\n        new Animation({}).animate(clipRect, {\n            duration: (duration === 0 && animationMode === 'Enable') ? 1000 : duration,\n            delay: animation.delay,\n            progress: function (args) {\n                clipRect.style.visibility = 'visible';\n                if (series.chart.requireInvertedAxis) {\n                    value = effect(args.timeStamp, 0, elementHeight, args.duration);\n                    clipRect.setAttribute('transform', 'translate(' + xCenter + ' ' + yCenter +\n                        ') scale(1,' + (value / elementHeight) + ') translate(' + (-xCenter) + ' ' + (-yCenter) + ')');\n                }\n                else {\n                    value = effect(args.timeStamp, 0, elementWidth, args.duration);\n                    clipRect.setAttribute('transform', 'translate(' + xCenter + ' ' + yCenter +\n                        ') scale(' + (value / elementWidth) + ', 1) translate(' + (-xCenter) + ' ' + (-yCenter) + ')');\n                }\n            },\n            end: function () {\n                var annotations = getElement(series.chart.element.id + '_Annotation_Collections');\n                if (annotations) {\n                    annotations.style.visibility = 'visible';\n                }\n                var stackLabelGroup = document.getElementById(series.chart.element.id + '_StackLabelGroup');\n                if (stackLabelGroup) {\n                    stackLabelGroup.setAttribute('visibility', 'visible');\n                }\n                clipRect.setAttribute('transform', 'translate(0,0)');\n                series.chart.trigger('animationComplete', { series: series.chart.isBlazor ? {} : series });\n            }\n        });\n    };\n    return LineBase;\n}());\nexport { LineBase };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}